<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emacs | Deliberate Software]]></title>
  <link href="http://deliberate-software.com/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://deliberate-software.com/"/>
  <updated>2016-02-05T07:12:27-05:00</updated>
  <id>http://deliberate-software.com/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Emacs Project Tip]]></title>
    <link href="http://deliberate-software.com/emacs-project-tip/"/>
    <updated>2014-12-06T08:45:00-05:00</updated>
    <id>http://deliberate-software.com/emacs-project-tip</id>
    <content type="html"><![CDATA[<p>I recently have been working in a Clojure project which is made up of
several microservices. While trying to build in a secure method for
each service to be able to call the others, I&rsquo;ve been in several
different projects at the same time.</p>

<p>At least once I accidentally opened the wrong &ldquo;handler.clj&rdquo; buffer,
and spent a few minutes adding a function that never worked. Since I
hate doing things like this, I wanted a simple way to see what project
I was currently viewing.</p>

<p>I started with a changing the title of the frame to show the whole
path of the current buffer, like this:</p>

<p><img class="center" src="/images/title.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code to change the title is simple, and the default in some of the
pre-packaged emacs bundles:</p>

<pre><code class="common-lisp">(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
</code></pre>

<p>This is fine, but still not great. The font is tiny and the important
part: &ldquo;octopress&rdquo; is buried. I wanted something a little more fluid,
so I could easily tell the different projects apart instantly. I came
up with the idea to color the background faintly different based on
the path of the file. Files with a path containing &ldquo;octopress&rdquo; might
be different from those containing &ldquo;.emacs&rdquo;.</p>

<p>Thankfully, <code>buffer-face-mode</code> makes it easy to change a single
property of a single buffer&rsquo;s face without changing any other
buffer. So long as you disable buffer-face-mode when closing emacs,
your files will open with the correct coloring scheme, then have the
new background overlaid.</p>

<p>While not perfect, this was the result.</p>

<p><img class="center" src="/images/colors.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The colors I choose are only faintly different, but just enough for me
to tell instantly which is which.</p>

<p>The buffer colors are applied when opening a file, using these
functions:</p>

<pre><code class="common-lisp">(defun my-buffer-face-mode-variable (color)
  (interactive)
  (setq buffer-face-mode-face (list :background color))
  (buffer-face-mode 1))

(defun my-set-theme-on-mode ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (cond
    ;; add your own project/color mappings here
     ((string-match "halcyon" file-name) (my-buffer-face-mode-variable "#00001A"))
     ((string-match "dwarf" file-name) (my-buffer-face-mode-variable "#001A1A"))
     ((string-match "nimbus" file-name) (my-buffer-face-mode-variable "black"))
     (t ""))))
</code></pre>

<p>To force them to run when opening a file, since I use helm, I set it
to execute on exiting helm for any reason:</p>

<pre><code class="common-lisp">(add-hook 'helm-after-action-hook 'my-set-theme-on-mode)
;; uncomment if not using helm
;; (add-hook 'find-file-hook 'my-set-theme-on-mode)
</code></pre>

<p>Lastly, to make sure emacs applies my normal theme and settings to a
buffer when starting, I disable buffer-face-mode on all buffers before
exiting.</p>

<pre><code class="common-lisp">(defun disable-all-buffer-face-mode ()
  (interactive)
  (let ((current (get-buffer (current-buffer))))
    (-map (lambda (x) (progn (switch-to-buffer x)
                             (buffer-face-mode 0))) (buffer-list))
    (switch-to-buffer current 1)))

(add-hook 'kill-emacs-hook 'disable-all-buffer-face-mode)
</code></pre>

<p>This block needs <a href="https://github.com/magnars/dash.el">dash.el</a> to get
the -map function.</p>

<p>While not the only solution, this seemed a simple and elegant way to
quickly be reminded of your current project.</p>

<p>Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Endless Debate]]></title>
    <link href="http://deliberate-software.com/the-endless-debate/"/>
    <updated>2011-07-22T00:00:00-04:00</updated>
    <id>http://deliberate-software.com/the-endless-debate</id>
    <content type="html"><![CDATA[<p><p><br />The last three and a half years for me have been terrible. Why? Well, three and half years ago, I discovered the endless debate, Emacs vs. Vim. Being an efficiency nut, I could not fathom the horror of learning one, and by that action, not learning the other. What if the one I learned was not the &ldquo;best&rdquo; one? I could see that both were excellent and worth learning, but I wanted to learn both concurrently. Unfortunately, my body has a hard time learning two completely different keyboard systems at the same time. Heck, three and a half years ago, I was still learning to touch-type. <p /> So, three years pass, and I am now no farther along. <p />Additionally, I read on an almost weekly basis, articles that explain how great Emacs and vim are, you just need to learn one, and learn it well. I wanted to stick with Emacs, for the built-in lisp, and <a href="http://blog.vivekhaldar.com/post/3996068979/the-levels-of-emacs-proficiency">several</a> of my <a href="http://sites.google.com/site/steveyegge2/effective-emacs">favorite</a> programmers highly advocate it. But, I wanted to pick up vim, because it is obviously the far superior text editor, and the default on Linux, and probably will help me not get Emacs <a href="http://xahlee.blogspot.com/2010/06/famous-emacs-people-with-hand-injuries.html">RSI</a> but, perversely, it is not nearly as easy to extend as Emacs. <p /> So, the debate raged in my head for three years, and I stupidly got better at neither. Then, the other day, it clicked. Vim is the greatest text editor of them all, with text objects, highly combine-able commands, and modal editing. Emacs is the greatest IDE of all, with an awesome programming language built-in and thousands of classes and libraries to build on. Vim is built in the tradition of a small, sharp UNIX tool; Emacs in the tradition of HAVING thousands of small sharp tools. <p /> Finally, in a rush, it clicked into place with earth-shattering force: I can make Vim inside Emacs, with lisp, but I really could not remake Emacs inside Vim. <p />Suddenly, in one glorious moment, the world all made sense. Vim, the greatest text editor, should be a part of Emacs, the greatest IDE! My searching had been in vain, there was no way to compare them, they are totally different tools!<p /> In my typical child-like innocence, I rolled up my sleeves, opened up an instance of Emacs, and started making Vim. A few hours later, Google pointed out the obvious: Emacs already has a vi mode built-in (viper). Better yet, with a simple file in the right place, I had <a href="http://www.emacswiki.org/emacs-es/Vimpulse">vimpulse </a>(the practically complete Vim mode) installed and ready to go. Suddenly, a huge weight lifted off my chest. I am free to use the best tool for the job, and, like Huck Finn, float off down the river, leaving silly feuds behind me. If my actions here seem unnatural, an abomination, an unholy union, I encourage you, leave behind the fan-boyism, pick up your tools, and come build something with men who see their tools for what they truly are: <span style="text-decoration:underline;">not a good hill to die on</span>.</p></p>
]]></content>
  </entry>
  
</feed>
