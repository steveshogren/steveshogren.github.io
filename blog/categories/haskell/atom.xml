<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | Deliberate Software]]></title>
  <link href="http://deliberate-software.com/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://deliberate-software.com/"/>
  <updated>2016-02-19T17:11:44-05:00</updated>
  <id>http://deliberate-software.com/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Haskell is the Dark Souls of Programming]]></title>
    <link href="http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/"/>
    <updated>2016-02-06T11:22:29-05:00</updated>
    <id>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming</id>
    <content type="html"><![CDATA[<p>HUMOROUS POST AHEAD. Please don&rsquo;t hit me, Haskell does a great job of that
already.</p>

<p><img class="center solaire" src="/images/altar_of_sunlight.gif" width="500" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<p>I decided to start the next version of my safety score posts. This time,
however, I decided to do it in Haskell. I love Haskell for the same reasons I
love Dark Souls. Fantastic and inscrutable lore, a great <del>combat</del> type
system, a cliff-wall difficulty curve, and unending punishment.</p>

<p>I want to collect some statistics from the GitHub API. Watch as I retrace my
steps attempting the Tomb of the Dread HTTPS GET Request.</p>

<h3>Step One - Stack (aka Pride Comes Before The Fall)</h3>

<p>I download stack and start a project:</p>

<pre><code>&gt; cd /home/jack/programming &amp;&amp; stack new github-stats &amp;&amp; cd github-stats
Downloading template "new-template" to create project "github-stats" in github-stats/ ...
 ......
All done.
</code></pre>

<p>So far so good. Does it work?</p>

<pre><code class="">  &gt; stack build &amp;&amp; stack exec -- github-stats-exe 
   github-stats-0.1.0.0: configure
   ..... 
   Registering github-stats-0.1.0.0...
   someFunc
</code></pre>

<p>Awww yisss. This is going to be so easy!</p>

<h3>Step Two - HTTPS GET Request (aka The Fall After The Pride)</h3>

<p><img class="center giants" src="/images/tomb_of_the_giants.gif" width="450" title="&lsquo;giants&rsquo; &lsquo;giants&rsquo;" ></p>

<p>Now I need to query the GitHub API. Not my first time to the rodeo, I generate a
personal access token from GitHub and copy it to a local file. What query should
I run first? How about the count for all ASM tetris repositories? Poking around
the <a href="https://developer.github.com/v3/search/#search-repositories">docs</a> comes up
with:</p>

<pre><code class="">GET https://api.github.com/search/repositories?q=tetris+language:assembly&amp;sort=stars&amp;order=desc
User-Agent: steveshogren
Authorization: token PUT_TOKEN_HERE
</code></pre>

<blockquote><p>{.. &ldquo;total_count&rdquo;: 354}</p></blockquote>

<p>Easy life. Now how do you GET a resource in Haskell? Ah,
<a href="https://hackage.haskell.org/package/HTTP-4000.3.2/docs/Network-HTTP.html">Network.HTTP</a>!
I copy the front page sample into <code>src/Lib.hs</code></p>

<pre><code class="haskell">module Lib
    ( someFunc
    ) where

x = simpleHTTP (getRequest "https://www.github.com/") &gt;&gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = 
   print x
</code></pre>

<p>So simple! This is why laugh at my NodeJS loving friends! What a bunch of cretins.</p>

<pre><code>&gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
</code></pre>

<p>Doesn&rsquo;t compile. Durp, hackage is a package library, I need to add this to my
cabal. What is the name of the package? HTTP-4000? HTTP-4000.3.2? Nothing in
hackage seems to indicate what goes into the cabal file. I discover it is just
HTTP through trial and error. I update my cabal file&hellip; in all three
build-depends&hellip;?</p>

<pre><code>  build-depends:       base &gt;= 4.7 &amp;&amp; &lt; 5
                       , HTTP
</code></pre>

<p>Hrm, same error.</p>

<pre><code>&gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
</code></pre>

<p>Oh, durp, I&rsquo;d need an import. (WHY ISN&rsquo;T THIS IN THE CODE SAMPLE?!) Also, print
doesn&rsquo;t work, I need <code>putStrLn</code>.</p>

<pre><code class="haskell">import Network.HTTP

x = simpleHTTP (getRequest "https://www.github.com/") &gt;&gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = x &gt;&gt;= putStrLn
</code></pre>

<p>Here goes!!!</p>

<pre><code> &gt; stack build &amp;&amp; stack exec -- github-stats-exe
github-stats-exe: user error (https not supported)
</code></pre>

<p>Wat. Further inspection of the docs shows a line WAAY DOWN in paragraph 5.</p>

<blockquote><p>NOTE: This package only supports HTTP;</p></blockquote>

<p><img class="center giants" src="/images/nope_better.gif" width="250" title="&lsquo;giants&rsquo; &lsquo;giants&rsquo;" ></p>

<p>When <del>playing Dark Souls</del>programming Haskell, sometimes the best move
is to run away. I search again. <code>haskell https request</code> returns
&ldquo;http-conduit&rdquo; as the best choice. After adding http-conduit to my cabal, I come
up with this beast without any surprises:</p>

<pre><code class="haskell">query :: IO String
query = do
    initReq &lt;- parseUrl "https://api.github.com/search/repositories"
    let r = initReq
                   { method = "GET"
                    , requestHeaders = [(hUserAgent, "steveshogren")
                                      , (hAuthorization, "token PUT_TOKEN_HERE")]}
    let request = setQueryString [("q", Just "tetris+language:assembly")
                                 ,("order", Just "desc")
                                 ,("sort", Just "stars")] r
    manager &lt;- newManager tlsManagerSettings
    res &lt;- httpLbs request manager
    return . show . responseBody $ res

someFunc :: IO ()
someFunc = do
   query &gt;&gt;= putStrLn
</code></pre>

<p>Huzzah! Results! I&rsquo;m getting back a monster string of json data.</p>

<blockquote><p>&ldquo;\&rdquo;{\\&ldquo;total_count\\&rdquo;:66, &hellip;.}\"</p></blockquote>

<p><img class="center solaire" src="/images/praisethesun.gif" width="150" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<h3>Step Three - Parsing JSON</h3>

<p>Time to parse this mega JSON string. Aeson seems to be the biggest contender. To
use Aeson and get the total_count value from the return, I needed the following
additions:</p>

<pre><code class="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount
</code></pre>

<p>ResultCount allows me to use <code>decode</code> from aeson instead of <code>show</code> to
parse the &ldquo;total_count&rdquo; from the JSON response into an Int. Sure enough, it
does!</p>

<pre><code class="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Lib
    ( someFunc
    ) where

import Control.Monad
import Network
import Network.HTTP.Conduit
import Network.HTTP.Types.Header
import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount

query :: IO (Maybe Int)
query = do
    initReq &lt;- parseUrl "https://api.github.com/search/repositories"
    let r = initReq
                   { method = "GET"
                    , requestHeaders = [(hUserAgent, "steveshogren")
                                      , (hAuthorization, "token PUT_TOKEN_HERE")]}
    let request = setQueryString [("q", Just "tetris+language:assembly")
                                 ,("order", Just "desc")
                                 ,("sort", Just "stars")] r
    manager &lt;- newManager tlsManagerSettings
    res &lt;- httpLbs request manager
    return . liftM total_count . decode . responseBody $ res

someFunc :: IO ()
someFunc = query &gt;&gt;= print
</code></pre>

<p>Puts out: <code>Just 66</code>. Success! Wait. 66 isn&rsquo;t the same count I got when
running from the browser. Check again. Sure enough, browser comes up with a
totally different count.</p>

<p><img class="center solaire" src="/images/come_at_me_bro.gif" width="400" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<p>Maybe the query request isn&rsquo;t correct? Adding a <code>print request</code> on line 31
after building the request shows:</p>

<pre><code>Request {
  host                 = "api.github.com"
  port                 = 443
  secure               = True
  requestHeaders       = [("User-Agent","steveshogren"),("Authorization","token PUT_TOKEN_HERE")]
  path                 = "/search/repositories"
  queryString          = "?q=tetris%2Blanguage%3Aassembly&amp;order=desc&amp;sort=stars"
  method               = "GET"
  proxy                = Nothing
  rawBody              = False
  redirectCount        = 10
  responseTimeout      = Just (-3425)
  requestVersion       = HTTP/1.1
}
</code></pre>

<p>The queryString isn&rsquo;t right! <code>?q=tetris%2Blanguage%3Aassembly&amp;order=desc&amp;sort=stars</code> It encoded my <code>+</code>
and <code>:</code>! After an hour of reading through docs and researching URL encoding
specs, it dawns on me. <code>+</code> is an encoded whitespace.</p>

<blockquote><p>No face-palm gif could ever represent the shear magnitude of my current
emotions&hellip; You&rsquo;ll have to use your imagination</p></blockquote>

<p>I change my query to <code>("q", Just "tetris language:assembly")</code> and the right
count comes back! <code>Just 354</code></p>

<p>I finally have something that correctly fetches a count of repositories from
GitHub and parses it into an Int. After over four hours of <del>Dark
Souls</del>Haskell punishment, we deserve to enjoy a bonfire!</p>

<p><img class="center solaire" src="/images/solaire_sitting.gif" width="400" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<h2>Edit: Bonus Round!</h2>

<p>Thanks to
<a href="http://bitemyapp.com/posts/2016-02-06-haskell-is-not-trivial-not-unfair.html">Chris Allen</a>
and
<a href="https://www.reddit.com/r/programming/comments/44hdl6/haskell_is_the_dark_souls_of_programming/czqaxfu">/u/JeanParker</a>
for pointing me towards <a href="http://www.serpentine.com/wreq/">wreq</a>, which weirdly
didn&rsquo;t come up when I looked around for libs yesterday. Yep, it was 6th on the
Google when searching for <code>haskell https get</code>. <code>Network.HTTP</code> is the
top three results, and that doesn&rsquo;t even <em>do</em> https.</p>

<p>¯\<em>(ツ)</em>/¯</p>

<p>Armed with their helpful suggestions, I knocked this out this morning.</p>

<pre><code class="haskell">import Network.Wreq
import Control.Lens
import Data.Aeson
import Data.Aeson.Lens
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as BS

opts :: String -&gt; String -&gt; Options
opts lang token = defaults &amp; param "q" .~ [T.pack $ "tetris language:" ++ lang]
                        &amp; param "order" .~ ["desc"]
                        &amp; param "sort" .~ ["stars"]
                        &amp; header "Authorization" .~ [BS.pack $ "token " ++ token]

query lang = do
    token &lt;- readFile "token"
    r &lt;- getWith (opts lang token) "https://api.github.com/search/repositories"
    return $ r ^? responseBody . key "total_count" . _Number
</code></pre>

<p>MUCH better. This includes reading my token from file called &ldquo;token&rdquo; so I don&rsquo;t
accidentally commit it. Also includes building up the different query options
based on inputs, which was the next step. Thanks y'all.</p>

<p><img class="center solaire" src="/images/solaire_idle.gif" width="200" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<blockquote><p>Pixel gifs sourced from
<a href="http://zedotagger.deviantart.com/gallery/54317550/Dark-Souls">zedotagger</a> on
deviantart, thanks zedotagger!</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Safety Score Mark 2]]></title>
    <link href="http://deliberate-software.com/safety-rank-part-2/"/>
    <updated>2015-07-24T10:13:00-04:00</updated>
    <id>http://deliberate-software.com/safety-rank-part-2</id>
    <content type="html"><![CDATA[<p>I want to make a model that predicts bugs.</p>

<p>I previously wrote a table for scoring language safety:
<a href="http://deliberate-software.com/programming-language-safety-algorithm/">Programming Language Safety Score</a>,
but it was extremely time consuming to score new languages or make modifications.</p>

<h2>Simplify, Simplify</h2>

<p>After being told I was <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>
the data, I&rsquo;ve attempted to clean up by simply checking if each category is
enforced, possible, or impossible. I score each as either 1 (language enforced),
0 (possible, but you have to remember to do it), or -1 (impossible). When the
magnitudes of the new model are compared with the previous model, they come out
very similar. The shape of the curve pretty much stays the same, which I was
told indicates that the character count weighting was a variable that didn&rsquo;t
matter.</p>

<p><img class="center" src="/images/rplot.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code I used to generate the plot and normalize the scores can be found here:
<a href="https://github.com/steveshogren/datasciencecoursera/blob/817dec79e36b6e9a6c5a8fd5700aff7cc394b9d4/scoreplot.R">scorePlot.R</a></p>

<h2>Safety Definitions</h2>

<p>A definition of the safety checks is as follows:</p>

<p><div ng-app="TableApp2">
<div ng-controller="TableCtrl">
<table class="langtable">
<tr><th>Check</th> <th>Description</th></tr>
<tr ng-repeat="check in langChecks">
<td> {{ check.name }} </td>
<td>  {{ check.desc }}  </td>
</tr>
</table></p>

<p>The new scores are shown here, with a lot more languages added in:</p>

<p><p class="lead">
<div style="overflow-x:scroll">
<table class="langtable">
<tr>
<th>Safety Check</th>
<th></th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[0]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[1]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[2]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[3]"></select>
</th>
</tr>
<tr ng-repeat="check in langChecks" score-row name="check.name" row-key="check.key"></tr>
<tr class="totals"><td>Totals</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ lang }} 
</td>
</tr>
<tr class="totals"><td>Magnitude</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ percentageTotals(lang) }}% 
</td>
</tr>
</table>
</div></p>

<p>Current Languages:
<span ng-repeat="lang in allLanguages">
 {{ getName(lang) }}: {{ allLangTotals[$index] }}, 
</select></p>

<h2>So, What&rsquo;s the Point?</h2>

<p>To see how this model corresponds with data in the real world, I used the GitHub
API to query for the number of bugs created in repositories with more than 15
forks created in a span from 2011 to 2015. Commits were counted by summing the
commit counts of all contributors.</p>

<p>I decided to rely on the count of commits as a standard for a unit of work. My
assumption was that across fifty different projects, the commit sizes would
average out. Once the unit of work was decided on, I wanted to find the ratio of
bugs per commit for each language.</p>

<p>I collected the ratio of bugs logged per commit for each repository, and after
grouping by primary language, removed the top and bottom 25% using the
bug/commit ratio, which is a common practice in statistics to help find a more
accurate average. I summed the bugs and commits of those remaining repositories
grouped by language, finding a total average bug/commit ratio for each language
grouping. Here is that data, sorted by safety score.</p>

<p><table class="langtable">
<tr><th>Language</th>
<th>Bugs</th>
<th>Commits</th>
<th>Repositories</th>
<th>Bug/Commits</th>
<tr ng-repeat="lang in languageRatios">
<td> {{ lang.name }} </td>
<td> {{ lang.bugs }} </td>
<td> {{ lang.commits }} </td>
<td> {{ lang.repos }} </td>
<td> {{ getBugsRatio(lang) }} </td>
</tr>
</table></p>

<p>Here are the languages sorted by safety score with bug/commit ratios:</p>

<p><img class="center" src="/images/errorChart.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" >
<img class="center" src="/images/bugsAverage.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>I took the magnitude of the safety scores and the bug/commit ratios. After
inverting the safety scores, I overlaid them both onto a single graph.</p>

<p><img class="center" src="/images/bothMags.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Immediately it is obvious that Ruby, Python, PHP, and Clojure all seem to strongly
buck the trend, but otherwise the languages follow a pretty consistent slope
down in bugs. Taking the correlation gives a
<a href="https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient">correlation coefficient</a>
of .55</p>

<h2>What About Unit Tests?</h2>

<p>Thinking that Ruby, Clojure, PHP, and Python might not correlate well due to some
other factor, I collected data on how many tests each repository had. I counted
the number of files containing &ldquo;test&rdquo; or &ldquo;spec&rdquo;, which gave the following,
sorted by tests per commit:</p>

<p><table class="langtable">
<tr><th>Language</th>
<th>Tests</th>
<th>Commits</th>
<th>Repositories</th>
<th>Tests/Commits</th></tr>
<tr ng-repeat="lang in sorter(languageRatios)">
<td> {{ lang.name }} </td>
<td> {{ lang.test }} </td>
<td> {{ lang.commits }} </td>
<td> {{ lang.repos }} </td>
<td> {{ getTestsRatio(lang) }} </td>
</tr>
</table></p>

<p>PHP, Python, and Ruby all have a higher then average number of tests, but
Clojure does not. Additionally, Go, Scala, and Java all also have a higher than
average number of tests, yet they score relatively average in bugs/commit.</p>

<h2>Conclusion</h2>

<p>In conclusion, the current safety model I have proposed seems to account for a
moderate reduction in bugs per commit across the sampled languages, but is not
the only factor. It currently is unable to account for a significantly lower
than expected bug count in Ruby and Clojure.</p>

<h2>Special Thanks</h2>

<p>Special thanks to (in alphabetical order):
<a href="https://twitter.com/traffichazard/">Patrick Boe</a> (Haskell, Sniff Test),
<a href="http://asymmetrical-view.com/">Kyle Burton</a> (General Advice),
Nils Creque (Listening Board),
Max Haley (Python, Ruby, Teaching me how to math),
<a href="https://github.com/danielmiladinov">Daniel Miladinov</a> (Java, Scala, Morale Support),
Keith O'Brien (Ruby and JS),
<a href="https://github.com/arlaneenalra">Chris Salch</a> (CoffeeScript and JS),
and <a href="https://github.com/timvisher">Tim Visher</a> (Clojure).</p>

<p>Additional thanks to the posters on
<a href="https://www.reddit.com/r/rust/comments/3egx49/language_safety_score_mark_2/">/r/rust</a>,
including <a href="https://www.reddit.com/user/notriddle">/u/notriddle</a>,
<a href="https://www.reddit.com/user/killercup">/u/killercup</a>, and
<a href="https://www.reddit.com/user/diegobernardes">/u/diegobernardes</a> who put together the Rust score.</p>

<h2>Complaints Department</h2>

<p>Did I mess up something about a language here, or am I missing a safety check? I&rsquo;ll happily take pull
requests for new languages:
<a href="https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders2.js">blog source</a>. Just
pick an existing language, edit the name and values, and &ldquo;copy to clipboard&rdquo; to
build your own language data structure. Send it to me in a PR and I&rsquo;ll include
it along with a thanks on the page.</p>

<p><div ng-show="showRealName">
<h2>Select Language:
<select ng-options="lang.name for lang in allLanguages" ng-model="selectedLang"></select>
<button ng-click="copyToClipboard(selectedLang)">Copy Changes to Clipboard</button>
</h2>
<h2><input ng-model="selectedLang.name"></input></h2>
<table class="langtable">
<tr><th>Check</th><th>Option</th></tr>
<tr ng-repeat="check in langChecks">
<td style="background-color: {{scoreClass(score(selectedLang[check.key]))}} ">
 {{ check.name }}:  {{score(selectedLang[check.key]) }} 
</td>
<td>
<select ng-options="enforcedNice(e) for e in enforcedTypes" ng-model="selectedLang[check.key].enforced"></select>
</td>
</tr>
</table></p>
]]></content>
  </entry>
  
</feed>
