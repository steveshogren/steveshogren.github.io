<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Deliberate Software]]></title>
  <link href="http://steveshogren.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://steveshogren.github.io/"/>
  <updated>2014-05-03T10:26:06-04:00</updated>
  <id>http://steveshogren.github.io/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pattern Matching - Make the Compiler Work for You]]></title>
    <link href="http://steveshogren.github.io/function-pattern-matching/"/>
    <updated>2014-04-28T22:05:00-04:00</updated>
    <id>http://steveshogren.github.io/function-pattern-matching</id>
    <content type="html"><![CDATA[<p>Pattern matching is a simple tool that will make your code safer and
easier to read.</p>

<p>Consider the following code that converts an Int to a string.</p>

<p>``` csharp
public enum Language {</p>

<pre><code>Spanish,
English
</code></pre>

<p>}
public static string convert(int number, Language lang) {</p>

<pre><code>string ret = "";
if (lang == Language.English) {
    switch(number) {
        case 0: ret = "zero"; break;
        case 1: ret = "one"; break;
        default: ret = "..."; break;
    }
} else if (lang == Language.Spanish) {
    switch(number) {
        case 0: ret = "zero"; break;
        case 1: ret = "uno"; break;
        default: ret = "~~~"; break;
    }
}
return ret;
</code></pre>

<p>}
```</p>

<p>What happens when we make this simple change?</p>

<p>``` csharp
public enum Language {</p>

<pre><code>Spanish,
English,
German
</code></pre>

<p>}
```</p>

<p>Does the code still compile? Sure does! Does the compiler/IDE offer us
any indication that something is missing? Nope! Our code has a
potential bug that is only exposed at run-time, and nothing will tell
us that. We made it fail gracefully by ensuring our code always
returns at least an empty string, but we have created a bug that can
only really be caught by something external: either automated tests or
manual checking.</p>

<p>The OO purists and &ldquo;Anti-If&rdquo; guys are probably leaping out of their
seats. &ldquo;Use classes and an interface!&rdquo; they yell. Ok, sure. I assert
that it just makes things even worse.</p>

<p>``` csharp</p>

<pre><code>public interface ILanguage {
    String convert(int num);
}
public class Spanish : ILanguage {
    public String convert (int num) {
        var ret = "";
        switch (num) {
            case 0: ret = "zero"; break;
            case 1: ret = "uno"; break;
            default: ret = "~~~"; break;
        }
        return ret;
    }
}
public class English : ILanguage {
    public String convert (int num) {
        var ret = "";
        switch (num) {
            case 0: ret = "zero"; break;
            case 1: ret = "one"; break;
            default: ret = "..."; break;
        }
        return ret;
    }
}
// somewhere else...
public static string convert(int x, Language lang) {
    return getLanguage(lang).convert(x);
}
public static ILanguage getLanguage(Language lang) {
    switch (lang) {
        case Language.English: return new English() ; break;
        case Language.Spanish: return new Spanish() ; break;
        default: throw new Exception();
    }
}
</code></pre>

<p>```</p>

<p>We have turned 21 lines in one file into 36 in three files (not
counting namespaces and imports). Does this new structure give us any
additional safety when we add a new concrete implementation? How about
when we add a new enum value? This code is even more likely to cause
bugs than the first, because now we have an implicit coupling between
the enum and the concrete class. We could get rid of the enum, and
&ldquo;pass in concrete class&rdquo; but <em>something</em> still has to say which
concrete class to instantiate.</p>

<p>Imagine if the compiler could warn us when either the enum or the
class changed. Imagine if instead of having to hunt down the possible
uses, we could just compile and fix the errors.</p>

<p>Good news, we can!</p>

<p>Check out this F# code. If you have never seen F# before, I know, it
looks completely crazy! It <em>still</em> looks a little weird to me, but
just try to read it. I think you will surprise yourself. This is a
function called <code>convert</code>, and if you keep in mind that the types
always come AFTER the value, the code makes a lot more sense. A
parameter in C# would be <code>int number</code>; in F# it is written
<code>number:Int</code>. Don&rsquo;t ask me why. The <code>match number with</code> is just how
you do the equivalent to a <code>switch/case</code> in C#, but you will see in a
second it is a lot more powerful!</p>

<p>``` fsharp
let convert(number:Int, lang:Language) :string =</p>

<pre><code>match lang with
    | Language.English -&gt; 
        match number with
           | 1 -&gt; "one" 
           | 2 -&gt; "two" 
           | _ -&gt; "..."
</code></pre>

<p>```</p>

<p>We are using the same enum from the C# file, but it is missing
something, right? Where are the Spanish and German parts? I try to
compile this and what do I see?</p>

<p><code>~/Program.fs(11,11): Warning FS0025: Incomplete pattern
matches on this expression. For example, the value 'enum&lt;Language&gt;
(0)' may indicate a case not covered by the pattern(s). (FS0025)</code></p>

<p>Spittake mushroom soup, the compiler just caught a potential bug for
us! A C# run-time bug no less! Not only is this very powerful, but it
is so simple. I can code the way I normally do, only now I get
additional safety for free! And no unit or integration test would ever
catch this class of errors.</p>

<p>Heck, if you really want to keep your classes and interfaces in C#,
you can have some &ldquo;glue code&rdquo; in F#, and still get all the benefit!</p>

<p>``` fsharp
let convert(number, lang) =</p>

<pre><code>match lang with
    | Language.English -&gt; English().convert(number)
</code></pre>

<p>```</p>

<p>This still calls the C# class above, and now the compiler gives us a
warning when we add a new enum value!</p>

<p>In this way, pattern matching is able to clearly remove edge cases. We
converted an unsafe <code>if</code> and <code>switch</code> statement into a type safe
<code>match</code>.</p>

<p>BONUS ROUND!</p>

<p>What we have already seen of pattern matching makes it a better
<code>switch/case</code> but what about the <code>if</code> statement? Thankfully the
<code>match/with</code> statement allows for patterns matched to have a <code>when</code>
clause which only matches when the condition is true:</p>

<p>``` fsharp
let convert(number, lang) =</p>

<pre><code>match lang with
    | Language.English -&gt; 
        match number with 
            | x when x &gt; 5 -&gt; "Large!"
            | 0 -&gt; "zero"
    | Language.Spanish -&gt; 
        match number with 
            | x when x &gt; 5 -&gt; "Grande!"
            | 0 -&gt; "zero"
</code></pre>

<p>```</p>

<p>Running the compiler again give us:</p>

<p><code>/home/jack/programming/monads-fsharp/monads-fsharp/Program.fs(19,19):
Warning FS0025: Incomplete pattern matches on this expression. For
example, the value '1' may indicate a case not covered by the
pattern(s). However, a pattern rule with a 'when' clause might
successfully match this value. (FS0025) (monads-fsharp)</code></p>

<p>That&rsquo;s right, it checks numbers too.</p>

<p>Lastly, it is possible to match on a combination of values, all at
once. We can convert our more complex structure to something simpler
using this trick, and the compiler is still intelligent enough to
check for missing cases.</p>

<p>``` fsharp
let convert(number, lang) =</p>

<pre><code>match lang, number with
    | Language.English, 0 -&gt; "zero" 
    | Language.English, 1 -&gt; "one"
    | Language.English, x when x &gt; 1 -&gt; "Larger than one!"
    | Language.English, _ -&gt; "dunno"
    | Language.Spanish, 0 -&gt; "zero" 
    | Language.Spanish, x when x &gt; 5 -&gt; "Grande!"
</code></pre>

<p>```</p>

<p>Here we introduce the <code>_</code> which is equivalent to a <code>default</code> in a C#
<code>switch/case</code> statement. The pattern <code>Language.English, _ -&gt;</code> sets a
default for any number in <code>Language.English</code> not already matched. The
bug in the code here is the missing <code>Language.Spanish</code> with numbers
1-5. What does the compiler say?</p>

<p><code>Program.fs(11,11): Warning FS0025: Incomplete pattern matches on this
expression. For example, the value '(_,1)' may indicate a case not
covered by the pattern(s). However, a pattern rule with a 'when'
clause might successfully match this value. (FS0025) (monads-fsharp)</code></p>

<p>Lastly, let&rsquo;s show the final result of converting our original
function to F#. If your entire function is just a single pattern
match, you can remove the <code>match/with</code> line and use the <code>function</code>
keyword, and simply match against the parameters (which I reversed for
clarity, but do not need to be written).</p>

<p>```fsharp
let convert = function</p>

<pre><code>| Language.English, 0 -&gt; "zero" 
| Language.English, 1 -&gt; "one"
| Language.English, _ -&gt; "..."
| Language.Spanish, 0 -&gt; "zero" 
| Language.Spanish, 1 -&gt; "uno" 
| Language.Spanish, _ -&gt; "~~~"
</code></pre>

<p>```</p>

<p>Our original 17 line convert function, converted into a <em>safer</em> 7
lines! I never had to specify what the types of lang, number and the
return type are, because the compiler is able to figure that out from
the code I wrote.</p>

<p>If you are not convinced at this point that pattern matching is a big
step forward in the safety and ease of development, I am not sure what
else would convince you. More safety means less time spent tracking
down bugs and more time adding on features!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn to Database]]></title>
    <link href="http://steveshogren.github.io/Learn-To-Database/"/>
    <updated>2014-04-16T00:00:00-04:00</updated>
    <id>http://steveshogren.github.io/Learn-To-Database</id>
    <content type="html"><![CDATA[<p>
  "... and it has to return 45,000 records a minute, or we are all
  screwed."
</p>


<p> <p> Monday morning, we inherited a legacy codebase. Tuesday, the
  word came down on stone tablets. Forty-five thousand records a
  minute, and no amount of political maneuvering or incremental gains
  were going to do. Too many broken promises. The last team mass quit
  over three months, leaving us the two most junior
  developers. Someone high up promised big, and the buck stopped with
  us.
</p> <p> &ldquo;Does anyone even know the throughput now?&rdquo;
</p> <p> We still don&rsquo;t even have the dumb thing running on our
  machines. Two weeks later we have it running and enough data to test
  it. 2500 records a minute. When scaled to 45000 records it is still
  going 30 minutes later, so it doesn&rsquo;t even scale linearly. We are
  screwed.
</p> <p> Most of us are front-end developers who stepped forward when
  everyone else stepped back. Databases are a distant memory,
  something we maybe did a few jobs back. You &ldquo;join&rdquo; tables, right?
  What we know of this process is it selects from 2-3 dozen databases
  using an ORM while running through an engine that does some
  supposedly massive calculations on the data, returning a message with
  several hundred fields. It can&rsquo;t be that hard to speed up.
</p> <p> &ldquo;We need a new architecture, with read-optimized databases
  and queue-based messaging.&rdquo;
</p> <p> None of us have ever built such a system, but we have read
  about it, and like the faithful we nod solemnly in agreement. Why
  not? If the database is read-optimized, surely it will perform like
  we need. But a few desist.
</p> <p> Like paratroopers dropped into unknown territory without a
  map, we start to canvas the code, looking for landmarks. We split
  into two teams, one to try to speed up the current system, the other
  to start on the new architecture. Two teams trying two different
  approaches doubles our chances, right? Whiteboards around our desks
  fill with maps, glossaries, and diagrams. My team starts to dissect
  this mostly home-made ORM.
</p> <p> &ldquo;Why is this selecting from the same table twice?&rdquo;
</p> <p> The ORM generated query selects a list of id&rsquo;s from table A,
  then puts those id&rsquo;s into a list as a filter for the same table:
</p> <p>
  SELECT * FROM A WHERE ID IN (SELECT ID FROM A WHERE &hellip;)
</p> <p> We scratch our heads a bit, but hey, that can&rsquo;t hurt
  anything, surely the database figures that sort of stuff out? Isn&rsquo;t
  that what&hellip; indexes do? Our most database-savvy developer can&rsquo;t
  stop coming back to that query. He says it doesn&rsquo;t smell
  right. Finally, he takes out the &ldquo;WHERE IN&rdquo; filter, shims in the
  query, and runs the process.
</p> <p>
  &ldquo;Guys, the whole thing, all 45k came back in 40 seconds.&rdquo;
</p> <p> We scoff at him, good joke! Our profiling showed time chewed
  up fairly evenly at every level throughout the entire
  process, not just the initial query. So the process came back,
  just empty, right? And who knows what Ancient Ones you disturbed by
  messing around with what the ORM generates, it will probably never
  work again. We run it again, 40 seconds, correct count of
  records. Odd, freak coincidence. We run it with the old filter still
  in place, it comes back 30+ minutes later, same exact data. Whoa,
  wait, what?
</p> <p> Turns out, this ORM uses SELECT-WHERE-IN for every entity
  join. That first SELECT FROM A WHERE ID IN (SELECT ID FROM A WHERE
  &hellip;) was used as the base criteria for every single lazy look-up of
  every entity on A, which were legion. What looked like slowness
  across the entire process was really ORM lazy loading at every
  level, with that first SELECT-WHERE-IN as the final filter in a line
  of nested SELECTS, some four levels deep. That initial bad query
  gets run countless times, and when it is slow, the whole system is
  slow.
</p> <p> This is the story of how I learned an important lesson: if
  you are going to database, LEARN TO DATABASE.
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Challenge - Code Every Day]]></title>
    <link href="http://steveshogren.github.io/streaks/"/>
    <updated>2014-01-28T00:00:00-05:00</updated>
    <id>http://steveshogren.github.io/streaks</id>
    <content type="html"><![CDATA[<p>
  You know what will make you a phenomenally better developer?
  Deliberate practice. How do you get such practice? By doing it every
  single day. Random bursts of effort over the odd weekend will gain
  you practically nothing comparatively, even if the time investment
  is the same. Your mind needs repetition and consistent effort to
  improve. So what do you want to get better at?  Pick your highest
  value subject: vim, regex, functional programming, meta-programming,
  OO, TDD, async co-routines, threading, graphics, web, etc, etc, and
  practice it every single day. Easy as that.
</p>


<p>
  When GitHub first came out with the "streak" feature on the front
  page, I realized it was time to stop my binge coding on the
  occasional weekend and start a system. Inspired by other recent
  system-based successes (working out every day), I decided to code
  every day for a year.
</p>


<p>
  I quickly realized that anything requiring detailed plans and
  designs is harder to do. Working though a book, on the other hand,
  is easy to start and stop. I started working through a book I had
  tried to read before: Let Over Lambda.
</p>


<p>
  Let Over Lambda is intense, filled with deeply complex concepts
  written in Common Lisp, a language with which I was only passingly
  familiar. But I managed to get through it without hardly any
  difficulty. How did I do that?
</p>


<p>
  I got a cheap netbook, and started to code on the train ride home.
  Interestingly, without any internet, I was much less distracted, and
  could just sit down and be in the zone within the minute (this from
  the guy whom it takes 20+ minutes to get in the zone at work). With
  only a limited span of ~25 minutes, I had no time to waste, and
  without people to talk to my brain just falls into it. I can only
  pinpoint a few times I could not get into the zone, and those were
  extreme circumstances of exhaustion or illness.
</p>


<p>
  In ten months, I have:
  <ul>
    <li>
      worked through Let Over Lambda once and read it twice
    </li>
    <li>
      worked twice through the PLAI programming languages book
      (once in Scheme and once in F#)
    </li>
    <li>
      read Clojure Programming, F# 3.0 Programming, and am currently
      in Real World Haskell
    </li>
    <li>
      completed the exercises up to chapter three of SICP
    </li>
    <li>
      authored a small Clojure library for run time type checking
      (don't use mine, use Prismatic's)
    </li>
    <li>
      prepared and given a two hour talk about macros at a local meet-up
    </li>
  </ul>
  Pretty incredible for only ~25 minutes a day! That is more
  programming books than I had read in the previous 2 years. I have
  improved mightily in such a short time, and it does not feel
  stressful in the least. Now, when I get home, if I feel like
  watching movies, cooking, or playing board games/Dark Souls all
  night, no problem! I can relax knowing I have accomplished my goals
  for the day. All in all, the last ten months have been incredible:
  some of the most rewarding, relaxing, and fulfilling months of my
  life.
</p>


<p>
  Before you scoff and point out that not everyone can take the train
  to work, consider this: get a portable computer, load up your
  environment, tools, and some pdfs. The next morning, leave for work
  ~25 minutes early. You will probably get in way sooner due to the
  decreased traffic (now you have earned back that time). Sit quietly
  in your car, and without the distractions of internet or other
  people, knock out a little programming. Maybe start with SICP (the
  best programming book I have ever read). See how much you can read
  and do before work starts. Do that for a month, every day. I
  guarantee you will learn something amazing.
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The 5:01 Developer]]></title>
    <link href="http://steveshogren.github.io/501-developer/"/>
    <updated>2013-12-14T00:00:00-05:00</updated>
    <id>http://steveshogren.github.io/501-developer</id>
    <content type="html"><![CDATA[<p>
  Can we agree for this post that money, energy, time, and effort are
  all forms of power? Like literally, if I wanted to build a building,
  I am going to need tools, skills, materials, labor. I can use the
  most liquid form of power I have (cash) to acquire all these things,
  or I can use a much less liquid form of power (my time) to harvest,
  extract, refine, learn, and build my building myself. Usually,
  economies of scale mean it is dramatically more efficient for me to
  specialize in one way of converting time into liquid power. Then,
  when I need something, I simply pass that money on to someone else
  who is also a specialist.
</p>


<p>
  Now you know why I don't quarry my own stone to build an
  amphitheater in my back yard.
</p>


<p>
  When you work a job, you are converting one form of power you have:
  time (and usually skills), into another much more liquid form of
  power: money. One can extend the model to include calories and
  shelter (the power to sleep safely) along with time and skills.
  Great, this is just basic economics, right? You need power (money)
  to buy power (food and shelter) to buy power (time) to convert back
  into more power (money). Since you are "harvesting" something finite
  and therefore scarce (time out of your short life), if you are
  disciplined and lucky, you can consistently end up with a net
  positive.
</p>


<p>
  On to the point! I read a post today mentioning
  the <a href="http://www.hanselman.com/blog/DarkMatterDevelopersTheUnseen99.aspx">"5:01 developer"</a>. It made me mad.
</p>


<p>
  Ideas like this are so subtle they just seep into your psyche. I
  don't think anyone would say under normal conditions, "I should
  really work for free today". But, effectively, that is what this
  whole phrase is about. The phrase lets people who cram eight hours
  of work into ten hours "get back" at those that get the same work
  done in six to eight. To clarify, this title is not about "saving
  the company" or "giving back to society"; those are unusual
  conditions. No, it is a chastisement of developers who do not "give
  back to the company". Sort of a tax, for the privilege of getting
  paid to work there, you should, according to this ideal, just give
  back some of that power they gave you. Thinking about this with the
  power model, you should accept money to work there in exchange for
  your time, but, when the time comes, you should deliberately
  short-change yourself by giving them extra time. Like some sort of
  weird tip.
</p>


<p>
  Hopefully this sounds as ridiculous as it really is.
</p>


<p>
  Now, in that post, the author sort of backpedals a little bit,
  saying that <i>what he really meant</i> was a developer who stops
  thinking about development as soon as work is over: someone not
  passionate. The issue I have is the whole wording of that phrase
  assumes a passion for their <i>job</i>, not a passion for
  their <i>craft</i>.
</p>


<p>
  I do not think it makes sense to demand every person
  be <i>passionate</i> about the job they are doing. There have been
  many times I have (even at a job I normally loved) done long,
  boring, and fruitless work. I did not do that work out of my passion
  for the "Mission: Save the World of Enterprise Banking", but because
  I am a professional: I do what needs to be done to the best of my
  abilities.
</p>


<p>
  I think professionalism is very important. In others I work with, I
  want to see the attitude that causes someone to stay abreast in
  their field. I want to be around those who keep their own saws
  sharp, who come in and work hard, and who push themselves and those
  around them to be best they can.
</p>


<p>
  Back to overtime: in my experience, very few offices care enough
  about their developers to let them sharpen their saws at work, so
  why would you waste your precious free time there? Will they pay you
  more for it? Doubtful. Will they be less likely to fire you when
  times get tough? <i>Maybe</i>. Sounds to me like a lot of
  speculation. A lot of investment for a marginal or non-existent
  return. If you want more money: either ask for a raise, go take a
  raise at a new job, or work a second job on the side. Those have a
  direct impact on your income. Putting in extra hours hoping someone
  will notice and reward you for it makes about as much sense as
  assuming you will get a raise for wearing the boss's favorite color
  every day.
</p>


<p>
  Consider the person who stays one extra hour a day as an
  "investment". The typical end of the year raise scale I have seen in
  the US in companies larger than 30 people is a 0-5% increase a
  year. Uncommonly does someone get more than that, and should not be
  considered a usual practice. The typical best you can expect is
  5%, maybe a bonus (in four diverse jobs, none gave bonuses, so I
  haven't considered them personally). Back to the extra hour a day. Not
  completely out there, not putting in a vast amount extra, right?
  Well, one extra hour is 12.5% percent more hours a day. But the most
  you can expect, on average, is 5%, if you are lucky! To put it in
  perspective, I have seen guys put in 12 hour days and get fired
  because the boss didn't get along with them.
</p>


<p>
  At a <i>few</i> points in my career, I worked longer hours. Once it
  was because I truly enjoyed the work and it was fun. Another time it
  was because I felt like the extra time was going to directly pay off
  as an investment (it didn't). A few times I have stuck around to
  "wrap this off" or "help out with something deeply unusual that has
  to be done outside normal work hours". I recently recommended to my
  little brother he work longer hours, as he was hired without many
  needed skills and on shaky footing with the boss. He worked out a
  deal where he spent two extra hours a day for a couple months
  reading and practicing to get "caught up". His boss got to see his
  hustle when he was the first one in and last one out every day; he
  got to study away from the distractions of everyday life. <b>In all
  circumstances, make overtime the exception, never the rule.</b>
</p>


<p>
  One last point. Before you think me a selfish jerk about my free
  time, know that I make it a daily habit to spend 30-60 minutes
  outside work advancing my development skills. I practice interactive
  rebases, work through awesome books, do online courses, advance side
  projects, contribute to open source, give local meetup talks, and
  learn new languages. These are the basics of what I feel is
  necessary to sustain and advance myself as a professional. If I
  simply worked a 45-50 hour work week instead, I personally would not
  have the motivation to <i>afterwards</i> stay so abreast of
  important changes in the development world. I would become much less
  effective over time, never getting any better. When the need for new
  paradigms or technologies arose, I would be so stuck in a rut that
  fear and ignorance would drive all my decisions.
</p>


<p>
  Treat overtime like an investment, and make it wisely. You are
  literally mining your life for time, so make sure you are
  comfortable with your investment strategies.
</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intro To Macros]]></title>
    <link href="http://steveshogren.github.io/intro-to-macros/"/>
    <updated>2013-08-19T00:00:00-04:00</updated>
    <id>http://steveshogren.github.io/intro-to-macros</id>
    <content type="html"><![CDATA[<p>
Macros are the most powerful way to manipulate the syntax of your language. Macros make it possible to completely modify your language to match your domain. To explain them, think for a minute about functions using the simple “substitution model” used to teach functions to beginner programmers. The substitution model has the reader replace a function call with the body of the called function.
</p>


<p>``` ruby
def doCalc ()
   return 1 + 2
end
def doAwesome (x)
   return doCalc() + x
end</p>

<h1>before substitution&hellip;</h1>

<p>def test ()
   return doAwesome(3)
end</p>

<h1>when substituted&hellip;</h1>

<p>def test ()
   return (1 + 2) + 3
end
```</p>

<p>
Ignoring scoping, the function/call system allows for immense power in programing languages. The function lets you "expand" a simple call into a much larger block of code. The expanded code can be vastly large. In our example above, the (doCalc) function is small, but it reality it could be doing hundreds of lines of code, which also would have to be substituted in place. The difference is real functions do not work this way. Real functions have their values evaluated before getting passed in as parameters.
</p>


<p dir="ltr">Macros are similar to the substitution model, with one expressed difference: by default, macros operate on the text of the code itself, not the values. Think of how expansion works in the simple if statement.</p>


<p><code>ruby
if workday(today()) do
  x = 1 + 1
else
  x = doOtherHugeCalc()
end
</code></p>

<p dir="ltr">Does the huge calc function execute each time? Not at all, you are guaranteed that only one will happen at any given run through that block of code.</p>


<p dir="ltr">Let’s say you wanted to make a generic function that would abstract away that call, and let you return the values, maybe something like this:</p>


<p>``` ruby
def ifworkday(first, second)
  if workday(today()) do</p>

<pre><code>return first
</code></pre>

<p>  else</p>

<pre><code>return second
</code></pre>

<p>  end
end
x = ifworkday(1 + 1, doOtherHugeCalc())</p>

<h1>when the values are “shown”</h1>

<p>def ifworkday(2, 3)
  if workday(today()) do</p>

<pre><code>return 2
</code></pre>

<p>  else</p>

<pre><code>return 3
</code></pre>

<p>  end
end
x = ifworkday(2, 3) # CALLED BOTH FUNCTIONS
```</p>

<p>
But wait, now BOTH functions get called, you are doing exactly twice as many huge calcs as needed. Now, those familiar with javascript probably are already itching with the solution, "JUST WRAP THEM IN ANONYMOUS FUNCTIONS!!!". I hear you, sure that works in this super simple example, but macros let you do this without that extra wordiness.  Macros defer evaluating parameters. Think of a macro as a function, but the biggest difference is parameters DON'T get called till you choose to call them.
</p>


<p>```</p>

<h1>if it is a macro&hellip;</h1>

<p>defmacro ifworkday(first, second)
  if workday(today()) do</p>

<pre><code>return first
</code></pre>

<p>  else</p>

<pre><code>return second
</code></pre>

<p>  end
end
ifworkday(1+1, doOtherHugeCalc())</p>

<h1>when the values are “shown”</h1>

<p>defmacro ifworkday(&ldquo;1+1&rdquo;, &ldquo;doOtherHugeCalc()&rdquo;)
  if workday(today()) do</p>

<pre><code>return eval("1+1")
</code></pre>

<p>  else</p>

<pre><code>return eval("doOtherHugeCalc()")
</code></pre>

<p>  end
end
```</p>

<p dir="ltr">Now, in this simple ruby example, I had to use strings and eval to approximate what happens with macros in other languages. Since this is unwieldy, let’s switch to clojure, where it is more natural.</p>


<p>I said that macros defer evaluation, they do that, but they also do much more. Lets look at a clojure list.</p>

<p><code>clojure
‘(a b c d)
;;=&gt; (a b c d)
</code></p>

<p dir="ltr">This is a list of four symbols. Symbols are basically like an enum or a keyword that only equals itself. So it is possible to say:</p>


<p><code>clojure
(= ‘a ‘a)
;;=&gt; true
</code></p>

<p dir="ltr">but that’s pretty much it. If I tried to evaluate a symbol, it would complain that the symbol has no definition, since it is trying to treat it like a variable lookup.</p>


<p><code>clojure
;; nothing gets evaluated inside the list at all..
‘(a b c)
</code></p>

<p dir="ltr">Now you are left with a list of symbols, unevaluated. The defmacro form, for each parameter, gives you such a list of unevaluated symbols.</p>


<p><code>`` clojure
;;before compilation
(defmacro ifWorkday [bigCalc1, bigCalc2]
 </code>(if (workday (today))</p>

<pre><code>~bigCalc1
~bigCalc2))
</code></pre>

<p>;; the call
(ifWorkday (+ 1 1) (otherBigCalc))</p>

<p>;;&hellip; after compilation&hellip;
(defmacro ifWorkday [(+ 1 1), (otherBigCalc)]
  `(if (workday (today))</p>

<pre><code>(+ 1 1)
(otherBigCalc)))
</code></pre>

<p>;; after compilation the call gets <em>transformed</em> into:
(if (workday (today)) (+ 1 1) (otherBigCalc))
```</p>

<p dir="ltr">The ` is called syntax quote, it disables evaluation much like quote does (it just also namespaces everything inside for your convenience). The ~ is called an unquote, and it turns evaluation back on. In any given space, if you have a function called (id), and you called it like (`~id), it would mean the same as just calling (id), because you turned off evaluation, then turned it back on. Above, the bigCalc parameters are filled with the actual values passed in, the lists unevaluated of ‘(+ 1 1) and ‘(otherBigCalc). I like to think of the return from a macro as a “template” to replace the original call with. Take the call (ifWorkday (+ 1 1) (otherBigCalc)). When calling the macro, the last thing returned from the macro is expected to be a list of clojure code to replace the original call at compile time. So, at compile time, (ifWorkday (+ 1 1) (otherBigCalc)) is replaced with (if (workday (today)) (+ 1 1) (otherBigCalc)) which is the return from the macro.</p>


<p dir="ltr">But that is a stupid example. Making your own if statements is the most basic uses of macros. But it demonstrates the point: macros generate code. This is profound, but hard to grasp for the first time. Macros expand code before compilation time, and therefore can be used to generate lots of code automatically.</p>




<p>
For extra credit, let’s take a bigger example in the same vein as our custom ifWorkday. I am making a game, and in it, I want an easy abstraction that gives me back one of several options with a custom percent chance. Ideally, something like
</p>


<p><code>clojure
(if25 (doFirst) (doSecond))
</code></p>

<p>
where the number corresponds to the percent chance that the next item will be executed and returned. In this example, (doFirst) will only happen 25% of the time and (doSecond) 75% of the time. This demonstrates a more interesting use of macros, the ability to generate other functions (or even other macros). Here is the code:
</p>


<p><code>`` clojure
(defmacro make-percents []
 </code>(list ~@(map (fn [num]</p>

<pre><code>              (let [macro-name (symbol (str "if" num))]    
                `(defmacro ~macro-name [x# y#]               
                  `(if (&gt; ~~num (rand-int 100)) ~x# ~y#))))  
            (range 100))))
</code></pre>

<p>(make-percents)
```</p>

<p>
This macro only needs to be called once, and what it does is generates this:
</p>


<p><code>clojure
(defmacro if0 [x__2603__auto__ y__2604__auto__]
  `(if (&gt; 0 (rand-int 100)) ~x__2603__auto__ ~y__2604__auto__))
(defmacro if1 [x__2604__auto__ y__2605__auto__]
  `(if (&gt; 1 (rand-int 100)) ~x__2604__auto__ ~y__2605__auto__))
(defmacro if2 [x__2606__auto__ y__2607__auto__]
  `(if (&gt; 2 (rand-int 100)) ~x__2606__auto__ ~y__2607__auto__))
;;...
(defmacro if99 [x__2609__auto__ y__2601__auto__]
  `(if (&gt; 99 (rand-int 100)) ~x__2609__auto__ ~y__2601__auto__))
</code></p>

<p dir="ltr">I hope the profundity of this hits you like a ton of bricks. With under 10 lines of macro code (and calling it) we auto-generated 100 macros! This 10 lines of code gets expanded to 100 more lines! Sure, this is a simple, almost silly example, but imagine what you could do with this sort of power. In a more complex example, you could be auto-generating vast amounts of code this way, code that you don’t have to write every time by hand. Don't let the x__2506__auto__ parameter names scare you, I will explain that in a bit.</p>


<p>
Those generated macros should not be too hard to understand after the previous ifWorkday macro, and they can be called just like we expect. Let's deconstruct (make-percents).
</p>


<p><code>clojure
`(list ~@(map (fn [num]  
</code></p>

<p dir="ltr">The ~@ is like unquote from above, the only difference is instead of just unquoting a list to be evaluated, it extracts the values from the list and sticks them in place. I like to think of it as just removing the outer parens in the unquoted list.</p>


<p><code>clojure
(let [x ‘(1 2 (3 4))]
  `(+ 8 ~@x))
;; =&gt; (clojure.core/+ 8 1 2 (3 4))
</code></p>

<p dir="ltr">The (list) function is just how we make a list of elements.</p>


<p><code>clojure
(list ‘a ‘b ‘c)
;;=&gt; (a b c)
</code></p>

<p>
The (map) function has two arguments: the first, a function; the second, a list of elements to “map” over.
</p>


<p>``` clojure
~@(map (fn [num] (&hellip;))</p>

<pre><code>   (range 100))
</code></pre>

<p>```</p>

<p dir="ltr">As you can see here, the ~@() tells us to unquote the whole form, re-enabling the evaluation, and therefore running the map call. The map then calls the anonymous function 100 times, with the num being the numbers 0..99. Inside the anon function we have a let binding:</p>


<p><code>clojure
(let [macro-name (symbol (str "if" num))]
</code></p>

<p dir="ltr">This line is more simple, it makes a let that binds to the value macro-name a symbol that looks like ‘if1, ‘if2, .. depending on which iteration of the loop you are on.</p>


<p><code>clojure
`(defmacro ~macro-name [x# y#]                
  `(if (&gt; ~~num (rand-int 100)) ~x# ~y#))))
</code></p>

<p dir="ltr">Here is the actual returned “template” of the macro. The # at the end of the parameter name ensures that it is unique, which is really really useful when you consider that the code returned from a macro replaces the call in place. To make sure you don’t accidentally double bind the same name, clojure will give you a warning like “cannot let unqualified name” if you try to let a value without including the # at the end inside a template, another really handy feature. What gets generated by x# looks something like x__2506__auto__ which is guaranteed to be unique. The reason you need this is in case there was another value bound to x inside your code, it could cause a conflict, and in certain circumstances, really break your code, so this prevents such conflicts. You should only need these when creating parameters or let bindings inside the template. All the values "outside" the template do not need to have the # appended to their names, since they will not actually be a part of the returned template.</p>


<p dir="ltr">The only odd thing here is the double ~~num. Notice how many quote levels deep we are. It is possible to unquote to “step” back up a level in the template. By the time we get to the ~~num, the original function parameter of num was two “levels” higher, so to access it, we have to “step up” two levels. Let me highlight it in colors, to make it easier to see.</p>


<p><img src="/images/macro.jpg" title="" ></p>

<p dir="ltr">See how by unquoting ~macro-name one level in line 3, and unquoting ~~num two levels on line 4, we bring them both back “up” to the “red” level where they were defined? Similarly, by unquoting ~x# and ~y# one level on line 4, we bring them back “up” to their “blue” definition level? This is an incredibly powerful tool that allows immense expansion of code in a tiny amount of space. If you think of the returned code form as a “template”, this quoting and unquoting lets you step in and out of evaluation with ease.</p>


<p dir="ltr">In the end, when the (make-percents) macro is called, it produces 100 macros that are callable just like any other macro. To tell the whole story, I wrote this into my game, then decided I wanted a more sophisticated macro that could take any number of percentages, but this remained a good way to explain this specific pattern of looped macro generation.</p>


<p dir="ltr">Hopefully, this article caused you to see how incredibly powerful macros can be, allowing effectively infinite auto-generation of code. The field of macros is still very under-explored, as most languages do not allow them at all, they remain a largely undiscovered, and yet incredibly powerful tool.</p>


<p dir="ltr">For further reading, I highly recommend Let Over Lambda, the first 6 chapters of which are free <a href="http://letoverlambda.com/index.cl/toc">here</a>. Let Over Lambda is written with examples in Common Lisp, but the macro parts are very similar in Clojure, so is a valuable read.</p>


<p>&nbsp;</p>
]]></content>
  </entry>
  
</feed>
