<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technical Skills | Deliberate Software]]></title>
  <link href="http://steveshogren.github.io/blog/categories/technical-skills/atom.xml" rel="self"/>
  <link href="http://steveshogren.github.io/"/>
  <updated>2015-03-15T14:11:14-04:00</updated>
  <id>http://steveshogren.github.io/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Case Study: Type-safe Domain Modeling in F#]]></title>
    <link href="http://steveshogren.github.io/pattern-matching-case-study/"/>
    <updated>2015-03-14T09:42:00-04:00</updated>
    <id>http://steveshogren.github.io/pattern-matching-case-study</id>
    <content type="html"><![CDATA[<p>Domain modeling in F# is significantly easier and safer than with the
traditional .NET languages. This is because of the increased safety of
pattern matching and the expressiveness of discriminated unions. These
concepts are not in C# or VB.NET, and therefore bring a new tool to
the table.</p>

<p>To illustrate this, I found some old code I&rsquo;d written to interact with
a legacy system. The system uses many single enums on a record to keep
track of statuses. When one changes, it can cause others to change as
well.</p>

<p>Here is a typical function that combines two enums to recalculate a
third.</p>

<p>``` csharp</p>

<pre><code>    public static PositionType GetPositionType (MovementType movementType, ApplyToParty applyToParty)
    {
        if ((movementType == MovementType.Deliver &amp;&amp; applyToParty == ApplyToParty.Principal)
            || (movementType == MovementType.Return &amp;&amp; applyToParty == ApplyToParty.Counterparty))
            return PositionType.Held;
        if ((movementType == MovementType.Return &amp;&amp; applyToParty == ApplyToParty.Principal)
            || (movementType == MovementType.Deliver &amp;&amp; applyToParty == ApplyToParty.Counterparty))
            return PositionType.Posted;

        return PositionType.Undefined;
    }
</code></pre>

<p>```</p>

<p>With some regularity, new records are added to these types of enums,
causing a dangerous search and update across the system fixing all the
if/else or switch/case statements.</p>

<p>Right off the bat, pattern matching is a huge win here, taking a hard
to comprehend function and making the domain concepts clear.</p>

<p>``` fsharp
let GetPositionType = function</p>

<pre><code>| Deliver, Principal | Return, Counterparty -&gt; Held
| Return, Principal | Deliver, Counterparty -&gt; Posted
| MovementType.Undefined, _ | _, ApplyToParty.Undefined -&gt; PositionType.Undefined
</code></pre>

<p>```</p>

<p>If we add a new status to any of these, we will get a compiler warning
in every place letting us know. If that alone was the win, we&rsquo;d be
still be ahead by a lot. The domain is so clear here, I can print this
code out and hand it to my BA to ensure the logic is correct.</p>

<p>Next though, this got me thinking. Why does this set of three enums
have to be calculated? Why are they even separate? Ah, of course,
right now they are stored in the database and ORM objects, each with a
separate field and set of enum ids. Changing that would be costly.</p>

<p>What I want is a domain layer a level higher than the typical database
ORM classes, something to convert my ORM classes into that will be
able to do work in a safer way.</p>

<p>Rather than three enums that are supposed to change in lock step (but
might get out of date), I really want a concept of the three combined
and &ldquo;frozen&rdquo; together.</p>

<p>``` fsharp
type Direction =</p>

<pre><code>| Held_Deliver_Principal
| Held_Return_Counterparty
| Posted_Return_Principal
| Posted_Deliver_Counterparty
</code></pre>

<p>let GetDirection = function
   | Deliver, Principal  &ndash;> Held_Deliver_Principal
   | Return, Counterparty &ndash;> Held_Return_Counterparty
   | Return, Principal &ndash;> Posted_Return_Principal
   | Deliver, Counterparty &ndash;> Posted_Deliver_Counterparty
```</p>

<p>Now I have a combined Direction that merges the three concepts into
one. It is impossible with this new merged type to have an invalid
state across the three. Getting any of the types back out to convert
into the ORM classes or do some work is as simple as another match:</p>

<p>``` fsharp
let GetMovementTypeToSaveInORM = function
   | Held_Deliver_Principal | Posted_Deliver_Counterparty &ndash;> Deliver
   | Posted_Return_Principal | Held_Return_Counterparty &ndash;> Return</p>

<p>let GetSendFn = function
   | Held_Deliver_Principal | Posted_Return_Principal &ndash;> SendMessageToPrincipal
   | Held_Return_Counterparty | Posted_Deliver_Counterparty &ndash;> SendMessageToCounterparty
```</p>

<p>While it is possible to make an equivalent C# enum and combine these
in a similar way, it is inherently unsafe (nothing to guarantee you
covered every case) and therefore appropriately uncommon. The typical
answer for safe polymorphic dispatch in C# is to use an interface and
classes. Unfortunately, something still has to dispatch on that enum
id, either inside a class or at the time of class instantiation. That
is a vector for errors.</p>

<p>Because F# interops so well with C#, it is possible to build in a
domain layer in F# immediately that calls down to your C# ORM
classes. Converting from a set of dangerous C# enums into a
constrained and safe F# discriminated union is easy and will simplify
your domain to its essence.</p>

<p>For reasons like this, when I have to build something with a rich
domain, I grab for F#.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Language Safety Algorithm]]></title>
    <link href="http://steveshogren.github.io/programming-language-safety-algorithm/"/>
    <updated>2015-02-17T14:13:00-05:00</updated>
    <id>http://steveshogren.github.io/programming-language-safety-algorithm</id>
    <content type="html"><![CDATA[<p>I think the time has come for a standard programming language safety
score. I want to use this model to help show that the concept of
safety is much more nuanced than a binary bit of &ldquo;has strong-static
types&rdquo;.</p>

<p>When someone says &ldquo;programming language safety&rdquo;, it typically invokes
thoughts of unit tests, long build times, and red squiggles in an
IDE. But, in day-to-day development, there are so many times when we
are bitten by things that somehow just slip through the cracks.</p>

<p>I put together this scoring model to get a sense of how safe a
language is at the primitive level, and if it isn&rsquo;t safe by default,
how much it costs to manually make it safe. Since all abstractions
eventually result in a series of primitive operations, I decided that
focusing only on primitives would still be a valuable (if incomplete)
data point. While any good library will handle all primitive checks
and present the consumer with a well-designed abstraction, in the end,
the consumer is still left wiring libraries together, building their
own primitive abstractions for integration. Due to the impossibility of
measuring the quality of abstractions in all libraries for a language,
I left that entirely out of scope of this model, unless it is designed
as a primitive check.</p>

<p>By focusing on only primitive operations: making and calling
functions, naming data, working with sequences, and dealing with
language primitive data types, I slimmed down the large range of
possible error vectors to a small handful. While in some languages it
is common to use user-defined classes to wrap around a set of
primitives, those classes are still doing the same primitive work,
just hidden behind a user-created abstraction. The more ways it is
possible to make a &ldquo;mistake&rdquo; with a primitive, the more difficult it
is to build such good abstractions.</p>

<pre><code>This model is not about language "power".
</code></pre>

<p>This model is not about ranking the &ldquo;power&rdquo;, &ldquo;expressiveness&rdquo;, or
&ldquo;abstract-ability&rdquo; of a language. In any language that supports
abstractions (functions, classes, modules, naming data), I am
convinced, given enough code, all Turing complete langauges can do the
same work. This model is only about the costs to prevent unexpected
&ldquo;confusion&rdquo; between the programmer and the machine at the primitive
level.</p>

<p>Rather than focus on what is <em>possible</em> with a language, I will
instead focus on what is typically idiomatic to that community. For
example, if it is possible to achieve a level of safety in a language
but by doing something uncommon, that should not be counted.</p>

<p>To score a language, simply figure out how many characters it costs to
&ldquo;prevent&rdquo; a certain type of error, and add that to the
total. Newlines, spaces, and tabs do not count, but all other
punctuation does. If a specific check is language enforced, like F#&rsquo;s
Option or C#&rsquo;s parameter type enforcement, that is given a -30 (by
default) to make up for the lack of unit tests and code exercising
needed to run that &ldquo;path&rdquo;. Do not count import lines for libraries, as
importing the module will have a negligible effect on the code size
and complexity.</p>

<p>If there is a safety feature that is not possible to achieve
programmatically, we will add +30 (by default) for a &ldquo;every change run
and debug to fix&rdquo; cost, such as Java not having a way to prevent stack
overflow exceptions caused by recursion.</p>

<pre><code>A lower score is "safer", needing less (or no) code to achieve the same level of safety.
</code></pre>

<p>Rather than tell you my thoughts (or survey for) hard-coded
weightings, all checks are weighted the same by default. Feel free to
apply your own weightings, to better match to your or your team&rsquo;s
specific needs and preferences. The languages are masked by default to
protect the innocent. You can unmask the names and see the code used
below the table.</p>

<p><div ng-app="TableApp">
<div ng-controller="TableCtrl"></p>

<p>Language Enforced Bonus:
 {{ enforcedScore }} 
<input ng-model="enforcedScore" type="range" min="0" max="50" /></p>

<p>Language Inability Penalty:
 {{ inabilityPenalty }} 
<input ng-model="inabilityPenalty" type="range" min="0" max="50" /></p>

<p>Show Weights <input type="checkbox" ng-model="showWeights" />
<p class="lead">
<div style="overflow-x:scroll">
<table class="langtable">
<tr>
<th>Safety Check</th>
<th></th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[0]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[1]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[2]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[3]"></select>
</th>
</tr>
<tr ng-repeat="check in langChecks" score-row name="check.name" row-key="check.key"></tr>
<tr class="totals"><td>Totals</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ lang }} 
</td>
</tr>
<tr class="totals"><td>Magnitude</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ percentageTotals(lang) }}% 
</td>
</tr>
</table>
</div></p>

<p><h3><input ng-model="showRealName" type="checkbox" /><span
ng-click="showRealName = !!!showRealName">Click to see backing code and unmask names</span></h3></p>

<p>Current Languages:
<span ng-repeat="lang in allLanguages">
 {{ getName(lang) }}: {{ allLangTotals[$index] }}, 
</select></p>

<p>I want to see your language represented here! I&rsquo;ll happily take pull
requests for new languages: <a href="https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders.js">blog source</a>. Just
use the &ldquo;edit language&rdquo; and &ldquo;copy to clipboard&rdquo; to build your own
language data structure.</p>

<p>I would love to see every major language represented, including major
language &ldquo;idiom communities&rdquo;. For example, Clojure and Typed Clojure
are vastly different in abilities. Similarly &ldquo;Scala &ndash; The Better Java&rdquo;
and &ldquo;Scala &ndash; The JVM Haskell&rdquo; have vastly different idioms with
apparently very separate communities.</p>

<p><div ng-show="showRealName"> Feel free to put in your own examples by
playing with the samples below. Code surrounded with &lt;! !> is ignored
from the tally, since it would vary heavily based on the language and
desired result. Variable and type names are kept at single characters,
which are counted. Feel free to add in your own language below, and
use the copy feature to extract the data structure to use in a pull
request.</p>

<p><h2>Select Language:
<select ng-options="lang.name for lang in allLanguages" ng-model="selectedLang"></select>
</h2>
<button ng-click="showEdit = !showEdit">Edit Language</button>
<button ng-click="copyToClipboard(selectedLang)">Copy Changes to Clipboard</button>
<div ng-show="showEdit">
<h2><input ng-model="selectedLang.name"></input></h2>
<div ng-repeat="check in langChecks">
<h3> {{ check.name }} :  {{ score(selectedLang[check.key]) }}  </h3>
<p>
<textarea class="widetextarea" rows="5" ng-model="selectedLang[check.key].desc"></textarea>
<div>
Code: <select ng-options="enforcedNice(e) for e in enforcedTypes" ng-model="selectedLang[check.key].enforced"></select>
<div class="tablecode">1234567890123456789012345678901234567890</div>
<div class="tablecode" >  {{ cleanCode(selectedLang[check.key].rawCode) }}  </div>
<input type="text" style="width:90%;" ng-model="selectedLang[check.key].rawCode" />
</div>
</p>
</div>
</div></p>

<p><div ng-show="!showEdit">
<h2> {{ selectedLang.name }} </h2>
<div ng-repeat="check in langChecks">
<h3> {{ check.name }} :  {{ score(selectedLang[check.key]) }}  </h3>
<p>
 {{ selectedLang[check.key].desc }} 
<div>
Code:  {{ enforcedNice(selectedLang[check.key].enforced)  }} 
<div class="tablecode" ng-if="selectedLang[check.key].rawCode">1234567890123456789012345678901234567890</div>
<div class="tablecode" >  {{ cleanCode(selectedLang[check.key].rawCode) }}  </div>
<input type="text" style="width:90%;" ng-model="selectedLang[check.key].rawCode" />
</div>
</p>
</div>
</div>
</div></p>

<p>Hope this is a helpful way to think about language safety!</p>

<p>Special thanks to (in alphabetical order):
Patrick Boe <a href="https://twitter.com/traffichazard/">(twitter)</a>,
Kyle Burton <a href="http://asymmetrical-view.com/">(blog)</a>,
Daniel Miladinov <a href="https://github.com/danielmiladinov">(github)</a>,
Chris Salch <a href="https://github.com/arlaneenalra">(github)</a>, and
Tim Visher <a href="https://github.com/timvisher">(github)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Christmas F# Polymorphism]]></title>
    <link href="http://steveshogren.github.io/christmas-f-number-polymorphism/"/>
    <updated>2014-12-06T13:37:00-05:00</updated>
    <id>http://steveshogren.github.io/christmas-f-number-polymorphism</id>
    <content type="html"><![CDATA[<p>One of my favorite things about F# is how it lets you choose how you want
to align your data.</p>

<p>In the previous posts highlighting on
<a href="http://deliberate-software.com/function-pattern-matching/">pattern matching</a>
and
<a href="http://deliberate-software.com/inversed-polymorphism/">inverted polymorphism</a>
we covered how pattern matching in F# is safer than <code>if</code>
statements and can replace classes and interfaces for polymorphism. If
you are unfamiliar with these concepts, you might want to skim those
first.</p>

<p>Today, for the 6th day of the
<a href="https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/">F# Advent Calendar</a>
I wanted to highlight F#&rsquo;s flexibility in solving the
&ldquo;<a href="http://c2.com/cgi/wiki?ExpressionProblem">expression problem</a>&rdquo;.</p>

<p>Let&rsquo;s show the two alternatives, first here is one with interfaces:</p>

<p>``` fsharp
type IChristmasTrees =</p>

<pre><code>abstract member Cost : int -&gt; int
abstract member Colors : unit -&gt; string list
</code></pre>

<p>type PlasticTree() =</p>

<pre><code>interface IChristmasTrees with
    member this.Cost(jolly_factor) = (100 * jolly_factor) / 2
    member this.Colors() = ["green";"silver"]
</code></pre>

<p>type LiveTree() =</p>

<pre><code>let HEAD_ACHE = 15
interface IChristmasTrees with
    member this.Cost(jolly_factor) = (jolly_factor + 10) * HEAD_ACHE
    member this.Colors() = ["green";"brown"]
</code></pre>

<p>```</p>

<p>Now the same functionality using pattern matching and discriminated unions.</p>

<p>``` fsharp
type IChristmasTrees2 =
  | PlasticTree
  | LiveTree</p>

<p>let colors = function
  | PlasticTree &ndash;> [&ldquo;green&rdquo;;&ldquo;silver&rdquo;]
  | LiveTree &ndash;> [&ldquo;green&rdquo;;&ldquo;brown&rdquo;]</p>

<p>let cost tree jolly_factor =
  match tree with</p>

<pre><code>| PlasticTree -&gt; (100 * jolly_factor) / 2
| LiveTree -&gt;
  let HEAD_ACHE = 15
  (jolly_factor + 10) * HEAD_ACHE
</code></pre>

<p>```</p>

<p>What changes if we want to add a new type of tree? In the class-based
example, adding a new type is quite simple, you only need to edit one
place to find all the definitions regarding the new type.</p>

<p><img class="center" src="/images/new-interfaces.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>In the pattern matching example, adding a new type requires editing
every single place you created a function that matches on the
type.</p>

<p><img class="center" src="/images/new-pattern-matching.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Thankfully, in both cases the compiler gives warnings about missing
functions or matches, so both are equally &ldquo;safe&rdquo;.</p>

<p>What about changing an existing function or adding a new function? We
now see the opposite behavior. Classes become harder to edit, because
the functions are spread across multiple classes.</p>

<p><img class="center" src="/images/change-interfaces.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>A pattern matching system is now the easier to modify, each function
only lives in one place.</p>

<p><img class="center" src="/images/change-pattern-matching.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>And that is the expression problem! The best thing about F# is that
you get to pick which one is better for each type of data! If you know
a certain type will need new behavior often, but rarely need new
types, use pattern matching. If you know there is a static set of
functions for a set of types, but the type list changes often, maybe
the traditional interfaces and classes makes the most sense.</p>

<p>There is no reason not to mix and match the two ways to handle
polymorphism, so you are free to choose the best representation for
each type of data you have!</p>

<p>Happy F#-filled Festivities!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacs Project Tip]]></title>
    <link href="http://steveshogren.github.io/emacs-project-tip/"/>
    <updated>2014-12-06T08:45:00-05:00</updated>
    <id>http://steveshogren.github.io/emacs-project-tip</id>
    <content type="html"><![CDATA[<p>I recently have been working in a Clojure project which is made up of
several microservices. While trying to build in a secure method for
each service to be able to call the others, I&rsquo;ve been in several
different projects at the same time.</p>

<p>At least once I accidentally opened the wrong &ldquo;handler.clj&rdquo; buffer,
and spent a few minutes adding a function that never worked. Since I
hate doing things like this, I wanted a simple way to see what project
I was currently viewing.</p>

<p>I started with a changing the title of the frame to show the whole
path of the current buffer, like this:</p>

<p><img class="center" src="/images/title.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code to change the title is simple, and the default in some of the
pre-packaged emacs bundles:</p>

<p>``` common-lisp
(setq frame-title-format</p>

<pre><code>  '((:eval (if (buffer-file-name)
               (abbreviate-file-name (buffer-file-name))
             "%b"))))
</code></pre>

<p>```</p>

<p>This is fine, but still not great. The font is tiny and the important
part: &ldquo;octopress&rdquo; is buried. I wanted something a little more fluid,
so I could easily tell the different projects apart instantly. I came
up with the idea to color the background faintly different based on
the path of the file. Files with a path containing &ldquo;octopress&rdquo; might
be different from those containing &ldquo;.emacs&rdquo;.</p>

<p>Thankfully, <code>buffer-face-mode</code> makes it easy to change a single
property of a single buffer&rsquo;s face without changing any other
buffer. So long as you disable buffer-face-mode when closing emacs,
your files will open with the correct coloring scheme, then have the
new background overlaid.</p>

<p>While not perfect, this was the result.</p>

<p><img class="center" src="/images/colors.png" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The colors I choose are only faintly different, but just enough for me
to tell instantly which is which.</p>

<p>The buffer colors are applied when opening a file, using these
functions:</p>

<p>``` common-lisp
(defun my-buffer-face-mode-variable (color)
  (interactive)
  (setq buffer-face-mode-face (list :background color))
  (buffer-face-mode 1))</p>

<p>(defun my-set-theme-on-mode ()
  (interactive)
  (let ((file-name (buffer-file-name)))</p>

<pre><code>(cond
;; add your own project/color mappings here
 ((string-match "halcyon" file-name) (my-buffer-face-mode-variable "#00001A"))
 ((string-match "dwarf" file-name) (my-buffer-face-mode-variable "#001A1A"))
 ((string-match "nimbus" file-name) (my-buffer-face-mode-variable "black"))
 (t ""))))
</code></pre>

<p>```</p>

<p>To force them to run when opening a file, since I use helm, I set it
to execute on exiting helm for any reason:</p>

<p><code>common-lisp
(add-hook 'helm-after-action-hook 'my-set-theme-on-mode)
;; uncomment if not using helm
;; (add-hook 'find-file-hook 'my-set-theme-on-mode)
</code></p>

<p>Lastly, to make sure emacs applies my normal theme and settings to a
buffer when starting, I disable buffer-face-mode on all buffers before
exiting.</p>

<p>``` common-lisp
(defun disable-all-buffer-face-mode ()
  (interactive)
  (let ((current (get-buffer (current-buffer))))</p>

<pre><code>(-map (lambda (x) (progn (switch-to-buffer x)
                         (buffer-face-mode 0))) (buffer-list))
(switch-to-buffer current 1)))
</code></pre>

<p>(add-hook &lsquo;kill-emacs-hook 'disable-all-buffer-face-mode)
```</p>

<p>This block needs <a href="https://github.com/magnars/dash.el">dash.el</a> to get
the -map function.</p>

<p>While not the only solution, this seemed a simple and elegant way to
quickly be reminded of your current project.</p>

<p>Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Skills Continuum]]></title>
    <link href="http://steveshogren.github.io/skill-continuum/"/>
    <updated>2014-12-02T07:26:00-05:00</updated>
    <id>http://steveshogren.github.io/skill-continuum</id>
    <content type="html"><![CDATA[<pre><code>    Learning Vim is a waste of time; I can prove it! - Anonymous
</code></pre>

<p>I recently had a gentle discussion with a new teammate about whether
or not they should learn to use Vim. My team uses a Vim emulator
inside Visual Studio and Emacs, and so we recommended he learn at
least the basics so to reduce friction when pair-programming (which we
do almost all the time).</p>

<p>He really had no desire to learn it, and took no small amount of
offense when we suggested it. The friction he felt trying to &ldquo;start
over&rdquo; really bothered him. He set out to prove that Vim was not worth
his time, and that it was actually us who needed to stop using it,
because we were the duped slow ones.</p>

<p>As any such localized experiments go, he never really came up with
anything conclusive either way. Personally, I suspect he spent more
time trying to figure out why Vim was worse than if he had just
buckled down and learned it. This got me thinking about skills we
learn as developers, and how much they cost.</p>

<h1>Skills</h1>

<p>Most skills fall along a continuum of tactical to strategic.</p>

<h3>Tactical Skills</h3>

<ul>
<li>Typing speed/accuracy</li>
<li>Keyboard shortcuts</li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs</li>
<li>Clean coding practices</li>
<li>Refactoring tools</li>
<li>Repl Driven Development / Test Driven Development</li>
<li>Debugging</li>
</ul>


<h3>Mid-way Skills</h3>

<ul>
<li>Unit testing</li>
<li>Building abstractions</li>
<li>Designing simple solutions</li>
<li>Automating tasks</li>
<li>Learning new languages and frameworks</li>
</ul>


<h3>Strategic Skills</h3>

<ul>
<li>Gathering requirements</li>
<li>Training developers</li>
<li>Organizing and leading teams</li>
<li>&ldquo;Understanding the real problem&rdquo;</li>
</ul>


<p>The more strategic the skills, the &ldquo;softer&rdquo; they become. The reason
for this is that soft skills often allow for the greatest leverage on
a project.</p>

<p>Why is this?</p>

<p>Consider the developer, who by more accurately gathering requirements
for a few extra days, realizes that the stakeholder can use a
preexisting solution instead of a six month planned project. If you
consider how many keystrokes he saved, there is no way he could have
possibly typed fast enough or refactored efficiently enough to make up
for that saved six months of effort. Unless he can typed out a six
month project in a few days, his time was better spent where it
was. Obviously, these opportunities do not happen all the time, but
they <em>do</em> happen.</p>

<p>Think about the return on investment for training developers. If you
have an average team (and yes, we all do), there is a good chance you
have some lower performing developers. I have witnessed many times
where a few months of pairing to brush up the skills of a less skilled
developer allowed them to become much more productive. In terms of
total company effort, that small investment paid back many times
before the end of the year as the newly trained developer was able to
tackle their work with the renewed vigor that comes from a greater
mastery of their work.</p>

<p>Similarly, the judicious use of automation for deployment, testing,
and building greatly reduces the friction of development for entire
teams. Lowered friction means less cognitive burden.</p>

<p>That being said, I think there comes a point where you have to put
fingers to keyboard and actually produce working software. Of course,
the fastest and best software is the software you never have to
write. But, when you absolutely must write or modify software, the
skill to actually execute becomes very important. Tactical skills
increase in significance the closer you get to the work.</p>

<p>While a great software tactician will never &ldquo;beat&rdquo; a great strategist
in terms of raw business value, a great strategist that is a terrible
tactician can only talk their way out of work. A strategist who
forgets or ignores good tactics is what we call an &ldquo;architecture
astronaut&rdquo; or an &ldquo;ivory tower architect&rdquo;. These disconnected
strategists eventually start to remove business value as their
solutions make less and less practical sense.</p>

<p>I think a developer who wants to improve should make sure they are
improving all across the spectrum. Don&rsquo;t focus only on strategic or
tactical skills, but seek projects and teams that will allow you to
gain skills across the board. I like to try to focus on one skill from
each side of the continuum each year. This year, it is emacs
automation and monads on the tactical side, and leading mature teams
on the strategic. By alternating readings, I find fuel to apply the
strategies using these new tactics!</p>

<p>Lastly, on the subject of &ldquo;what to study&rdquo;, I think it is possible to
study a number of subjects all across the continuum. Unless you have
weeks where you never type any code at all, you can practice and learn
new tactical techniques all the time. If it slows you down today, but
speeds you up next week, it might just be worth it. Even if it slowed
you down to a quarter your usual speed for two weeks, but then gives
you a measly 5% boost to productively after that, you&rsquo;ll earn that
time back by the end of the year, plus some. And 5% is not hard to
do. I&rsquo;d guess learning a few new navigation or refactoring shortcuts
would net you 5% easily.</p>

<p>When studying more strategic skills, the same holds, but they are
harder to learn. The best way I have found for learning strategic
skills is to read books about it, and try to work around others who
are good at it. Neither books or working with others will get you all
the way there, you also have to apply it yourself.</p>

<h1>Progression</h1>

<p>I usually recommend that the more experienced a person is, the more
mastery they should have in the tactical skills. A suggested path I&rsquo;ve
recommended for a new developer would look like this:</p>

<h3>0 &ndash; 6 Months:</h3>

<ul>
<li>Typing speed/accuracy</li>
<li>Keyboard shortcuts</li>
<li>Repl Driven Development / Test Driven Development</li>
<li>Unit testing</li>
<li>Clean coding practices</li>
<li>Designing simple solutions</li>
</ul>


<h3>0 &ndash; 2 Years:</h3>

<ul>
<li>Debugging</li>
<li>Refactoring tools</li>
<li>Building abstractions</li>
<li>Automating tasks</li>
<li>Learning new languages and frameworks</li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs</li>
</ul>


<h3>0 &ndash; 50+ Years:</h3>

<ul>
<li>Gathering requirements</li>
<li>Training developers</li>
<li>Organizing and leading teams</li>
<li>Understanding the real problem</li>
</ul>


<p>This is not a hard and fast list. If you are completely unsure of what
to learn, I recommend this rough progression just to get you
started. If you are a two year developer, and you cannot touch type, I
think learning it can really help, alongside the other 0 &ndash; 2 year
skills.</p>

<p>Not all skills along the list build on a mastery of the ones below
it. A developer can absolutely get to a very senior mastery of the
strategic skills only knowing one language and using notepad.exe. I
believe that they are missing out on a deep richness that comes from
better knowing their field, and I suggest they spend some time learning new
languages and tools. The more tactical the skill, usually, the easier
it is to learn, so it won&rsquo;t take very much time to come up to
speed.</p>

<p>The hardest thing I think a more senior developer has to deal with is
humbling themselves to learn a perceived &ldquo;entry-level&rdquo; skill. I have
another post brewing about this very topic, so I&rsquo;ll not get too much
into it here. But if you have gotten to a place where you feel like
you are so senior that some skills are too &ldquo;entry-level&rdquo; for you to
learn, I think you need to humble yourself and learn them. Nothing can
be gained from pretending like they are not valuable. Additionally,
the assumption that your time is now so valuable that it is &ldquo;a waste&rdquo;
to spend it on learning tactical skills is absurd.</p>

<p>Claiming you are too good to waste on low level skills not only
belittles everyone around you, but belies a deep misunderstanding of
our field. The senior developer who takes five times as long to enter
and edit code isn&rsquo;t just spending longer to do that task, but they are
paying a missed opportunity cost in time they could have spent in more
strategic endeavors. They could have been training, planning,
gathering requirements, building better automation, etc, instead they
stubbornly claim &ldquo;typing isn&rsquo;t what software is about&rdquo;. By giving it
so little credence, they have made it most of their actual mental
effort! Take simple touch-typing. Imagine how much mental effort it
takes the hunt-and-peck typist to write out a single line of
code. That is mental overhead that is simply wasted. The developer who
doesn&rsquo;t have to think about how to move a file or edit a structure
finds themselves quickly through the tactical efforts with little
distraction, free to think deeply.</p>

<h1>Resources</h1>

<p>Here are some links and books to get you started on these topics.</p>

<ul>
<li>Typing speed/accuracy &ndash; <a href="http://store.steampowered.com/agecheck/app/246580/">Typing of the Dead</a></li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs &ndash; <a href="http://vim-adventures.com/">Vim Adventures</a></li>
<li>Clean coding practices &ndash; <a href="https://cleancoders.com/">Clean Coders</a></li>
<li>Repl Driven Development &ndash; <a href="http://blog.jayfields.com/2014/01/repl-driven-development.html">RDD</a></li>
<li>Test Driven Development &ndash; <a href="http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530">http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530</a></li>
<li>Debugging &ndash; <a href="http://c.learncodethehardway.org/book/ex31.html">Debugging</a></li>
<li>Building abstractions / Designing Simple Solutions &ndash; <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and Interpretation of Computer Programs</a></li>
<li>Training developers &ndash; <a href="http://en.wikipedia.org/wiki/Pair_programming">Pair Programming</a></li>
<li>Organizing and leading teams &ndash; <a href="http://managinghumans.com/">Managing Humans</a></li>
<li>Understanding the real problem &ndash; <a href="http://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow">Thinking Fast and Slow</a></li>
<li>Learning new languages and frameworks &ndash; <a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></li>
<li>Automating tasks <a href="http://www.stuartellis.eu/articles/rake/">Rake to Automate Tasks</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
