<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: technical skills | Deliberate Software]]></title>
  <link href="http://deliberate-software.com/blog/categories/technical-skills/atom.xml" rel="self"/>
  <link href="http://deliberate-software.com/"/>
  <updated>2016-02-07T09:23:51-05:00</updated>
  <id>http://deliberate-software.com/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Haskell is the Dark Souls of Programming]]></title>
    <link href="http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/"/>
    <updated>2016-02-06T11:22:29-05:00</updated>
    <id>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming</id>
    <content type="html"><![CDATA[<p>HUMOROUS POST AHEAD. Please don&rsquo;t hit me, Haskell does a great job of that
already.</p>

<p><img class="center solaire" src="/images/altar_of_sunlight.gif" width="500" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<p>I decided to start the next version of my safety score posts. This time,
however, I decided to do it in Haskell. I love Haskell for the same reasons I
love Dark Souls. Fantastic and inscrutable lore, a great <del>combat</del> type
system, a cliff-wall difficulty curve, and unending punishment.</p>

<p>I want to collect some statistics from the GitHub API. Watch as I retrace my
steps attempting the Tomb of the Dread HTTPS GET Request.</p>

<h3>Step One - Stack (aka Pride Comes Before The Fall)</h3>

<p>I download stack and start a project:</p>

<pre><code>&gt; cd /home/jack/programming &amp;&amp; stack new github-stats &amp;&amp; cd github-stats
Downloading template "new-template" to create project "github-stats" in github-stats/ ...
 ......
All done.
</code></pre>

<p>So far so good. Does it work?</p>

<pre><code class="">  &gt; stack build &amp;&amp; stack exec -- github-stats-exe 
   github-stats-0.1.0.0: configure
   ..... 
   Registering github-stats-0.1.0.0...
   someFunc
</code></pre>

<p>Awww yisss. This is going to be so easy!</p>

<h3>Step Two - HTTPS GET Request (aka The Fall After The Pride)</h3>

<p><img class="center giants" src="/images/tomb_of_the_giants.gif" width="450" title="&lsquo;giants&rsquo; &lsquo;giants&rsquo;" ></p>

<p>Now I need to query the GitHub API. Not my first time to the rodeo, I generate a
personal access token from GitHub and copy it to a local file. What query should
I run first? How about the count for all ASM tetris repositories? Poking around
the <a href="https://developer.github.com/v3/search/#search-repositories">docs</a> comes up
with:</p>

<pre><code class="">GET https://api.github.com/search/repositories?q=tetris+language:assembly&amp;sort=stars&amp;order=desc
User-Agent: steveshogren
Authorization: token PUT_TOKEN_HERE
</code></pre>

<blockquote><p>{.. &ldquo;total_count&rdquo;: 354}</p></blockquote>

<p>Easy life. Now how do you GET a resource in Haskell? Ah,
<a href="https://hackage.haskell.org/package/HTTP-4000.3.2/docs/Network-HTTP.html">Network.HTTP</a>!
I copy the front page sample into <code>src/Lib.hs</code></p>

<pre><code class="haskell">module Lib
    ( someFunc
    ) where

x = simpleHTTP (getRequest "https://www.github.com/") &gt;&gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = 
   print x
</code></pre>

<p>So simple! This is why laugh at my NodeJS loving friends! What a bunch of cretins.</p>

<pre><code>&gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
</code></pre>

<p>Doesn&rsquo;t compile. Durp, hackage is a package library, I need to add this to my
cabal. What is the name of the package? HTTP-4000? HTTP-4000.3.2? Nothing in
hackage seems to indicate what goes into the cabal file. I discover it is just
HTTP through trial and error. I update my cabal file&hellip; in all three
build-depends&hellip;?</p>

<pre><code>  build-depends:       base &gt;= 4.7 &amp;&amp; &lt; 5
                       , HTTP
</code></pre>

<p>Hrm, same error.</p>

<pre><code>&gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
</code></pre>

<p>Oh, durp, I&rsquo;d need an import. (WHY ISN&rsquo;T THIS IN THE CODE SAMPLE?!) Also, print
doesn&rsquo;t work, I need <code>putStrLn</code>.</p>

<pre><code class="haskell">import Network.HTTP

x = simpleHTTP (getRequest "https://www.github.com/") &gt;&gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = x &gt;&gt;= putStrLn
</code></pre>

<p>Here goes!!!</p>

<pre><code> &gt; stack build &amp;&amp; stack exec -- github-stats-exe
github-stats-exe: user error (https not supported)
</code></pre>

<p>Wat. Further inspection of the docs shows a line WAAY DOWN in paragraph 5.</p>

<blockquote><p>NOTE: This package only supports HTTP;</p></blockquote>

<p><img class="center giants" src="/images/nope_better.gif" width="250" title="&lsquo;giants&rsquo; &lsquo;giants&rsquo;" ></p>

<p>When <del>playing Dark Souls</del>programming Haskell, sometimes the best move
is to run away. I search again. <code>haskell https request</code> returns
&ldquo;http-conduit&rdquo; as the best choice. After adding http-conduit to my cabal, I come
up with this beast without any surprises:</p>

<pre><code class="haskell">query :: IO String
query = do
    initReq &lt;- parseUrl "https://api.github.com/search/repositories"
    let r = initReq
                   { method = "GET"
                    , requestHeaders = [(hUserAgent, "steveshogren")
                                      , (hAuthorization, "token PUT_TOKEN_HERE")]}
    let request = setQueryString [("q", Just "tetris+language:assembly")
                                 ,("order", Just "desc")
                                 ,("sort", Just "stars")] r
    manager &lt;- newManager tlsManagerSettings
    res &lt;- httpLbs request manager
    return . show . responseBody $ res

someFunc :: IO ()
someFunc = do
   query &gt;&gt;= putStrLn
</code></pre>

<p>Huzzah! Results! I&rsquo;m getting back a monster string of json data.</p>

<blockquote><p>&ldquo;\&rdquo;{\\&ldquo;total_count\\&rdquo;:66, &hellip;.}\"</p></blockquote>

<p><img class="center solaire" src="/images/praisethesun.gif" width="150" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<h3>Step Three - Parsing JSON</h3>

<p>Time to parse this mega JSON string. Aeson seems to be the biggest contender. To
use Aeson and get the total_count value from the return, I needed the following
additions:</p>

<pre><code class="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount
</code></pre>

<p>ResultCount allows me to use <code>decode</code> from aeson instead of <code>show</code> to
parse the &ldquo;total_count&rdquo; from the JSON response into an Int. Sure enough, it
does!</p>

<pre><code class="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Lib
    ( someFunc
    ) where

import Control.Monad
import Network
import Network.HTTP.Conduit
import Network.HTTP.Types.Header
import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount

query :: IO (Maybe Int)
query = do
    initReq &lt;- parseUrl "https://api.github.com/search/repositories"
    let r = initReq
                   { method = "GET"
                    , requestHeaders = [(hUserAgent, "steveshogren")
                                      , (hAuthorization, "token PUT_TOKEN_HERE")]}
    let request = setQueryString [("q", Just "tetris+language:assembly")
                                 ,("order", Just "desc")
                                 ,("sort", Just "stars")] r
    manager &lt;- newManager tlsManagerSettings
    res &lt;- httpLbs request manager
    return . liftM total_count . decode . responseBody $ res

someFunc :: IO ()
someFunc = query &gt;&gt;= print
</code></pre>

<p>Puts out: <code>Just 66</code>. Success! Wait. 66 isn&rsquo;t the same count I got when
running from the browser. Check again. Sure enough, browser comes up with a
totally different count.</p>

<p><img class="center solaire" src="/images/come_at_me_bro.gif" width="400" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<p>Maybe the query request isn&rsquo;t correct? Adding a <code>print request</code> on line 31
after building the request shows:</p>

<pre><code>Request {
  host                 = "api.github.com"
  port                 = 443
  secure               = True
  requestHeaders       = [("User-Agent","steveshogren"),("Authorization","token PUT_TOKEN_HERE")]
  path                 = "/search/repositories"
  queryString          = "?q=tetris%2Blanguage%3Aassembly&amp;order=desc&amp;sort=stars"
  method               = "GET"
  proxy                = Nothing
  rawBody              = False
  redirectCount        = 10
  responseTimeout      = Just (-3425)
  requestVersion       = HTTP/1.1
}
</code></pre>

<p>The queryString isn&rsquo;t right! <code>?q=tetris%2Blanguage%3Aassembly&amp;order=desc&amp;sort=stars</code> It encoded my <code>+</code>
and <code>:</code>! After an hour of reading through docs and researching URL encoding
specs, it dawns on me. <code>+</code> is an encoded whitespace.</p>

<blockquote><p>No face-palm gif could ever represent the shear magnitude of my current
emotions&hellip; You&rsquo;ll have to use your imagination</p></blockquote>

<p>I change my query to <code>("q", Just "tetris language:assembly")</code> and the right
count comes back! <code>Just 354</code></p>

<p>I finally have something that correctly fetches a count of repositories from
GitHub and parses it into an Int. After over four hours of <del>Dark
Souls</del>Haskell punishment, we deserve to enjoy a bonfire!</p>

<p><img class="center solaire" src="/images/solaire_sitting.gif" width="400" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<h2>Edit: Bonus Round!</h2>

<p>Thanks to
<a href="http://bitemyapp.com/posts/2016-02-06-haskell-is-not-trivial-not-unfair.html">Chris Allen</a>
and
<a href="https://www.reddit.com/r/programming/comments/44hdl6/haskell_is_the_dark_souls_of_programming/czqaxfu">/u/JeanParker</a>
for pointing me towards <a href="http://www.serpentine.com/wreq/">wreq</a>, which weirdly
didn&rsquo;t come up when I looked around for libs yesterday. Yep, it was 6th on the
Google when searching for <code>haskell https get</code>. <code>Network.HTTP</code> is the
top three results, and that doesn&rsquo;t even <em>do</em> https.</p>

<p>¯\<em>(ツ)</em>/¯</p>

<p>Armed with their helpful suggestions, I knocked this out this morning.</p>

<pre><code class="haskell">import Network.Wreq
import Control.Lens
import Data.Aeson
import Data.Aeson.Lens
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as BS

opts :: String -&gt; String -&gt; Options
opts lang token = defaults &amp; param "q" .~ [T.pack $ "tetris language:" ++ lang]
                        &amp; param "order" .~ ["desc"]
                        &amp; param "sort" .~ ["stars"]
                        &amp; header "Authorization" .~ [BS.pack $ "token " ++ token]

query lang = do
    token &lt;- readFile "token"
    r &lt;- getWith (opts lang token) "https://api.github.com/search/repositories"
    return $ r ^? responseBody . key "total_count" . _Number
</code></pre>

<p>MUCH better. This includes reading my token from file called &ldquo;token&rdquo; so I don&rsquo;t
accidentally commit it. Also includes building up the different query options
based on inputs, which was the next step. Thanks y'all.</p>

<p><img class="center solaire" src="/images/solaire_idle.gif" width="200" title="&lsquo;solaire&rsquo; &lsquo;solaire&rsquo;" ></p>

<blockquote><p>Pixel gifs sourced from
<a href="http://zedotagger.deviantart.com/gallery/54317550/Dark-Souls">zedotagger</a> on
deviantart, thanks zedotagger!</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[F# Unit Testing with SimpleMock]]></title>
    <link href="http://deliberate-software.com/f-number-unit-testing/"/>
    <updated>2015-10-21T16:41:00-04:00</updated>
    <id>http://deliberate-software.com/f-number-unit-testing</id>
    <content type="html"><![CDATA[<p>If you are considering using F#, you might be curious how to handle unit test
mocking, especially if you want to use both modules and classes. In a language
like C# or Java, the common method is to a DI container or handmade constructor
injection on a class. These &ldquo;entry points&rdquo; allow for a unit test to replace a
real dependency with a test-only replacement.</p>

<p>I previously posted an example that shows a much simpler way to inject
dependencies called the <a href="http://deliberate-software.com/simplemock-unit-test-mocking/">SimpleMock pattern</a>. The SimpleMock pattern can also be
used in F#, even if you are only using modules.</p>

<h2>SimpleMock in F# Modules</h2>

<p>We will assume you are mocking inside a module and not a class. Mocking inside
an F# class would look much the same as it does in C#, which we showed in the
SimpleMock post. Here is a sample program that does some work and persists the
results.</p>

<pre><code class="fsharp">let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
</code></pre>

<p>To apply the SimpleMock pattern, we can use argument currying by adding a simple
function wrapper.</p>

<pre><code class="fsharp">let addAndSave' saveSum x y = 
  let sum = x + y
  saveSum sum
  sum
let addAndSave = addAndSave' DBModule.saveSum

// Test code
let addAndSave_Test =
  let calledVar = ref 0
  let result = addAndSave' (fun sum -&gt; calledVar := sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, !calledVar)
</code></pre>

<p>We started by renaming the <code>addAndSave</code> function with a trailing <code>'</code>. We
created a new <code>addAndSave</code> that calls <code>addAndSave'</code> with the correct
dependency for the first argument, leaving the rest of the arguments to be
called later. Currying is what allows this ability. The new <code>addAndSave</code>
function only needs the <code>x</code> and <code>y</code> parameters. At test time, we called <code>addAndSave'</code>, passing in the needed dependency, but using a lambda as the
&ldquo;fake&rdquo;. The injection is as close to the dependency use as possible!</p>

<h2>Bonus: SimpleMock Fake Helper</h2>

<p>The earlier replacement for DBModule.saveSum is a bit complex, and it does not
show us how many times the fake was called. We can easily make a helper that
takes parameters and returns them when called, along withe count of times it was
called.</p>

<pre><code class="fsharp">type TestFakeResults() =
  member val timesCalled = 0 with get,set
  member val args: obj list = [] with get,set

let makeFake_OneArg () =
  let results = new TestFakeResults()
  let fake = (fun p1 -&gt;
                  results.args &lt;- p1 :: results.args
                  results.timesCalled &lt;- results.timesCalled + 1
                  ())
  (fake, results)
</code></pre>

<p>The above code might be hard to comprehend at first! We have made a generic
helper that can create any single argument fake we need. We return a tuple,
containing the fake lambda and an instance of <code>TestFakeResults</code>. The fake
lambda will populate the <code>TestFakeResults</code>, which we can access in the test
via the second arg of the tuple.</p>

<p>We can now re-write the previous test using <code>makeFake_OneArg</code>:</p>

<pre><code class="fsharp">// Test code
let addAndSave_Test =
  let (fakeSave, fakeSaveCalling) = makeFake_OneArg()
  let result = addAndSave' fakeSave 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaveCalling.args.[0])
  Assert.AreEqual(1, fakeSaveCalling.timesCalled)
</code></pre>

<p>The TestFakeResults can return information about the way it was called,
including the list of all arguments. If we felt we needed the extra
expressiveness, we could also use a mocking library like RhinoMocks or Moq. The
TestFakeResults and its constructor are not essential to the pattern. The most
important part is learning to unit test in F# with confidence.</p>

<h1>Double Bonus: When to Use a Class Instead of a Record</h1>

<p>When I first wrote this post, I used a record instead of a class for the <code>TestFakeResults</code> type. If you have been bitten by the functional programming bug,
you might have wondered at my usage of a mutable class. Here are two alternates
of <code>makeFake_OneArg</code> which use records. You can probably see why I switched to a class:</p>

<pre><code class="fsharp">type TestFakeResults = {timesCalled:int, args obj list}

// Using Record Alternate 1
let makeFake_OneArg_RecordAlternate1 () = 
  let t = ref 0
  let a : obj list ref = ref []
  let fake = (fun p1 -&gt;
                  a := p1 :: !a
                  t := !t + 1
                  ())
  (fake, (fun () -&gt;
                {TestFakeRecord.timesCalled = !t;
                 args = !a}))

// Using Record Alternate 2
let makeFake_OneArg_RecordAlternate2 () = 
  let result = ref {TestFakeRecord.timesCalled = 0; args = []}
  let fake = (fun p1 -&gt;
              result := {timesCalled = (!result).timesCalled + 1;
                         args = p1 :: (!result).args}
              ())
  (fake, (fun () -&gt; !result))
</code></pre>

<p>The only way to use a record is to delay its construction via a lambda which
must be executed by the test code. Both are complex: what we need is a mutable
data structure which we can access via a reference. A record is not that. We can
approximate it using tricks, but ultimately I find both alternatives to be too
complex to justify their use. Sometimes a mutable data structure is the best
choice to solve your problem efficiently. The power of F# is that it gives us
the ability to choose the best tool for the job: records for immutability,
classes for mutability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SimpleMock: Language Agnostic Unit Test Mocking]]></title>
    <link href="http://deliberate-software.com/simplemock-unit-test-mocking/"/>
    <updated>2015-08-13T06:53:00-04:00</updated>
    <id>http://deliberate-software.com/simplemock-unit-test-mocking</id>
    <content type="html"><![CDATA[<p>SimpleMock is a pattern for reducing TDD damage. You can use the pattern to
organize your testing code without mocking or complicated dependency injection.</p>

<p>SimpleMock works in any language with closures that can be passed around by
reference, so off the top of my head: C#, Java, F#, Scala, PHP, C++, Ruby, and
Python. I&rsquo;m sure you can think of others.</p>

<h2>Example:</h2>

<p>Here is a brief (if a bit silly) example of the final pattern:</p>

<pre><code class="csharp">public class LineCounter {
    internal Func&lt;string, IEnumerable&lt;string&gt;&gt; _readLines = File.ReadLines;

    public string CountLines(string filename) {
        return _readLines(filename).Count();
    }
}

/// Test Code
[TestCase]
public void TestLineCounter () {
    var sut = new LineCounter();
    // "SimpleMock" of File.ReadLines
    sut._readLines = (string x) =&gt; new List&lt;string&gt;{"test", "that"};

    var result = sut.CountLines("test");

    Assert.AreEqual(2, result);
}
</code></pre>

<h2>Benefits</h2>

<ul>
<li>Reduced boilerplate</li>
<li>Saves interfaces for real polymorphism</li>
<li>Simplifies test code</li>
<li>Reduces testing concerns in production code</li>
<li>Removes need for fragile IoC containers</li>
<li>Encourages better abstraction design</li>
<li>Can convert one class at a time!</li>
</ul>


<p>The SimpleMock pattern promotes a better design of your abstractions and simpler
tests. The pattern also reduces boilerplate and the pollution of your production
code with testing concerns.</p>

<p>If you aren&rsquo;t familiar with the normal pattern of unit test mocking using
interfaces, dependency injection, and mock libraries, scroll down to &ldquo;The
Non-SimpleMock Way&rdquo; at the end of the post.</p>

<h2>SimpleMock Pattern</h2>

<p>The SimpleMock pattern is aptly named.</p>

<ol>
<li>Replace Test-Only Interfaces With Functions</li>
<li>Define Dependencies Inline</li>
<li>Write Better Abstractions</li>
</ol>


<h2>Step One: Replace Test-Only Interfaces With Functions</h2>

<p>My examples are in C# because that is what I got paid to write today - it is
freshest in memory. C# has an incredible ability to create and pass around
lambdas and function references. Here is an example of using functions instead
of interfaces.</p>

<pre><code class="csharp">public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}
public class Translator {
    private Func&lt;DateTime&gt; _getCurrentTime;

    public Translator() : this(new CurrentTime().GetCurrentTime) {}

    public Translator(Func&lt;DateTime&gt; getCurrentTime) {
        this._getCurrentTime = getCurrentTime;
    }

    public string Translate(string input) {
        return string.Format("{0}: {1}", _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;

    var sut = new Translator(() =&gt; now);

    var result = sut.Translate("test");

    Assert.AreEqual(now.ToString() + ": test", result);
}
</code></pre>

<p>The test code is quite simple! No longer do we need the dependency on third
party mocking libraries, or the relatively complicated setup logic. Instead we
can simply inject the lambda at runtime, replacing that pointer. We didn&rsquo;t need
the whole interface, really we just needed the simple signature of the function.</p>

<h2>Step 2: Define Dependencies Inline</h2>

<p>We can take it even a step further. Why use constructor injection at all? Since
all we really want is a single mutable dispatch table row, why not just make it
that way?</p>

<pre><code class="csharp">public class Translator {
    internal Func&lt;DateTime&gt; _getCurrentTime = new CurrentTime().GetCurrentTime;

    public string Translate(string input) {
        return string.Format("{0}: {1}", _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;
    var sut = new Translator();
    sut._getCurrentTime = () =&gt; now;

    var result = sut.Translate("test");

    Assert.AreEqual(now.ToString() + ": test", result);
}
</code></pre>

<p>We&rsquo;ve cleaned up our nasty multi-line indirection into a single dispatch line.
&ldquo;Go to definition&rdquo; now takes me to the actual line with the actual called
function. We&rsquo;ve replaced a dependency on a class based interface with a function
signature. The function signature <em>is</em> the interface!</p>

<p>You probably noticed we have lost something with this final version. We have
lost the ability to inject polymorphic behavior through the constructor. If you
need it, simply go back to injecting the interface in the constructor or by
passing it into the function itself. In practice, I have found this is needed
very rarely, making the SimpleMock pattern a better tool to reach for first.</p>

<h2>Step 3: Write Better Abstractions</h2>

<p>Lastly, SimpleMock actually promotes better designs. For example, a coworker was
writing some tests today and ran into a complicated situation. Take the
following sanitized code:</p>

<pre><code class="csharp">public class WorkDoer {
    internal Action&lt;Thing&gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Action&lt;Thing&gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public void IgnoreAndRemoveThings(Thing t1, Thing t2) {
        ignoreElements(t1);
        ignoreElements(t2);
        removeIgnoredElements(t1);
        removeIgnoredElements(t2);
    }
}
</code></pre>

<p>How would you check that each section was called? Our naive solution was a
complicated lambda with a &ldquo;timesCalled&rdquo; counter and an if statement to assert
against each argument, but it turns nasty quickly:</p>

<pre><code class="csharp">/// Nasty test code
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();

    var ignoredCalledTimes = 0;
    sut.ignoreElements = (t) =&gt; {
        ignoredCalledTimes++;
        if (ignoredCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };
    var removedCalledTimes = 0;
    sut.removeIgnoredElements = (t) =&gt; {
        removedCalledTimes++;
        if (removedCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };

    var t1 = new Thing();
    var t2 = new Thing();

    var result = sut.IgnoreAndRemoveThings(t1, t2);
    Assert.AreEqual(2, removedCalledTimes);
    Assert.AreEqual(2, ignoredCalledTimes);
}
</code></pre>

<p>Yuck! The test is an absolute catastrophe. I see a mess of mixed concerns.
Conditionals?! In a test?! Unconscionable.</p>

<p>In situations like this, we have two easy options. Option one is to just use
a third party mocking library, replacing the functions from inside the test
code. This gives us access to all the sophisticated mocking tools available.</p>

<p>My preferred option is seeking to decomplect the production code by using better
abstractions.</p>

<p>I have found that strong reliance of mocking libraries enables worse designs.
Consider the code, what makes it so hard to test? Not knowing which element is
called when, doing the same work on two parameters, and reference mutation all
make this a poor abstraction. Why not simplify?</p>

<pre><code class="csharp">public class WorkDoer {
    internal Func&lt;Thing, Thing&gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Func&lt;Thing, Thing&gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public List&lt;Thing&gt; IgnoreAndRemoveThings(List&lt;Thing&gt; ts) {
        return ts.Select(t =&gt; removeIgnoredElements(ignoreElements(t)));
    }
}

/// Simpler test
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();
    var expected = new Thing();
    var ts = new List&lt;Thing&gt;{new Thing()};

    sut.ignoreElements = (t) =&gt; new Thing();

    sut.removeIgnoredElements = (t) =&gt; {
        Assert.AreEqual(t, sut.ignoreElements(t));
        return expected;
    };

    var result = sut.IgnoreAndRemoveThings(ts);

    Assert.AreEqual(expected, result.First())
}
</code></pre>

<p>Much better! Yes, we had to change a few signatures. We get the same work done,
but now the code is actually a lot more useful. Our test code is comparable with
anything you&rsquo;d find using a mocking library. I am absolutely okay with using a
mocking library when needed, but I always carefully consider my abstractions and
design first.</p>

<p>If mocking libraries and IoC containers are the chainsaws of the testing world,
then SimpleMock is the garden shears. Sometimes the chainsaw is the only tool
for the job, and that is fine. But for most work around the yard, you can leave
the chainsaw in the shed.</p>

<h2>Conclusion</h2>

<p>I’ve shown how you can really simplify your code with SimpleMock. The dispatch
row is clear and easy to read. We have removed some third party mocking
dependencies. You can remove a lot of the boilerplate &ldquo;for making it more
testable&rdquo; from your code. The test code is greatly simplified, and injection a
breeze. The result: much simpler code, just as easy to test.</p>

<p>Thanks to Shuwei Chen for helping me put this together!</p>

<h2>The Non-SimpleMock Way</h2>

<p>If you are familiar with unit test mocking with interfaces, this part is
probably boring. Feel free to skip.</p>

<p>The traditional way of performing C# unit test mocking involves dependency
injection and interface mocking using a mocking library. For dependency
injection, it is common to use a tool like Ninject or hand-rolled constructor
injection. For mocking, a library like Moq or Rhino Mocks is standard. Here is
an example of a class and its testing code without any business logic.</p>

<pre><code class="csharp">public interface ICurrentTime {
    DateTime GetCurrentTime();
}

public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}

public class Translator {
    private readonly ICurrentTime ct;

    public Translator() : this(new CurrentTime()) {}

    public Translator(ICurrentTime currentTime) {
        this.ct = currentTime;
    }

    public string Translate(string input) {
        return string.Format("{0}: {1}", ct.GetCurrentTime().ToString(), input);
    }
}

/// Test Code with Moq
[TestCase]
public void TestCurrentTimeTranslator () {
    var rightNow = DateTime.Now;
    var mock = new Mock&lt;ICurrentTime&gt;();

    mock.Setup(a=&gt;a.GetCurrentTime()).Returns(rightNow);

    var sut = new Translator(mock.Object);

    var result = sut.Translate("test");

    Assert.AreEqual(rightNow.ToString() + ": test", result);
}
</code></pre>

<p>If you&rsquo;ve done much C# unit testing, this should look familiar. We want to
inject some code that is potentially long-running or dynamic. We put that code
into a class, add an interface, then inject that interface into the class we
want to test. To test it, we mock the interface, creating a different concrete
class at test runtime which implements that interface. We can setup that mock to
respond with anything, which we use for assertions.</p>

<h2>What&rsquo;s Wrong with the Non-SimpleMock Way?</h2>

<p>The first problem is we have created a whole interface just for testing.
Interfaces are for polymorphism, but we don&rsquo;t really need polymorphism for this
class. We simply want to mock it. The constructor injection is also test code
polluting our business logic.</p>

<p>What we have done is create a very small and primitive dispatch table. The
table has one row: something that has a function with the signature of <code>() -&gt; DateTime</code> or, as it is known in C#: <code>Func&lt;DateTime&gt;</code>.  We will need to make
this primitive dispatch table for every single mock in every single class we
wish to test. That&rsquo;s a lot of boilerplate!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Language Safety Score Mark 2]]></title>
    <link href="http://deliberate-software.com/safety-rank-part-2/"/>
    <updated>2015-07-24T10:13:00-04:00</updated>
    <id>http://deliberate-software.com/safety-rank-part-2</id>
    <content type="html"><![CDATA[<p>I want to make a model that predicts bugs.</p>

<p>I previously wrote a table for scoring language safety:
<a href="http://deliberate-software.com/programming-language-safety-algorithm/">Programming Language Safety Score</a>,
but it was extremely time consuming to score new languages or make modifications.</p>

<h2>Simplify, Simplify</h2>

<p>After being told I was <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>
the data, I&rsquo;ve attempted to clean up by simply checking if each category is
enforced, possible, or impossible. I score each as either 1 (language enforced),
0 (possible, but you have to remember to do it), or -1 (impossible). When the
magnitudes of the new model are compared with the previous model, they come out
very similar. The shape of the curve pretty much stays the same, which I was
told indicates that the character count weighting was a variable that didn&rsquo;t
matter.</p>

<p><img class="center" src="/images/rplot.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The code I used to generate the plot and normalize the scores can be found here:
<a href="https://github.com/steveshogren/datasciencecoursera/blob/817dec79e36b6e9a6c5a8fd5700aff7cc394b9d4/scoreplot.R">scorePlot.R</a></p>

<h2>Safety Definitions</h2>

<p>A definition of the safety checks is as follows:</p>

<p><div ng-app="TableApp2">
<div ng-controller="TableCtrl">
<table class="langtable">
<tr><th>Check</th> <th>Description</th></tr>
<tr ng-repeat="check in langChecks">
<td> {{ check.name }} </td>
<td>  {{ check.desc }}  </td>
</tr>
</table></p>

<p>The new scores are shown here, with a lot more languages added in:</p>

<p><p class="lead">
<div style="overflow-x:scroll">
<table class="langtable">
<tr>
<th>Safety Check</th>
<th></th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[0]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[1]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[2]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[3]"></select>
</th>
</tr>
<tr ng-repeat="check in langChecks" score-row name="check.name" row-key="check.key"></tr>
<tr class="totals"><td>Totals</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ lang }} 
</td>
</tr>
<tr class="totals"><td>Magnitude</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ percentageTotals(lang) }}% 
</td>
</tr>
</table>
</div></p>

<p>Current Languages:
<span ng-repeat="lang in allLanguages">
 {{ getName(lang) }}: {{ allLangTotals[$index] }}, 
</select></p>

<h2>So, What&rsquo;s the Point?</h2>

<p>To see how this model corresponds with data in the real world, I used the GitHub
API to query for the number of bugs created in repositories with more than 15
forks created in a span from 2011 to 2015. Commits were counted by summing the
commit counts of all contributors.</p>

<p>I decided to rely on the count of commits as a standard for a unit of work. My
assumption was that across fifty different projects, the commit sizes would
average out. Once the unit of work was decided on, I wanted to find the ratio of
bugs per commit for each language.</p>

<p>I collected the ratio of bugs logged per commit for each repository, and after
grouping by primary language, removed the top and bottom 25% using the
bug/commit ratio, which is a common practice in statistics to help find a more
accurate average. I summed the bugs and commits of those remaining repositories
grouped by language, finding a total average bug/commit ratio for each language
grouping. Here is that data, sorted by safety score.</p>

<p><table class="langtable">
<tr><th>Language</th>
<th>Bugs</th>
<th>Commits</th>
<th>Repositories</th>
<th>Bug/Commits</th>
<tr ng-repeat="lang in languageRatios">
<td> {{ lang.name }} </td>
<td> {{ lang.bugs }} </td>
<td> {{ lang.commits }} </td>
<td> {{ lang.repos }} </td>
<td> {{ getBugsRatio(lang) }} </td>
</tr>
</table></p>

<p>Here are the languages sorted by safety score with bug/commit ratios:</p>

<p><img class="center" src="/images/errorChart.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" >
<img class="center" src="/images/bugsAverage.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>I took the magnitude of the safety scores and the bug/commit ratios. After
inverting the safety scores, I overlaid them both onto a single graph.</p>

<p><img class="center" src="/images/bothMags.jpg" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>Immediately it is obvious that Ruby, Python, PHP, and Clojure all seem to strongly
buck the trend, but otherwise the languages follow a pretty consistent slope
down in bugs. Taking the correlation gives a
<a href="https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient">correlation coefficient</a>
of .55</p>

<h2>What About Unit Tests?</h2>

<p>Thinking that Ruby, Clojure, PHP, and Python might not correlate well due to some
other factor, I collected data on how many tests each repository had. I counted
the number of files containing &ldquo;test&rdquo; or &ldquo;spec&rdquo;, which gave the following,
sorted by tests per commit:</p>

<p><table class="langtable">
<tr><th>Language</th>
<th>Tests</th>
<th>Commits</th>
<th>Repositories</th>
<th>Tests/Commits</th></tr>
<tr ng-repeat="lang in sorter(languageRatios)">
<td> {{ lang.name }} </td>
<td> {{ lang.test }} </td>
<td> {{ lang.commits }} </td>
<td> {{ lang.repos }} </td>
<td> {{ getTestsRatio(lang) }} </td>
</tr>
</table></p>

<p>PHP, Python, and Ruby all have a higher then average number of tests, but
Clojure does not. Additionally, Go, Scala, and Java all also have a higher than
average number of tests, yet they score relatively average in bugs/commit.</p>

<h2>Conclusion</h2>

<p>In conclusion, the current safety model I have proposed seems to account for a
moderate reduction in bugs per commit across the sampled languages, but is not
the only factor. It currently is unable to account for a significantly lower
than expected bug count in Ruby and Clojure.</p>

<h2>Special Thanks</h2>

<p>Special thanks to (in alphabetical order):
<a href="https://twitter.com/traffichazard/">Patrick Boe</a> (Haskell, Sniff Test),
<a href="http://asymmetrical-view.com/">Kyle Burton</a> (General Advice),
Nils Creque (Listening Board),
Max Haley (Python, Ruby, Teaching me how to math),
<a href="https://github.com/danielmiladinov">Daniel Miladinov</a> (Java, Scala, Morale Support),
Keith O'Brien (Ruby and JS),
<a href="https://github.com/arlaneenalra">Chris Salch</a> (CoffeeScript and JS),
and <a href="https://github.com/timvisher">Tim Visher</a> (Clojure).</p>

<p>Additional thanks to the posters on
<a href="https://www.reddit.com/r/rust/comments/3egx49/language_safety_score_mark_2/">/r/rust</a>,
including <a href="https://www.reddit.com/user/notriddle">/u/notriddle</a>,
<a href="https://www.reddit.com/user/killercup">/u/killercup</a>, and
<a href="https://www.reddit.com/user/diegobernardes">/u/diegobernardes</a> who put together the Rust score.</p>

<h2>Complaints Department</h2>

<p>Did I mess up something about a language here, or am I missing a safety check? I&rsquo;ll happily take pull
requests for new languages:
<a href="https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders2.js">blog source</a>. Just
pick an existing language, edit the name and values, and &ldquo;copy to clipboard&rdquo; to
build your own language data structure. Send it to me in a PR and I&rsquo;ll include
it along with a thanks on the page.</p>

<p><div ng-show="showRealName">
<h2>Select Language:
<select ng-options="lang.name for lang in allLanguages" ng-model="selectedLang"></select>
<button ng-click="copyToClipboard(selectedLang)">Copy Changes to Clipboard</button>
</h2>
<h2><input ng-model="selectedLang.name"></input></h2>
<table class="langtable">
<tr><th>Check</th><th>Option</th></tr>
<tr ng-repeat="check in langChecks">
<td style="background-color: {{scoreClass(score(selectedLang[check.key]))}} ">
 {{ check.name }}:  {{score(selectedLang[check.key]) }} 
</td>
<td>
<select ng-options="enforcedNice(e) for e in enforcedTypes" ng-model="selectedLang[check.key].enforced"></select>
</td>
</tr>
</table></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Case Study: Type-safe Domain Modeling in F#]]></title>
    <link href="http://deliberate-software.com/pattern-matching-case-study/"/>
    <updated>2015-03-14T09:42:00-04:00</updated>
    <id>http://deliberate-software.com/pattern-matching-case-study</id>
    <content type="html"><![CDATA[<p>Domain modeling in F# is significantly easier and safer than with the
traditional .NET languages. This is because of the increased safety of
pattern matching and the expressiveness of discriminated unions. These
concepts are not in C# or VB.NET, and therefore bring a new tool to
the table.</p>

<p>To illustrate this, I found some old code I&rsquo;d written to interact with
a legacy system. The system uses many single enums on a record to keep
track of statuses. When one changes, it can cause others to change as
well.</p>

<p>Here is a typical function that combines two enums to recalculate a
third.</p>

<pre><code class="csharp">        public static PositionType GetPositionType (MovementType movementType, ApplyToParty applyToParty)
        {
            if ((movementType == MovementType.Deliver &amp;&amp; applyToParty == ApplyToParty.Principal)
                || (movementType == MovementType.Return &amp;&amp; applyToParty == ApplyToParty.Counterparty))
                return PositionType.Held;
            if ((movementType == MovementType.Return &amp;&amp; applyToParty == ApplyToParty.Principal)
                || (movementType == MovementType.Deliver &amp;&amp; applyToParty == ApplyToParty.Counterparty))
                return PositionType.Posted;

            return PositionType.Undefined;
        }
</code></pre>

<p>With some regularity, new records are added to these types of enums,
causing a dangerous search and update across the system fixing all the
if/else or switch/case statements.</p>

<p>Right off the bat, pattern matching is a huge win here, taking a hard
to comprehend function and making the domain concepts clear.</p>

<pre><code class="fsharp">let GetPositionType = function
    | Deliver, Principal | Return, Counterparty -&gt; Held
    | Return, Principal | Deliver, Counterparty -&gt; Posted
    | MovementType.Undefined, _ | _, ApplyToParty.Undefined -&gt; PositionType.Undefined
</code></pre>

<p>If we add a new status to any of these, we will get a compiler warning
in every place letting us know. If that alone was the win, we&rsquo;d be
still be ahead by a lot. The domain is so clear here, I can print this
code out and hand it to my BA to ensure the logic is correct.</p>

<p>Next though, this got me thinking. Why does this set of three enums
have to be calculated? Why are they even separate? Ah, of course,
right now they are stored in the database and ORM objects, each with a
separate field and set of enum ids. Changing that would be costly.</p>

<p>What I want is a domain layer a level higher than the typical database
ORM classes, something to convert my ORM classes into that will be
able to do work in a safer way.</p>

<p>Rather than three enums that are supposed to change in lock step (but
might get out of date), I really want a concept of the three combined
and &ldquo;frozen&rdquo; together.</p>

<pre><code class="fsharp">type Direction = 
    | Held_Deliver_Principal
    | Held_Return_Counterparty
    | Posted_Return_Principal
    | Posted_Deliver_Counterparty

let GetDirection = function
   | Deliver, Principal  -&gt; Held_Deliver_Principal
   | Return, Counterparty -&gt; Held_Return_Counterparty
   | Return, Principal -&gt; Posted_Return_Principal
   | Deliver, Counterparty -&gt; Posted_Deliver_Counterparty
</code></pre>

<p>Now I have a combined Direction that merges the three concepts into
one. It is impossible with this new merged type to have an invalid
state across the three. Getting any of the types back out to convert
into the ORM classes or do some work is as simple as another match:</p>

<pre><code class="fsharp">let GetMovementTypeToSaveInORM = function
   | Held_Deliver_Principal | Posted_Deliver_Counterparty -&gt; Deliver
   | Posted_Return_Principal | Held_Return_Counterparty -&gt; Return

let GetSendFn = function
   | Held_Deliver_Principal | Posted_Return_Principal -&gt; SendMessageToPrincipal
   | Held_Return_Counterparty | Posted_Deliver_Counterparty -&gt; SendMessageToCounterparty
</code></pre>

<p>While it is possible to make an equivalent C# enum and combine these
in a similar way, it is inherently unsafe (nothing to guarantee you
covered every case) and therefore appropriately uncommon. The typical
answer for safe polymorphic dispatch in C# is to use an interface and
classes. Unfortunately, something still has to dispatch on that enum
id, either inside a class or at the time of class instantiation. That
is a vector for errors.</p>

<p>Because F# interops so well with C#, it is possible to build in a
domain layer in F# immediately that calls down to your C# ORM
classes. Converting from a set of dangerous C# enums into a
constrained and safe F# discriminated union is easy and will simplify
your domain to its essence.</p>

<p>For reasons like this, when I have to build something with a rich
domain, I reach for F#.</p>
]]></content>
  </entry>
  
</feed>
