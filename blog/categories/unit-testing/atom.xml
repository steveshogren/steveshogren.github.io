<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unit testing | Deliberate Software]]></title>
  <link href="http://deliberate-software.com/blog/categories/unit-testing/atom.xml" rel="self"/>
  <link href="http://deliberate-software.com/"/>
  <updated>2016-02-19T17:11:44-05:00</updated>
  <id>http://deliberate-software.com/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[F# Unit Testing with SimpleMock]]></title>
    <link href="http://deliberate-software.com/f-number-unit-testing/"/>
    <updated>2015-10-21T16:41:00-04:00</updated>
    <id>http://deliberate-software.com/f-number-unit-testing</id>
    <content type="html"><![CDATA[<p>If you are considering using F#, you might be curious how to handle unit test
mocking, especially if you want to use both modules and classes. In a language
like C# or Java, the common method is to a DI container or handmade constructor
injection on a class. These &ldquo;entry points&rdquo; allow for a unit test to replace a
real dependency with a test-only replacement.</p>

<p>I previously posted an example that shows a much simpler way to inject
dependencies called the <a href="http://deliberate-software.com/simplemock-unit-test-mocking/">SimpleMock pattern</a>. The SimpleMock pattern can also be
used in F#, even if you are only using modules.</p>

<h2>SimpleMock in F# Modules</h2>

<p>We will assume you are mocking inside a module and not a class. Mocking inside
an F# class would look much the same as it does in C#, which we showed in the
SimpleMock post. Here is a sample program that does some work and persists the
results.</p>

<pre><code class="fsharp">let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
</code></pre>

<p>To apply the SimpleMock pattern, we can use argument currying by adding a simple
function wrapper.</p>

<pre><code class="fsharp">let addAndSave' saveSum x y = 
  let sum = x + y
  saveSum sum
  sum
let addAndSave = addAndSave' DBModule.saveSum

// Test code
let addAndSave_Test =
  let calledVar = ref 0
  let result = addAndSave' (fun sum -&gt; calledVar := sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, !calledVar)
</code></pre>

<p>We started by renaming the <code>addAndSave</code> function with a trailing <code>'</code>. We
created a new <code>addAndSave</code> that calls <code>addAndSave'</code> with the correct
dependency for the first argument, leaving the rest of the arguments to be
called later. Currying is what allows this ability. The new <code>addAndSave</code>
function only needs the <code>x</code> and <code>y</code> parameters. At test time, we called <code>addAndSave'</code>, passing in the needed dependency, but using a lambda as the
&ldquo;fake&rdquo;. The injection is as close to the dependency use as possible!</p>

<h2>Bonus: SimpleMock Fake Helper</h2>

<p>The earlier replacement for DBModule.saveSum is a bit complex, and it does not
show us how many times the fake was called. We can easily make a helper that
takes parameters and returns them when called, along withe count of times it was
called.</p>

<pre><code class="fsharp">type TestFakeResults() =
  member val timesCalled = 0 with get,set
  member val args: obj list = [] with get,set

let makeFake_OneArg () =
  let results = new TestFakeResults()
  let fake = (fun p1 -&gt;
                  results.args &lt;- p1 :: results.args
                  results.timesCalled &lt;- results.timesCalled + 1
                  ())
  (fake, results)
</code></pre>

<p>The above code might be hard to comprehend at first! We have made a generic
helper that can create any single argument fake we need. We return a tuple,
containing the fake lambda and an instance of <code>TestFakeResults</code>. The fake
lambda will populate the <code>TestFakeResults</code>, which we can access in the test
via the second arg of the tuple.</p>

<p>We can now re-write the previous test using <code>makeFake_OneArg</code>:</p>

<pre><code class="fsharp">// Test code
let addAndSave_Test =
  let (fakeSave, fakeSaveCalling) = makeFake_OneArg()
  let result = addAndSave' fakeSave 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaveCalling.args.[0])
  Assert.AreEqual(1, fakeSaveCalling.timesCalled)
</code></pre>

<p>The TestFakeResults can return information about the way it was called,
including the list of all arguments. If we felt we needed the extra
expressiveness, we could also use a mocking library like RhinoMocks or Moq. The
TestFakeResults and its constructor are not essential to the pattern. The most
important part is learning to unit test in F# with confidence.</p>

<h1>Double Bonus: When to Use a Class Instead of a Record</h1>

<p>When I first wrote this post, I used a record instead of a class for the <code>TestFakeResults</code> type. If you have been bitten by the functional programming bug,
you might have wondered at my usage of a mutable class. Here are two alternates
of <code>makeFake_OneArg</code> which use records. You can probably see why I switched to a class:</p>

<pre><code class="fsharp">type TestFakeResults = {timesCalled:int, args obj list}

// Using Record Alternate 1
let makeFake_OneArg_RecordAlternate1 () = 
  let t = ref 0
  let a : obj list ref = ref []
  let fake = (fun p1 -&gt;
                  a := p1 :: !a
                  t := !t + 1
                  ())
  (fake, (fun () -&gt;
                {TestFakeRecord.timesCalled = !t;
                 args = !a}))

// Using Record Alternate 2
let makeFake_OneArg_RecordAlternate2 () = 
  let result = ref {TestFakeRecord.timesCalled = 0; args = []}
  let fake = (fun p1 -&gt;
              result := {timesCalled = (!result).timesCalled + 1;
                         args = p1 :: (!result).args}
              ())
  (fake, (fun () -&gt; !result))
</code></pre>

<p>The only way to use a record is to delay its construction via a lambda which
must be executed by the test code. Both are complex: what we need is a mutable
data structure which we can access via a reference. A record is not that. We can
approximate it using tricks, but ultimately I find both alternatives to be too
complex to justify their use. Sometimes a mutable data structure is the best
choice to solve your problem efficiently. The power of F# is that it gives us
the ability to choose the best tool for the job: records for immutability,
classes for mutability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SimpleMock: Language Agnostic Unit Test Mocking]]></title>
    <link href="http://deliberate-software.com/simplemock-unit-test-mocking/"/>
    <updated>2015-08-13T06:53:00-04:00</updated>
    <id>http://deliberate-software.com/simplemock-unit-test-mocking</id>
    <content type="html"><![CDATA[<p>SimpleMock is a pattern for reducing TDD damage. You can use the pattern to
organize your testing code without mocking or complicated dependency injection.</p>

<p>SimpleMock works in any language with closures that can be passed around by
reference, so off the top of my head: C#, Java, F#, Scala, PHP, C++, Ruby, and
Python. I&rsquo;m sure you can think of others.</p>

<h2>Example:</h2>

<p>Here is a brief (if a bit silly) example of the final pattern:</p>

<pre><code class="csharp">public class LineCounter {
    internal Func&lt;string, IEnumerable&lt;string&gt;&gt; _readLines = File.ReadLines;

    public string CountLines(string filename) {
        return _readLines(filename).Count();
    }
}

/// Test Code
[TestCase]
public void TestLineCounter () {
    var sut = new LineCounter();
    // "SimpleMock" of File.ReadLines
    sut._readLines = (string x) =&gt; new List&lt;string&gt;{"test", "that"};

    var result = sut.CountLines("test");

    Assert.AreEqual(2, result);
}
</code></pre>

<h2>Benefits</h2>

<ul>
<li>Reduced boilerplate</li>
<li>Saves interfaces for real polymorphism</li>
<li>Simplifies test code</li>
<li>Reduces testing concerns in production code</li>
<li>Removes need for fragile IoC containers</li>
<li>Encourages better abstraction design</li>
<li>Can convert one class at a time!</li>
</ul>


<p>The SimpleMock pattern promotes a better design of your abstractions and simpler
tests. The pattern also reduces boilerplate and the pollution of your production
code with testing concerns.</p>

<p>If you aren&rsquo;t familiar with the normal pattern of unit test mocking using
interfaces, dependency injection, and mock libraries, scroll down to &ldquo;The
Non-SimpleMock Way&rdquo; at the end of the post.</p>

<h2>SimpleMock Pattern</h2>

<p>The SimpleMock pattern is aptly named.</p>

<ol>
<li>Replace Test-Only Interfaces With Functions</li>
<li>Define Dependencies Inline</li>
<li>Write Better Abstractions</li>
</ol>


<h2>Step One: Replace Test-Only Interfaces With Functions</h2>

<p>My examples are in C# because that is what I got paid to write today - it is
freshest in memory. C# has an incredible ability to create and pass around
lambdas and function references. Here is an example of using functions instead
of interfaces.</p>

<pre><code class="csharp">public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}
public class Translator {
    private Func&lt;DateTime&gt; _getCurrentTime;

    public Translator() : this(new CurrentTime().GetCurrentTime) {}

    public Translator(Func&lt;DateTime&gt; getCurrentTime) {
        this._getCurrentTime = getCurrentTime;
    }

    public string Translate(string input) {
        return string.Format("{0}: {1}", _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;

    var sut = new Translator(() =&gt; now);

    var result = sut.Translate("test");

    Assert.AreEqual(now.ToString() + ": test", result);
}
</code></pre>

<p>The test code is quite simple! No longer do we need the dependency on third
party mocking libraries, or the relatively complicated setup logic. Instead we
can simply inject the lambda at runtime, replacing that pointer. We didn&rsquo;t need
the whole interface, really we just needed the simple signature of the function.</p>

<h2>Step 2: Define Dependencies Inline</h2>

<p>We can take it even a step further. Why use constructor injection at all? Since
all we really want is a single mutable dispatch table row, why not just make it
that way?</p>

<pre><code class="csharp">public class Translator {
    internal Func&lt;DateTime&gt; _getCurrentTime = new CurrentTime().GetCurrentTime;

    public string Translate(string input) {
        return string.Format("{0}: {1}", _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;
    var sut = new Translator();
    sut._getCurrentTime = () =&gt; now;

    var result = sut.Translate("test");

    Assert.AreEqual(now.ToString() + ": test", result);
}
</code></pre>

<p>We&rsquo;ve cleaned up our nasty multi-line indirection into a single dispatch line.
&ldquo;Go to definition&rdquo; now takes me to the actual line with the actual called
function. We&rsquo;ve replaced a dependency on a class based interface with a function
signature. The function signature <em>is</em> the interface!</p>

<p>You probably noticed we have lost something with this final version. We have
lost the ability to inject polymorphic behavior through the constructor. If you
need it, simply go back to injecting the interface in the constructor or by
passing it into the function itself. In practice, I have found this is needed
very rarely, making the SimpleMock pattern a better tool to reach for first.</p>

<h2>Step 3: Write Better Abstractions</h2>

<p>Lastly, SimpleMock actually promotes better designs. For example, a coworker was
writing some tests today and ran into a complicated situation. Take the
following sanitized code:</p>

<pre><code class="csharp">public class WorkDoer {
    internal Action&lt;Thing&gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Action&lt;Thing&gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public void IgnoreAndRemoveThings(Thing t1, Thing t2) {
        ignoreElements(t1);
        ignoreElements(t2);
        removeIgnoredElements(t1);
        removeIgnoredElements(t2);
    }
}
</code></pre>

<p>How would you check that each section was called? Our naive solution was a
complicated lambda with a &ldquo;timesCalled&rdquo; counter and an if statement to assert
against each argument, but it turns nasty quickly:</p>

<pre><code class="csharp">/// Nasty test code
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();

    var ignoredCalledTimes = 0;
    sut.ignoreElements = (t) =&gt; {
        ignoredCalledTimes++;
        if (ignoredCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };
    var removedCalledTimes = 0;
    sut.removeIgnoredElements = (t) =&gt; {
        removedCalledTimes++;
        if (removedCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };

    var t1 = new Thing();
    var t2 = new Thing();

    var result = sut.IgnoreAndRemoveThings(t1, t2);
    Assert.AreEqual(2, removedCalledTimes);
    Assert.AreEqual(2, ignoredCalledTimes);
}
</code></pre>

<p>Yuck! The test is an absolute catastrophe. I see a mess of mixed concerns.
Conditionals?! In a test?! Unconscionable.</p>

<p>In situations like this, we have two easy options. Option one is to just use
a third party mocking library, replacing the functions from inside the test
code. This gives us access to all the sophisticated mocking tools available.</p>

<p>My preferred option is seeking to decomplect the production code by using better
abstractions.</p>

<p>I have found that strong reliance of mocking libraries enables worse designs.
Consider the code, what makes it so hard to test? Not knowing which element is
called when, doing the same work on two parameters, and reference mutation all
make this a poor abstraction. Why not simplify?</p>

<pre><code class="csharp">public class WorkDoer {
    internal Func&lt;Thing, Thing&gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Func&lt;Thing, Thing&gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public List&lt;Thing&gt; IgnoreAndRemoveThings(List&lt;Thing&gt; ts) {
        return ts.Select(t =&gt; removeIgnoredElements(ignoreElements(t)));
    }
}

/// Simpler test
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();
    var expected = new Thing();
    var ts = new List&lt;Thing&gt;{new Thing()};

    sut.ignoreElements = (t) =&gt; new Thing();

    sut.removeIgnoredElements = (t) =&gt; {
        Assert.AreEqual(t, sut.ignoreElements(t));
        return expected;
    };

    var result = sut.IgnoreAndRemoveThings(ts);

    Assert.AreEqual(expected, result.First())
}
</code></pre>

<p>Much better! Yes, we had to change a few signatures. We get the same work done,
but now the code is actually a lot more useful. Our test code is comparable with
anything you&rsquo;d find using a mocking library. I am absolutely okay with using a
mocking library when needed, but I always carefully consider my abstractions and
design first.</p>

<p>If mocking libraries and IoC containers are the chainsaws of the testing world,
then SimpleMock is the garden shears. Sometimes the chainsaw is the only tool
for the job, and that is fine. But for most work around the yard, you can leave
the chainsaw in the shed.</p>

<h2>Conclusion</h2>

<p>I’ve shown how you can really simplify your code with SimpleMock. The dispatch
row is clear and easy to read. We have removed some third party mocking
dependencies. You can remove a lot of the boilerplate &ldquo;for making it more
testable&rdquo; from your code. The test code is greatly simplified, and injection a
breeze. The result: much simpler code, just as easy to test.</p>

<p>Thanks to Shuwei Chen for helping me put this together!</p>

<h2>The Non-SimpleMock Way</h2>

<p>If you are familiar with unit test mocking with interfaces, this part is
probably boring. Feel free to skip.</p>

<p>The traditional way of performing C# unit test mocking involves dependency
injection and interface mocking using a mocking library. For dependency
injection, it is common to use a tool like Ninject or hand-rolled constructor
injection. For mocking, a library like Moq or Rhino Mocks is standard. Here is
an example of a class and its testing code without any business logic.</p>

<pre><code class="csharp">public interface ICurrentTime {
    DateTime GetCurrentTime();
}

public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}

public class Translator {
    private readonly ICurrentTime ct;

    public Translator() : this(new CurrentTime()) {}

    public Translator(ICurrentTime currentTime) {
        this.ct = currentTime;
    }

    public string Translate(string input) {
        return string.Format("{0}: {1}", ct.GetCurrentTime().ToString(), input);
    }
}

/// Test Code with Moq
[TestCase]
public void TestCurrentTimeTranslator () {
    var rightNow = DateTime.Now;
    var mock = new Mock&lt;ICurrentTime&gt;();

    mock.Setup(a=&gt;a.GetCurrentTime()).Returns(rightNow);

    var sut = new Translator(mock.Object);

    var result = sut.Translate("test");

    Assert.AreEqual(rightNow.ToString() + ": test", result);
}
</code></pre>

<p>If you&rsquo;ve done much C# unit testing, this should look familiar. We want to
inject some code that is potentially long-running or dynamic. We put that code
into a class, add an interface, then inject that interface into the class we
want to test. To test it, we mock the interface, creating a different concrete
class at test runtime which implements that interface. We can setup that mock to
respond with anything, which we use for assertions.</p>

<h2>What&rsquo;s Wrong with the Non-SimpleMock Way?</h2>

<p>The first problem is we have created a whole interface just for testing.
Interfaces are for polymorphism, but we don&rsquo;t really need polymorphism for this
class. We simply want to mock it. The constructor injection is also test code
polluting our business logic.</p>

<p>What we have done is create a very small and primitive dispatch table. The
table has one row: something that has a function with the signature of <code>() -&gt; DateTime</code> or, as it is known in C#: <code>Func&lt;DateTime&gt;</code>.  We will need to make
this primitive dispatch table for every single mock in every single class we
wish to test. That&rsquo;s a lot of boilerplate!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Six Unusual Reasons Why Clojure Is a Delight]]></title>
    <link href="http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight/"/>
    <updated>2015-02-09T11:36:00-05:00</updated>
    <id>http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight</id>
    <content type="html"><![CDATA[<p>Clojure is a delightful language, and here are six uncommonly
discussed reasons why.</p>

<h2>1 - Dead Simple Unit Test Mocking</h2>

<p>Clojure is the easiest language to unit test I have ever
seen. &ldquo;Mocking&rdquo; a function in a test only requires a simple
replacement of the function definition. No extraneous interfaces, no
dependency injection, no mocking framework.  The built-in function <code>with-redefs</code>
will replace any function in any library or
namespace with a new definition.</p>

<pre><code class="clojure">(defn next-id [connection]
  (+ 1 (get-current-id connection)))

(testing "next-id"
  ;; bind get-current-id to a lambda that always returns 4 
  (with-redefs [get-current-id (fn [_] 4)]
    (is (= 5 (next-id nil)))))
</code></pre>

<p>We &ldquo;mock&rdquo; the <code>get-current-id</code> function to always return 4 inside
the scope of <code>with-redefs</code>. Couldn&rsquo;t be more simple! The binding
only is in scope for code inside and called by the s-expression of the
with-redefs, so no need to unbind it after the test.</p>

<h2>2 - Amazing Editing</h2>

<p>Many arguments have been made over those contentious
parentheses. While the most powerful use of s-expressions is to easily
allow macros, for the day to day, s-expressions have a very important
use: amazing editing!</p>

<p><img class="center <a" src="href="http://danmidwood.com/assets/animated-paredit/paredit-slurp-barf.gif">http://danmidwood.com/assets/animated-paredit/paredit-slurp-barf.gif</a>" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>With ParEdit (available in most editors), it is trivial to select,
move, replace, grow, or shrink any s-expression, string, map, or
list. <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html">This animated guide</a>
shows excellent examples of ParEdit that are too
complex to explain here.</p>

<p>Languages that don&rsquo;t have a surrounding delimiter for expressions
leave you jumping around with the mouse and arrow keys a whole lot more.
Because it is so much easier to write a parser to select <code>(add 1 2)</code>
than it is for <code>add(1, 2)</code>, the tooling can be so much better.</p>

<p>No local editing tool I have seen comes close to Vim with ParEdit for
effective editing.</p>

<h2>3 - Live Attached Repl</h2>

<p>Developing in Clojure against a running version of the program is a
huge bonus for development speed. While possible to get similar
behavior with an attached debugger in other languages, the fluidity of
an always-on live attached repl is incredible. At any point, it is
possible to run and rerun any given expression to see the
results. More than once, I have seen an exception caused by calling a
certain function. I trace that function to see the exact inputs that
cause the exception, and am able to quickly run every line of the
offending function to see the source.</p>

<p>If a debugger sheds light on a single line at a time when running an
application, a live attached repl sheds light on the entire
application.</p>

<h2>4 - No-fuss Polymorphism</h2>

<p>One of the best claims about &ldquo;traditional&rdquo; Java OO is
polymorphism. The ability to make an interface with concrete classes
gives the powerful ability to replace behavior dynamically. The
trouble is, Java&rsquo;s polymorphic dynamic dispatch is single dispatch - the
decision of which method to call is limited to a single thing: the
type of the callee. If this was the only type of dynamic dispatch you
ever knew of, it might be hard for you to consciously realize it was
ever a limitation, especially if you&rsquo;ve never seen examples of
multiple dispatch.</p>

<p>While most of the time, in any language with first class functions, it
is possible to achieve a similar effect by passing functions, it is
also possible to get a similar value with something called multimethods.</p>

<pre><code class="clojure">(defmulti speak :animal)
(defmethod speak :dog [this] (str "woof says " (:name this)))
(defmethod speak :cat [this] (str "mow says " (:name this)))

(speak {:animal :dog :id 1 :name "Spike"})
;; =&gt; "woof says Spike"
(speak {:animal :cat :id 2 :name "Mr Cat"})
;; =&gt; "mow says Mr Cat"
</code></pre>

<p>In this example, we use the <code>:animal</code> keyword to be the &ldquo;route&rdquo; function,
and the two methods fill in two of the possible concrete types. We are
not limited to just a keyword, we can dispatch on anything on the
passed map, for example, the oddness of the id:</p>

<pre><code class="clojure">(defmulti odds? (comp odd? :id))
(defmethod odds? true [d] "odd id")
(defmethod odds? false [c] "even id")

(odds? {:animal :dog :id 1 :name "Spike"})
;; =&gt; "odd id"
(odds? {:animal :cat :id 2 :name "Mr Cat"})
;; =&gt; "even id"
</code></pre>

<p>While both examples are a bit silly, they should demonstrate the power
of simple polymorphism. But you might think, what about inheritance?
Multimethods allow that too!</p>

<h2>5 - Simple Multiple Inheritance</h2>

<p>We don&rsquo;t build inheritance on a single type, but on a hierarchy of
keywords. Those can be dispatched on just like any other
keyword. First, an example hierarchy of keywords using the built-in
functions <code>derive</code> and <code>isa?</code>. These <code>::</code> keywords are
namespaced, which prevents collisions.</p>

<pre><code class="clojure">(derive ::cat ::mammal)
(derive ::dog ::mammal)
(derive ::dog ::hairy)
(derive ::poodle ::dog)

(isa? ::poodle ::dog)
;; =&gt; true
(isa? ::poodle ::mammal)
;; =&gt; true
(isa? ::poodle ::hairy)
;; =&gt; true
(isa? ::poodle ::cat)
;; =&gt; false
(isa? ::mammal ::hairy)
;; =&gt; false
</code></pre>

<p>A <code>::dog</code> is-a <code>::mammal</code> and is-a <code>::hairy</code>, the
classical diamond problem (without the common ancestor, which is
possible, but unneeded for the example).</p>

<pre><code class="clojure">(defmulti speak :animal)
(defmethod speak ::poodle [d] "chirps")
(defmethod speak ::mammal [c] "breathes")

(speak {:animal ::poodle :id 1 :name "Spike"})
;; =&gt; "chirps"
(speak {:animal ::dog :id 2 :name "Mr Dog"})
;; =&gt; "breathes"

(defmulti shave :animal)
(defmethod shave ::poodle [d] "shivers")
(defmethod shave ::hairy [c] "stuggles")
(defmethod shave ::mammal [c] "maybe cant be shaved!")
(prefer-method shave ::hairy ::mammal)

(shave {:animal ::poodle :id 1 :name "Spike"})
;; =&gt; "shivers"
(shave {:animal ::dog :id 2 :name "Rufs"})
;; =&gt; "stuggles"
</code></pre>

<p>We can see the <code>::dog</code> keyword doesn&rsquo;t have an explicit speak or shave
implementation, which is fine, because it will then use the &ldquo;preferred&rdquo;
parent implementation, which returns &ldquo;breathes&rdquo; for speak or
&ldquo;struggles&rdquo; for shave. Since we can have a keyword be the child of
multiple parents, we get a multiple inherited behavior, where the
preferred match is the one returned.</p>

<p>This is possible because the default equality check of multimethod is
the <code>isa?</code> function. Because of this, uses of multimethod
hierarchies can have inherited behavior for complex structures.</p>

<h2>6 - Mostly Monadic</h2>

<p>Languages like Haskell and F# have tools like the maybe monad that add
safety to operations. For example, using the maybe monad can
completely prevent null reference exceptions by making you ensure you
&ldquo;unpack&rdquo; the value every time.</p>

<p>How does Clojure address this? In a typical Clojure way, which gives
80% of the value for 20% of the effort, Clojure has a great
relationship with empty lists and nil. Rather than wrapping every
value that is nullable in a type, Clojure&rsquo;s default functions all
<em>mostly</em> deal with nil and empty without throwing exceptions. For
example:</p>

<pre><code class="clojure">(get {:id 5} :id)
;; =&gt; 5
(get nil :id)
;; =&gt; nil

(first [3 2 1])
;; =&gt; 3
(first nil)
;; =&gt; nil
(count nil)
;; =&gt; 0
</code></pre>

<p>This allows functions to be chained without fear that along the way a
nil will get returned.</p>

<p>Since most of the core functions are &ldquo;smart&rdquo; about nil, you gain much
of the value and safety of monads without most of the
hassle. Ultimately, a more rich type system would allow for custom
types which can be domain specific, but in day-to-day working,
primitive safety is still a huge win.</p>

<h2>Conclusion</h2>

<p>These are a few simple features that keep me coming back to Clojure,
even from languages like F# and Haskell. While Clojure is a bit more
wordy than the ML family, and not as type safe, the simplicity of
these features keep me coming back for more!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing is to programming what math is to engineering]]></title>
    <link href="http://deliberate-software.com/testing-is-to-programming-what-math-is-to-eng/"/>
    <updated>2011-09-26T00:00:00-04:00</updated>
    <id>http://deliberate-software.com/testing-is-to-programming-what-math-is-to-eng</id>
    <content type="html"><![CDATA[<p>
  In ancient times, plenty of builders did their work without math,
  and I would guess that a good portion of them likely did it faster
  then their math-doing counterparts.
</p>


<p >
  I am certain that when builders first started using math to prove
  that buildings would stand up safely, they were mocked by their
  math-less counterparts. I can hear them now, "Oh, Stephos, it takes
  you 5 times longer to prove your building will stand up, real men
  can just <em>see</em> that it will work". Even in modern times, many
  people build houses and small buildings that probably don't even
  need the math to really "prove" they work, but they perform the due
  diligence anyway. On the other hand, some people today still build
  houses, sheds, tree-houses, lofts, and fire pits without any
  drawings or math at at all, and why should they? They are
  responsible for the risk.
</p>


<p >
  This is all fine, but, builders who shy away from math also don't
  build airliners, space shuttles, and skyscrapers. An aircraft
  designer who doesn't feel like using math to prove their aircraft
  will fly is handed an "Experimental" sticker and gravely patted on
  the back.
</p>


<p >
  Today, programming is at the same place as both
  ancient <strong>and</strong> modern engineering: many projects can
  be done "by eye", and some of the most experienced programmers are
  able to build immense projects alone without any sort of automated
  testing at all. When you go to a forum and ask for help, you are
  just as likely to hear from a "space shuttle" programmer as you are
  to hear from a "tin shack" programmer. The "space shuttle"
  programmer would be horrified to hear of working without automated
  testing and rigorous review practices, whereas the "tin shack"
  programmer would be horrified to think of the time wasted to
  even <em>learn the procedures</em> to automatically prove his code
  works as it should. The "space shuttle" programmer might work on the
  same internal financial project for months or years, finally
  releasing with zero defects; the "tin shack" programmer might churn
  out several quick web sites a day. Neither project
  is <em>better</em> then the other, they both might be perfect for
  what their business needs.
</p>


<p>
  I have heard several times from very good lone wolf programmers that
  testing just slows them down, and in some ways, it does appear to be
  a slowdown for them. Unfortunately, the cost to build even
  medium-sized projects with several workers without automated testing
  is only felt when it is too late, when the deadlines (and costs) are
  spiraling out of control.
</p>


<p>
  The disciplined application of mathematics transformed and
  solidified the field of engineering into a field far more vast and
  capable of some of the most incredible constructions imaginable.
  Would we have smart-phones, GPS, modern cars, and airliners if
  engineering had just avoided mathematics? Just imagine what the
  field of programming could grow into if we continue to learn and
  grow our testing, designing, and writing of software.
</p>


<p>
  I propose that automated testing is to programming what math was
  to ancient engineering.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[End-to-End Web Service Testing]]></title>
    <link href="http://deliberate-software.com/end-to-end-web-service-testing/"/>
    <updated>2011-06-28T00:00:00-04:00</updated>
    <id>http://deliberate-software.com/end-to-end-web-service-testing</id>
    <content type="html"><![CDATA[<p>
  At work last month, I was assigned to fix some bugs in an
  asynchronous legacy code base. My supervisor gave me a month to see
  what I could do, and to see if I could fix a few tricky bugs. The
  code is divided into two sections, a client application and a web
  server. Both the client application and the server have their own
  persistence, and they communicate through a soap web service.
</p>


<p>
  I wanted to try and write some sort of end-to-end tests around this,
  but I could not figure out how to get around that web service. I
  don&#039;t want my tests to rely on a server having to always be up,
  so I initially was planning on writing tests from the client
  database to the web service, where I would just stub some responses.
  I got about an hour into that plan, before I realized I would then
  have to do that same thing on the server, and that sort of testing
  will not really tell me what the code <i>does</i>. I needed to cover
  this whole process end-to-end.
</p>


<p>
 I walked around for a bit, thinking. Then it hit me, both the server
 and client code are written in VB.NET, and, except for the web service, work
 just like plain old highly-coupled code. Hmmm.
</p>


<p>
 For the first pass, I wrote an interface to wrap the web service,
 then used dependency injection to inject a fake web service that (and
 here is the cool part) simply calls around the web service entirely
 to the server code directly and injects a different database
 connection string, so the server talks to a second database I have
 prepared.
</p>


<p>
 Just like that, I can run, all on my machine, 99 percent of the code
 in a single end-to-end test. I can even setup several client
 databases, and rotate them out, to &quot;swap&quot; between several
 clients in the middle of the tests.
</p>


<p>
 I added a few &quot;integration&quot; tests that do talk to a real
 published testing web service, just to make sure everything is still
 in place correctly.
</p>


<p>
  Now, I said this was asynchronous, and it is, the executed
  system-under-test kicks off a thread to talk to the web service, and
  so to get it to test, I needed to wait for the thread to finish,
  then do my assertions.
</p>


<p>
 I used a system where the spun off thread will set a boolean when it
 has finished running, to let the main thread know it has finished,
 and the main thread just keeps checking that boolean until it is
 true. While hackish, that is my current working solution, as no more
 then one thread is ever spun off at a time, I can just have my test
 wait for the thread to finish, then complete the required assertions.
</p>

]]></content>
  </entry>
  
</feed>
