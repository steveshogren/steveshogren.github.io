<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Meta Game | Deliberate Software]]></title>
  <link href="http://steveshogren.github.io/blog/categories/meta-game/atom.xml" rel="self"/>
  <link href="http://steveshogren.github.io/"/>
  <updated>2015-03-07T16:09:59-05:00</updated>
  <id>http://steveshogren.github.io/</id>
  <author>
    <name><![CDATA[Steve Shogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming Language Safety Algorithm]]></title>
    <link href="http://steveshogren.github.io/programming-language-safety-algorithm/"/>
    <updated>2015-02-17T14:13:00-05:00</updated>
    <id>http://steveshogren.github.io/programming-language-safety-algorithm</id>
    <content type="html"><![CDATA[<p>I think the time has come for a standard programming language safety
score. I want to use this model to help show that the concept of
safety is much more nuanced than a binary bit of &ldquo;has strong-static
types&rdquo;.</p>

<p>When someone says &ldquo;programming language safety&rdquo;, it typically invokes
thoughts of unit tests, long build times, and red squiggles in an
IDE. But, in day-to-day development, there are so many times when we
are bitten by things that somehow just slip through the cracks.</p>

<p>I put together this scoring model to get a sense of how safe a
language is at the primitive level, and if it isn&rsquo;t safe by default,
how much it costs to manually make it safe. Since all abstractions
eventually result in a series of primitive operations, I decided that
focusing only on primitives would still be a valuable (if incomplete)
data point. While any good library will handle all primitive checks
and present the consumer with a well-designed abstraction, in the end,
the consumer is still left wiring libraries together, building their
own primitive abstractions for integration. Due to the impossibility of
measuring the quality of abstractions in all libraries for a language,
I left that entirely out of scope of this model, unless it is designed
as a primitive check.</p>

<p>By focusing on only primitive operations: making and calling
functions, naming data, working with sequences, and dealing with
language primitive data types, I slimmed down the large range of
possible error vectors to a small handful. While in some languages it
is common to use user-defined classes to wrap around a set of
primitives, those classes are still doing the same primitive work,
just hidden behind a user-created abstraction. The more ways it is
possible to make a &ldquo;mistake&rdquo; with a primitive, the more difficult it
is to build such good abstractions.</p>

<pre><code>This model is not about language "power".
</code></pre>

<p>This model is not about ranking the &ldquo;power&rdquo;, &ldquo;expressiveness&rdquo;, or
&ldquo;abstract-ability&rdquo; of a language. In any language that supports
abstractions (functions, classes, modules, naming data), I am
convinced, given enough code, all Turing complete langauges can do the
same work. This model is only about the costs to prevent unexpected
&ldquo;confusion&rdquo; between the programmer and the machine at the primitive
level.</p>

<p>Rather than focus on what is <em>possible</em> with a language, I will
instead focus on what is typically idiomatic to that community. For
example, if it is possible to achieve a level of safety in a language
but by doing something uncommon, that should not be counted.</p>

<p>To score a language, simply figure out how many characters it costs to
&ldquo;prevent&rdquo; a certain type of error, and add that to the
total. Newlines, spaces, and tabs do not count, but all other
punctuation does. If a specific check is language enforced, like F#&rsquo;s
Option or C#&rsquo;s parameter type enforcement, that is given a -30 (by
default) to make up for the lack of unit tests and code exercising
needed to run that &ldquo;path&rdquo;. Do not count import lines for libraries, as
importing the module will have a negligible effect on the code size
and complexity.</p>

<p>If there is a safety feature that is not possible to achieve
programmatically, we will add +30 (by default) for a &ldquo;every change run
and debug to fix&rdquo; cost, such as Java not having a way to prevent stack
overflow exceptions caused by recursion.</p>

<pre><code>A lower score is "safer", needing less (or no) code to achieve the same level of safety.
</code></pre>

<p>Rather than tell you my thoughts (or survey for) hard-coded
weightings, all checks are weighted the same by default. Feel free to
apply your own weightings, to better match to your or your team&rsquo;s
specific needs and preferences. The languages are masked by default to
protect the innocent. You can unmask the names and see the code used
below the table.</p>

<p><div ng-app="TableApp">
<div ng-controller="TableCtrl"></p>

<p>Language Enforced Bonus:
 {{ enforcedScore }} 
<input ng-model="enforcedScore" type="range" min="0" max="50" /></p>

<p>Language Inability Penalty:
 {{ inabilityPenalty }} 
<input ng-model="inabilityPenalty" type="range" min="0" max="50" /></p>

<p>Show Weights <input type="checkbox" ng-model="showWeights" />
<p class="lead">
<div style="overflow-x:scroll">
<table class="langtable">
<tr>
<th>Safety Check</th>
<th></th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[0]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[1]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[2]"></select>
</th>
<th>
<select ng-options="getName(lang) for lang in allLanguages" ng-model="languages[3]"></select>
</th>
</tr>
<tr ng-repeat="check in langChecks" score-row name="check.name" language-fn="check.fn"></tr>
<tr class="totals"><td>Totals</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ lang }} 
</td>
</tr>
<tr class="totals"><td>Magnitude</td>
<td></td>
<td ng-repeat="lang in langTotals track by $index">
 {{ percentageTotals(lang) }}% 
</td>
</tr>
</table>
</div></p>

<p>I want to see your language represented here! I&rsquo;ll happily take pull
requests for new languages so long as they are in the same data
structure found here: <a href="https://github.com/steveshogren/blog-source/blob/22f907bb2d43b1edf7ca8807c32bb4542c887d93/source/javascripts/sliders.js#L97-L158">language data structure</a></p>

<p>I would love to see every major language represented, including major
language &ldquo;idiom communities&rdquo;. For example, Clojure and Typed Clojure
are vastly different in abilities. Similarly &ldquo;Scala &ndash; The Better Java&rdquo;
and &ldquo;Scala &ndash; The JVM Haskell&rdquo; have vastly different idioms with
apparently very separate communities.</p>

<p><h3><input ng-model="showRealName" type="checkbox" /><span
ng-click="showRealName = !!!showRealName">Click to see backing code and unmask names</span></h3></p>

<p><div ng-show="showRealName"> Feel free to put in your own examples by
playing with the samples below. Code surrounded with &lt;! !> is ignored
from the tally, since it would vary heavily based on the language and
desired result. Variable and type names are kept at single characters,
which are counted. Feel free to add in your own language below, and
use the copy feature to extract the data structure to use in a pull
request.</p>

<p><h2>Select Language:
<select ng-options="lang.name for lang in allLanguages" ng-model="selectedLang"></select>
</h2>
<button ng-click="copyToClipboard(selectedLang)">Copy Changes to Clipboard</button>
<h2><input ng-model="selectedLang.name"></input></h2>
<div ng-repeat="check in langChecks">
<h3> {{ check.name }} :  {{ score(check.fn(selectedLang)) }}  </h3>
<p>
<textarea class="widetextarea" rows="5" ng-model="check.fn(selectedLang).desc"></textarea>
<div>
Code: <select ng-options="enforcedNice(e) for e in enforcedTypes" ng-model="check.fn(selectedLang).enforced"></select>
<div class="tablecode">1234567890123456789012345678901234567890</div>
<div class="tablecode" >  {{ cleanCode(check.fn(selectedLang).rawCode) }}  </div>
<input type="text" style="width:90%;" ng-model="check.fn(selectedLang).rawCode" />
</div>
</p>
</div>
</div></p>

<p>Hope this is a helpful way to think about language safety!</p>

<p>Special thanks to (in alphabetical order):
Kyle Burton <a href="http://asymmetrical-view.com/">(blog)</a>,
Daniel Miladinov <a href="https://github.com/danielmiladinov">(github)</a>,
Chris Salch <a href="https://github.com/arlaneenalra">(github)</a>, and
Tim Visher <a href="https://github.com/timvisher">(github)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Skills Continuum]]></title>
    <link href="http://steveshogren.github.io/skill-continuum/"/>
    <updated>2014-12-02T07:26:00-05:00</updated>
    <id>http://steveshogren.github.io/skill-continuum</id>
    <content type="html"><![CDATA[<pre><code>    Learning Vim is a waste of time; I can prove it! - Anonymous
</code></pre>

<p>I recently had a gentle discussion with a new teammate about whether
or not they should learn to use Vim. My team uses a Vim emulator
inside Visual Studio and Emacs, and so we recommended he learn at
least the basics so to reduce friction when pair-programming (which we
do almost all the time).</p>

<p>He really had no desire to learn it, and took no small amount of
offense when we suggested it. The friction he felt trying to &ldquo;start
over&rdquo; really bothered him. He set out to prove that Vim was not worth
his time, and that it was actually us who needed to stop using it,
because we were the duped slow ones.</p>

<p>As any such localized experiments go, he never really came up with
anything conclusive either way. Personally, I suspect he spent more
time trying to figure out why Vim was worse than if he had just
buckled down and learned it. This got me thinking about skills we
learn as developers, and how much they cost.</p>

<h1>Skills</h1>

<p>Most skills fall along a continuum of tactical to strategic.</p>

<h3>Tactical Skills</h3>

<ul>
<li>Typing speed/accuracy</li>
<li>Keyboard shortcuts</li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs</li>
<li>Clean coding practices</li>
<li>Refactoring tools</li>
<li>Repl Driven Development / Test Driven Development</li>
<li>Debugging</li>
</ul>


<h3>Mid-way Skills</h3>

<ul>
<li>Unit testing</li>
<li>Building abstractions</li>
<li>Designing simple solutions</li>
<li>Automating tasks</li>
<li>Learning new languages and frameworks</li>
</ul>


<h3>Strategic Skills</h3>

<ul>
<li>Gathering requirements</li>
<li>Training developers</li>
<li>Organizing and leading teams</li>
<li>&ldquo;Understanding the real problem&rdquo;</li>
</ul>


<p>The more strategic the skills, the &ldquo;softer&rdquo; they become. The reason
for this is that soft skills often allow for the greatest leverage on
a project.</p>

<p>Why is this?</p>

<p>Consider the developer, who by more accurately gathering requirements
for a few extra days, realizes that the stakeholder can use a
preexisting solution instead of a six month planned project. If you
consider how many keystrokes he saved, there is no way he could have
possibly typed fast enough or refactored efficiently enough to make up
for that saved six months of effort. Unless he can typed out a six
month project in a few days, his time was better spent where it
was. Obviously, these opportunities do not happen all the time, but
they <em>do</em> happen.</p>

<p>Think about the return on investment for training developers. If you
have an average team (and yes, we all do), there is a good chance you
have some lower performing developers. I have witnessed many times
where a few months of pairing to brush up the skills of a less skilled
developer allowed them to become much more productive. In terms of
total company effort, that small investment paid back many times
before the end of the year as the newly trained developer was able to
tackle their work with the renewed vigor that comes from a greater
mastery of their work.</p>

<p>Similarly, the judicious use of automation for deployment, testing,
and building greatly reduces the friction of development for entire
teams. Lowered friction means less cognitive burden.</p>

<p>That being said, I think there comes a point where you have to put
fingers to keyboard and actually produce working software. Of course,
the fastest and best software is the software you never have to
write. But, when you absolutely must write or modify software, the
skill to actually execute becomes very important. Tactical skills
increase in significance the closer you get to the work.</p>

<p>While a great software tactician will never &ldquo;beat&rdquo; a great strategist
in terms of raw business value, a great strategist that is a terrible
tactician can only talk their way out of work. A strategist who
forgets or ignores good tactics is what we call an &ldquo;architecture
astronaut&rdquo; or an &ldquo;ivory tower architect&rdquo;. These disconnected
strategists eventually start to remove business value as their
solutions make less and less practical sense.</p>

<p>I think a developer who wants to improve should make sure they are
improving all across the spectrum. Don&rsquo;t focus only on strategic or
tactical skills, but seek projects and teams that will allow you to
gain skills across the board. I like to try to focus on one skill from
each side of the continuum each year. This year, it is emacs
automation and monads on the tactical side, and leading mature teams
on the strategic. By alternating readings, I find fuel to apply the
strategies using these new tactics!</p>

<p>Lastly, on the subject of &ldquo;what to study&rdquo;, I think it is possible to
study a number of subjects all across the continuum. Unless you have
weeks where you never type any code at all, you can practice and learn
new tactical techniques all the time. If it slows you down today, but
speeds you up next week, it might just be worth it. Even if it slowed
you down to a quarter your usual speed for two weeks, but then gives
you a measly 5% boost to productively after that, you&rsquo;ll earn that
time back by the end of the year, plus some. And 5% is not hard to
do. I&rsquo;d guess learning a few new navigation or refactoring shortcuts
would net you 5% easily.</p>

<p>When studying more strategic skills, the same holds, but they are
harder to learn. The best way I have found for learning strategic
skills is to read books about it, and try to work around others who
are good at it. Neither books or working with others will get you all
the way there, you also have to apply it yourself.</p>

<h1>Progression</h1>

<p>I usually recommend that the more experienced a person is, the more
mastery they should have in the tactical skills. A suggested path I&rsquo;ve
recommended for a new developer would look like this:</p>

<h3>0 &ndash; 6 Months:</h3>

<ul>
<li>Typing speed/accuracy</li>
<li>Keyboard shortcuts</li>
<li>Repl Driven Development / Test Driven Development</li>
<li>Unit testing</li>
<li>Clean coding practices</li>
<li>Designing simple solutions</li>
</ul>


<h3>0 &ndash; 2 Years:</h3>

<ul>
<li>Debugging</li>
<li>Refactoring tools</li>
<li>Building abstractions</li>
<li>Automating tasks</li>
<li>Learning new languages and frameworks</li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs</li>
</ul>


<h3>0 &ndash; 50+ Years:</h3>

<ul>
<li>Gathering requirements</li>
<li>Training developers</li>
<li>Organizing and leading teams</li>
<li>Understanding the real problem</li>
</ul>


<p>This is not a hard and fast list. If you are completely unsure of what
to learn, I recommend this rough progression just to get you
started. If you are a two year developer, and you cannot touch type, I
think learning it can really help, alongside the other 0 &ndash; 2 year
skills.</p>

<p>Not all skills along the list build on a mastery of the ones below
it. A developer can absolutely get to a very senior mastery of the
strategic skills only knowing one language and using notepad.exe. I
believe that they are missing out on a deep richness that comes from
better knowing their field, and I suggest they spend some time learning new
languages and tools. The more tactical the skill, usually, the easier
it is to learn, so it won&rsquo;t take very much time to come up to
speed.</p>

<p>The hardest thing I think a more senior developer has to deal with is
humbling themselves to learn a perceived &ldquo;entry-level&rdquo; skill. I have
another post brewing about this very topic, so I&rsquo;ll not get too much
into it here. But if you have gotten to a place where you feel like
you are so senior that some skills are too &ldquo;entry-level&rdquo; for you to
learn, I think you need to humble yourself and learn them. Nothing can
be gained from pretending like they are not valuable. Additionally,
the assumption that your time is now so valuable that it is &ldquo;a waste&rdquo;
to spend it on learning tactical skills is absurd.</p>

<p>Claiming you are too good to waste on low level skills not only
belittles everyone around you, but belies a deep misunderstanding of
our field. The senior developer who takes five times as long to enter
and edit code isn&rsquo;t just spending longer to do that task, but they are
paying a missed opportunity cost in time they could have spent in more
strategic endeavors. They could have been training, planning,
gathering requirements, building better automation, etc, instead they
stubbornly claim &ldquo;typing isn&rsquo;t what software is about&rdquo;. By giving it
so little credence, they have made it most of their actual mental
effort! Take simple touch-typing. Imagine how much mental effort it
takes the hunt-and-peck typist to write out a single line of
code. That is mental overhead that is simply wasted. The developer who
doesn&rsquo;t have to think about how to move a file or edit a structure
finds themselves quickly through the tactical efforts with little
distraction, free to think deeply.</p>

<h1>Resources</h1>

<p>Here are some links and books to get you started on these topics.</p>

<ul>
<li>Typing speed/accuracy &ndash; <a href="http://store.steampowered.com/agecheck/app/246580/">Typing of the Dead</a></li>
<li>&ldquo;Mouse-free&rdquo; editing systems: Vim, Emacs &ndash; <a href="http://vim-adventures.com/">Vim Adventures</a></li>
<li>Clean coding practices &ndash; <a href="https://cleancoders.com/">Clean Coders</a></li>
<li>Repl Driven Development &ndash; <a href="http://blog.jayfields.com/2014/01/repl-driven-development.html">RDD</a></li>
<li>Test Driven Development &ndash; <a href="http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530">http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530</a></li>
<li>Debugging &ndash; <a href="http://c.learncodethehardway.org/book/ex31.html">Debugging</a></li>
<li>Building abstractions / Designing Simple Solutions &ndash; <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and Interpretation of Computer Programs</a></li>
<li>Training developers &ndash; <a href="http://en.wikipedia.org/wiki/Pair_programming">Pair Programming</a></li>
<li>Organizing and leading teams &ndash; <a href="http://managinghumans.com/">Managing Humans</a></li>
<li>Understanding the real problem &ndash; <a href="http://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow">Thinking Fast and Slow</a></li>
<li>Learning new languages and frameworks &ndash; <a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></li>
<li>Automating tasks <a href="http://www.stuartellis.eu/articles/rake/">Rake to Automate Tasks</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Book Should I Read Next?]]></title>
    <link href="http://steveshogren.github.io/next-book/"/>
    <updated>2014-07-26T11:46:00-04:00</updated>
    <id>http://steveshogren.github.io/next-book</id>
    <content type="html"><![CDATA[<p>&ldquo;It&rsquo;s my first job, what book should I read first?&rdquo;</p>

<p>Recently, a few developers I am mentoring were curious about what book
to read first. Even mid and senior level developers I&rsquo;ve known
sometimes struggle with this question.</p>

<p>If you want to be truly great, you have to read technical books and
white papers, and you have to learn new programming languages. You
could figure the content out yourself from first principles, but you
will be about 50 years behind those who just read the
books. Additionally, if you stick to a certain language, you are
limiting yourself to only thinking about a problem in a way common to
the language.</p>

<p>Just like with adding new features to a project, you should prioritize
your learning.</p>

<p>I&rsquo;d start by getting into the mindset that you will need roughly a
decade and at least ten thousand high quality hours to become a master
programmer. To be able to get that many high-value hours, you will
need to carefully select your jobs, and constantly be learning new
things that actually make you a better developer.</p>

<h2>Languages</h2>

<pre><code>    "A language that doesn't affect the way you think about programming,
    is not worth knowing." - Alan Perlis
</code></pre>

<p>I agree with <a
href="http://michaelochurch.wordpress.com/2012/07/27/six-languages-to-master/">other developers</a> who assert that a language is <a
href="http://en.wikiquote.org/wiki/Alan_Perlis">not worth learning</a>
unless it teaches you something new and mind-expanding. There are exceptions of course. Maybe you want to switch stacks to get an awesome high-value job. By all means, learn the new stack.</p>

<p>If you want to follow the extremely good <a
href="http://pragprog.com/the-pragmatic-programmer">advice of others</a> and learn one new programming language a year, make each
one count. For example, if you are a Ruby guy, it is safe to say you
will learn nothing of really any mind-expanding value if you try to
learn PHP, Python, JavaScript, or Perl.</p>

<p>Same for the family of Java, C++, C#, or VB.NET. One of those is plenty.</p>

<p>Instead shoot for languages that will really beef up your thought
process. I like the advice given by <a href="http://norvig.com/21-days.html">Peter Norvig</a>:</p>

<pre><code>     "Learn at least a half dozen programming languages. Include one
     language that supports class abstractions (like Java or C++), one that
     supports functional abstraction (like Lisp or ML), one that supports
     syntactic abstraction (like Lisp), one that supports declarative
     specifications (like Prolog or C++ templates), one that supports
     coroutines (like Icon or Scheme), and one that supports parallelism
     (like Sisal)."
</code></pre>

<p>I would add to that my own personal list: a language that forces you
to use monands for controlling side-effects (Haskell), and a language
that allows for dependent types (Idris).</p>

<p>If you are saying, &ldquo;wow, in Python, you have to put a colon at the end
of the function signature line, unlike in Ruby, that blows my mind&rdquo;,
or &ldquo;wow, in Java, the String keyword is uppercase instead of
lowercase!&rdquo; chances are you are getting a very low return for your
investment of time.</p>

<p>What is important about a new language is <em>not</em> a new syntax. A new
syntax is just cruft that gets in the way of the new concepts. A new
concept might be closures. If you have always worked in Java, a
closure will really expand your mind. Or macros. If you have never
seen macros, the concept alone is completely foreign, not just the
syntax. That is where the value is. A good test if you are learning
something new is if you have to research what the concept even means,
without even needing to see the syntax first. For example, when I
started learning monads, I didn&rsquo;t even need to see the syntax for how
Haskell does them, I didn&rsquo;t even understand the concept <em>at all</em>, so I
could read pretty much anything about the concept and get value out of
it. That is the high value content.</p>

<h2>Frameworks</h2>

<p>I would say very few frameworks are going to expand your mind in a way
that is worth the effort to learn them. Some very select frameworks
can cause you to think of a problem in a novel way and thus expand
your mind (off the top of my head: React.js, Core.Async, Akka,
Datomic) but those are very few and far between.</p>

<p>Obviously, in production use, frameworks have their place, and they
can provide an immense boost to your day-to-day productivity and
safety, but very few overall will expand your mind in such a way that
would make you better at the craft. It is not hard to reason why. A
framework can only do what is possible in the language. If the
language is only so powerful, the framework cannot be more powerful
than that. You will be using tools that you could&rsquo;ve written yourself
with your current skill level, but you won&rsquo;t even get the benefit of
writing it yourself. Hopefully, those tools will be safer and save you
a lot of time, but saved time cranking out widgets at work will not
directly cause you to better understand programming.</p>

<h2>Paradigms</h2>

<p>It is fashionable these days to get into functional programming. If
you haven&rsquo;t learned a language that supports a functional paradigm, I
highly recommend that as a good place to start. That being the case,
don&rsquo;t forget to add a logic, a literate, and a declarative programming
language to your list too (you have ten years remember, you&rsquo;ll need a
list). Why not pile on a stack based language too?</p>

<h2>Libraries</h2>

<p>While it is important to be aware of the libraries in your space, I
would say these often provide the least mind-expanding
opportunities. A library, much like a framework, is usually
constrained by the power of the language. In most languages, libraries
are just convenience abstractions at or below the same abstraction
layer as the rest of your code. I would never consider doing my
day-to-day work without the full power of available libraries, but
they are not going to help me think any better about the work.</p>

<h2>&ldquo;Meta&rdquo; books</h2>

<p>A vast number of books exist that attempt to impart something of a
&ldquo;mindset&rdquo; for the developer. Usually, the author is retelling his
experiences, which can be entertaining, but of limited reuse. The best
meta books are those that use actual research and data to try to
explain our industry. Books like Peopleware, Code Complete, and
Pragmatic Programmer are great in this regard. These best books can
cause you to see the creation of software artifacts with a totally
different light: e.g. I remember first reading about using a
programming language to generate automatically the source files for a
given project. At the time for me, it was revolutionary.</p>

<h2>Pattern Books</h2>

<p>I lately have come to think &ldquo;pattern books&rdquo; like Domain Driven Design,
Design Patterns, Patterns of Enterprise Architecture, Refactoring, etc
are just a way to try to replicate missing features in a language of a
lower power. These seem to be written for entirely Java and C#, and are mostly
complex solutions to complex problems created by the lack of power of the language. Apparently, I
am not alone: <a
href="http://www.c2.com/cgi/wiki?AreDesignPatternsMissingLanguageFeatures">Are Design Patterns Missing Language Features?</a></p>

<p>That being said, I think some parts of these books are helpful,
specifically, the ubiquitous language ideas from Domain Driven
Design. If your team has decided on always using the terms from a
certain book, and you are the only person who does not know them, I do
recommend at least skimming it just to ensure smooth communication.</p>

<h2>Suggestions</h2>

<p>I won&rsquo;t suggest too many books or languages, but those I do are very
highly recommended.</p>

<ul>
<li><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and Interpretation of Computer Programs</a>

<ul>
<li>The best book I&rsquo;ve ever read. No other book I&rsquo;ve read even comes close to beating this for sheer value per minute as this book. Do all the exercies, and you&rsquo;ll be way ahead of the curve.</li>
</ul>
</li>
<li>Code Complete</li>
<li>Clean Code</li>
<li>Pragmatic Programmer</li>
<li>Productive Programming</li>
<li>Peopleware</li>
</ul>


<h2>Wrap up</h2>

<p>It takes courage to step outside your comfort zone and learn something
new. You might be the only person learning something new on your
team. That is ok! Don&rsquo;t worry about &ldquo;converting&rdquo; everyone else to the
path of learning, and do not make fun of them or the only language
they know. (Developers who only know one language take any comment
good or bad about &ldquo;their&rdquo; language as a comment about themselves.) If
you do make fun of them, you will start to resent them. It&rsquo;ll make you
look like an outsider, and they will ignore you and finally push you
out of the team.</p>

<p>When you learn a new thing, be very careful to not run around trying
to use it everywhere. I am very careful to not use any new tool in
production until I&rsquo;ve &ldquo;moved on&rdquo; to learning another tool, so I could
critically consider the best tool for the job without the &ldquo;honeymoon&rdquo;
effect clouding my judgment.</p>

<p>My experience has been: keep getting better, and you will find
yourself in better and better places to work. A person who puts in the
effort to really master the craft is easy to spot and hard to
fake. Most people want to work with those who think like them, and you
cannot think like a master engineer only knowing one tool, so get
started now, and have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn to Database]]></title>
    <link href="http://steveshogren.github.io/Learn-To-Database/"/>
    <updated>2014-04-16T00:00:00-04:00</updated>
    <id>http://steveshogren.github.io/Learn-To-Database</id>
    <content type="html"><![CDATA[<p>
  "... and it has to return 45,000 records a minute, or we are all
  screwed."
</p>


<p> <p> Monday morning, we inherited a legacy codebase. Tuesday, the
  word came down on stone tablets. Forty-five thousand records a
  minute, and no amount of political maneuvering or incremental gains
  were going to do. Too many broken promises. The last team mass quit
  over three months, leaving us the two most junior
  developers. Someone high up promised big, and the buck stopped with
  us.
</p> <p> &ldquo;Does anyone even know the throughput now?&rdquo;
</p> <p> We still don&rsquo;t even have the dumb thing running on our
  machines. Two weeks later we have it running and enough data to test
  it. 2500 records a minute. When scaled to 45000 records it is still
  going 30 minutes later, so it doesn&rsquo;t even scale linearly. We are
  screwed.
</p> <p> Most of us are front-end developers who stepped forward when
  everyone else stepped back. Databases are a distant memory,
  something we maybe did a few jobs back. You &ldquo;join&rdquo; tables, right?
  What we know of this process is it selects from 2-3 dozen databases
  using an ORM while running through an engine that does some
  supposedly massive calculations on the data, returning a message with
  several hundred fields. It can&rsquo;t be that hard to speed up.
</p> <p> &ldquo;We need a new architecture, with read-optimized databases
  and queue-based messaging.&rdquo;
</p> <p> None of us have ever built such a system, but we have read
  about it, and like the faithful we nod solemnly in agreement. Why
  not? If the database is read-optimized, surely it will perform like
  we need. But a few desist.
</p> <p> Like paratroopers dropped into unknown territory without a
  map, we start to canvas the code, looking for landmarks. We split
  into two teams, one to try to speed up the current system, the other
  to start on the new architecture. Two teams trying two different
  approaches doubles our chances, right? Whiteboards around our desks
  fill with maps, glossaries, and diagrams. My team starts to dissect
  this mostly home-made ORM.
</p> <p> &ldquo;Why is this selecting from the same table twice?&rdquo;
</p> <p> The ORM generated query selects a list of id&rsquo;s from table A,
  then puts those id&rsquo;s into a list as a filter for the same table:
</p> <p>
  SELECT * FROM A WHERE ID IN (SELECT ID FROM A WHERE &hellip;)
</p> <p> We scratch our heads a bit, but hey, that can&rsquo;t hurt
  anything, surely the database figures that sort of stuff out? Isn&rsquo;t
  that what&hellip; indexes do? Our most database-savvy developer can&rsquo;t
  stop coming back to that query. He says it doesn&rsquo;t smell
  right. Finally, he takes out the &ldquo;WHERE IN&rdquo; filter, shims in the
  query, and runs the process.
</p> <p>
  &ldquo;Guys, the whole thing, all 45k came back in 40 seconds.&rdquo;
</p> <p> We scoff at him, good joke! Our profiling showed time chewed
  up fairly evenly at every level throughout the entire
  process, not just the initial query. So the process came back,
  just empty, right? And who knows what Ancient Ones you disturbed by
  messing around with what the ORM generates, it will probably never
  work again. We run it again, 40 seconds, correct count of
  records. Odd, freak coincidence. We run it with the old filter still
  in place, it comes back 30+ minutes later, same exact data. Whoa,
  wait, what?
</p> <p> Turns out, this ORM uses SELECT-WHERE-IN for every entity
  join. That first SELECT FROM A WHERE ID IN (SELECT ID FROM A WHERE
  &hellip;) was used as the base criteria for every single lazy look-up of
  every entity on A, which were legion. What looked like slowness
  across the entire process was really ORM lazy loading at every
  level, with that first SELECT-WHERE-IN as the final filter in a line
  of nested SELECTS, some four levels deep. That initial bad query
  gets run countless times, and when it is slow, the whole system is
  slow.
</p> <p> This is the story of how I learned an important lesson: if
  you are going to database, LEARN TO DATABASE.
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Challenge - Code Every Day]]></title>
    <link href="http://steveshogren.github.io/streaks/"/>
    <updated>2014-01-28T00:00:00-05:00</updated>
    <id>http://steveshogren.github.io/streaks</id>
    <content type="html"><![CDATA[<p>
  You know what will make you a phenomenally better developer?
  Deliberate practice. How do you get such practice? By doing it every
  single day. Random bursts of effort over the odd weekend will gain
  you practically nothing comparatively, even if the time investment
  is the same. Your mind needs repetition and consistent effort to
  improve. So what do you want to get better at?  Pick your highest
  value subject: vim, regex, functional programming, meta-programming,
  OO, TDD, async co-routines, threading, graphics, web, etc, etc, and
  practice it every single day. Easy as that.
</p>


<p>
  When GitHub first came out with the "streak" feature on the front
  page, I realized it was time to stop my binge coding on the
  occasional weekend and start a system. Inspired by other recent
  system-based successes (working out every day), I decided to code
  every day for a year.
</p>


<p>
  I quickly realized that anything requiring detailed plans and
  designs is harder to do. Working though a book, on the other hand,
  is easy to start and stop. I started working through a book I had
  tried to read before: Let Over Lambda.
</p>


<p>
  Let Over Lambda is intense, filled with deeply complex concepts
  written in Common Lisp, a language with which I was only passingly
  familiar. But I managed to get through it without hardly any
  difficulty. How did I do that?
</p>


<p>
  I got a cheap netbook, and started to code on the train ride home.
  Interestingly, without any internet, I was much less distracted, and
  could just sit down and be in the zone within the minute (this from
  the guy whom it takes 20+ minutes to get in the zone at work). With
  only a limited span of ~25 minutes, I had no time to waste, and
  without people to talk to my brain just falls into it. I can only
  pinpoint a few times I could not get into the zone, and those were
  extreme circumstances of exhaustion or illness.
</p>


<p>
  In ten months, I have:
  <ul>
    <li>
      worked through Let Over Lambda once and read it twice
    </li>
    <li>
      worked twice through the PLAI programming languages book
      (once in Scheme and once in F#)
    </li>
    <li>
      read Clojure Programming, F# 3.0 Programming, and am currently
      in Real World Haskell
    </li>
    <li>
      completed the exercises up to chapter three of SICP
    </li>
    <li>
      authored a small Clojure library for run time type checking
      (don't use mine, use Prismatic's)
    </li>
    <li>
      prepared and given a two hour talk about macros at a local meet-up
    </li>
  </ul>
  Pretty incredible for only ~25 minutes a day! That is more
  programming books than I had read in the previous 2 years. I have
  improved mightily in such a short time, and it does not feel
  stressful in the least. Now, when I get home, if I feel like
  watching movies, cooking, or playing board games/Dark Souls all
  night, no problem! I can relax knowing I have accomplished my goals
  for the day. All in all, the last ten months have been incredible:
  some of the most rewarding, relaxing, and fulfilling months of my
  life.
</p>


<p>
  Before you scoff and point out that not everyone can take the train
  to work, consider this: get a portable computer, load up your
  environment, tools, and some pdfs. The next morning, leave for work
  ~25 minutes early. You will probably get in way sooner due to the
  decreased traffic (now you have earned back that time). Sit quietly
  in your car, and without the distractions of internet or other
  people, knock out a little programming. Maybe start with SICP (the
  best programming book I have ever read). See how much you can read
  and do before work starts. Do that for a month, every day. I
  guarantee you will learn something amazing.
</p>



]]></content>
  </entry>
  
</feed>
