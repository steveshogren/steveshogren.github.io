<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Emacs on Deliberate Software</title>
    <link>http://deliberate-software.com/categories/emacs/</link>
    <description>Recent content in Emacs on Deliberate Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 May 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://deliberate-software.com/categories/emacs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Editor Abstractions</title>
      <link>http://deliberate-software.com/editor-abstractions/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/editor-abstractions/</guid>
      <description>&lt;p&gt;I was recently inspired by a comment from a respected coworker:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;I am just as productive with basic Vim commands as I am with a refactoring
suite like ReSharper.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I have pair-programmed with him for hundreds of hours of C# development. He is
equally productive with both, that much I know. On some tasks he is less
efficient than with ReSharper, on others he is more. To clarify, we use the
superb VsVim inside Visual Studio, so he still relies on the built-in tools for
&amp;ldquo;Auto-complete&amp;rdquo; and &amp;ldquo;Go to Definition&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The greatest benefit comes when we work in JavaScript, Haskell, or Clojure. His
productivity doesn&amp;rsquo;t drop! &lt;strong&gt;His Vim and grep skills work just as effectively on
any text.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The tools in our editors and IDE&amp;rsquo;s are concrete abstractions. If you have a good
set of abstractions, you can use them to solve any problem. A well-designed
abstraction composes well, and can be combined with others for new utility.&lt;/p&gt;

&lt;p&gt;Consider the sequence abstractions. With only: &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and
&lt;code&gt;fold&lt;/code&gt;, you can transform any sequence of data into another shape. Mastering
the three sequence abstractions empowers you to transform any data. The power comes
from how easily they can be combined.&lt;/p&gt;

&lt;p&gt;Editor abstractions are most powerful when they can be composed. You can
replicate most of the functionality of a refactoring suite using basic,
composable text-editing commands. Well-designed editor abstractions can be
recorded, edited, and replayed to transform text in any way you need. While no
replacement for semantic tools like &amp;ldquo;Language Errors&amp;rdquo;, &amp;ldquo;Go to Definition&amp;rdquo;, and
&amp;ldquo;Auto-complete&amp;rdquo;, they are an easy replacement for most other refactorings.&lt;/p&gt;

&lt;p&gt;If you work in multiple languages, composable text-editing commands are a much
better abstraction than those provided by a refactoring suite. Refactoring
suites often have dozens of bespoke commands that only work in certain contexts.
Even the best of these suites are often constrained to a single language. &lt;strong&gt;If
you ever work in more than one language, you will get the most value learning to
rely on abstractions that are constant across all environments.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I find I get the most value with a Vim plugin inside whatever environment
provides the best semantic tools for the language. When building an Android app,
I use IDEAVim inside Android Studio. For C#: VsVim inside Visual Studio. For all
other languages: Evil mode inside Emacs. Instead of hundreds of specialized
commands and contexts, I rely on a few basic abstractions to achieve any text
transformation I can imagine.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs Project Tip</title>
      <link>http://deliberate-software.com/emacs-project-tip/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/emacs-project-tip/</guid>
      <description>&lt;p&gt;I recently have been working in a Clojure project which is made up of
several microservices. While trying to build in a secure method for
each service to be able to call the others, I&amp;rsquo;ve been in several
different projects at the same time.&lt;/p&gt;

&lt;p&gt;At least once I accidentally opened the wrong &amp;ldquo;handler.clj&amp;rdquo; buffer,
and spent a few minutes adding a function that never worked. Since I
hate doing things like this, I wanted a simple way to see what project
I was currently viewing.&lt;/p&gt;

&lt;p&gt;I started with a changing the title of the frame to show the whole
path of the current buffer, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/title.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The code to change the title is simple, and the default in some of the
pre-packaged emacs bundles:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(setq frame-title-format
      &#39;((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 &amp;quot;%b&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is fine, but still not great. The font is tiny and the important
part: &amp;ldquo;octopress&amp;rdquo; is buried. I wanted something a little more fluid,
so I could easily tell the different projects apart instantly. I came
up with the idea to color the background faintly different based on
the path of the file. Files with a path containing &amp;ldquo;octopress&amp;rdquo; might
be different from those containing &amp;ldquo;.emacs&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Thankfully, &lt;code&gt;buffer-face-mode&lt;/code&gt; makes it easy to change a single
property of a single buffer&amp;rsquo;s face without changing any other
buffer. So long as you disable buffer-face-mode when closing emacs,
your files will open with the correct coloring scheme, then have the
new background overlaid.&lt;/p&gt;

&lt;p&gt;While not perfect, this was the result.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/colors.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The colors I choose are only faintly different, but just enough for me
to tell instantly which is which.&lt;/p&gt;

&lt;p&gt;The buffer colors are applied when opening a file, using these
functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defun my-buffer-face-mode-variable (color)
  (interactive)
  (setq buffer-face-mode-face (list :background color))
  (buffer-face-mode 1))

(defun my-set-theme-on-mode ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (cond
    ;; add your own project/color mappings here
     ((string-match &amp;quot;halcyon&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;#00001A&amp;quot;))
     ((string-match &amp;quot;dwarf&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;#001A1A&amp;quot;))
     ((string-match &amp;quot;nimbus&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;black&amp;quot;))
     (t &amp;quot;&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To force them to run when opening a file, since I use helm, I set it
to execute on exiting helm for any reason:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(add-hook &#39;helm-after-action-hook &#39;my-set-theme-on-mode)
;; uncomment if not using helm
;; (add-hook &#39;find-file-hook &#39;my-set-theme-on-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, to make sure emacs applies my normal theme and settings to a
buffer when starting, I disable buffer-face-mode on all buffers before
exiting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defun disable-all-buffer-face-mode ()
  (interactive)
  (let ((current (get-buffer (current-buffer))))
    (-map (lambda (x) (progn (switch-to-buffer x)
                             (buffer-face-mode 0))) (buffer-list))
    (switch-to-buffer current 1)))

(add-hook &#39;kill-emacs-hook &#39;disable-all-buffer-face-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block needs &lt;a href=&#34;https://github.com/magnars/dash.el&#34;&gt;dash.el&lt;/a&gt; to get
the -map function.&lt;/p&gt;

&lt;p&gt;While not the only solution, this seemed a simple and elegant way to
quickly be reminded of your current project.&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs/VIm The Endless Debate</title>
      <link>http://deliberate-software.com/the-endless-debate/</link>
      <pubDate>Fri, 22 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/the-endless-debate/</guid>
      <description>&lt;p&gt;&lt;br /&gt;The last three and a half years for me have been terrible. Why? Well, three and half years ago, I discovered the endless debate, Emacs vs. Vim. Being an efficiency nut, I could not fathom the horror of learning one, and by that action, not learning the other. What if the one I learned was not the &#34;best&#34; one? I could see that both were excellent and worth learning, but I wanted to learn both concurrently. Unfortunately, my body has a hard time learning two completely different keyboard systems at the same time. Heck, three and a half years ago, I was still learning to touch-type. &lt;p /&gt; So, three years pass, and I am now no farther along. &lt;p /&gt;Additionally, I read on an almost weekly basis, articles that explain how great Emacs and vim are, you just need to learn one, and learn it well. I wanted to stick with Emacs, for the built-in lisp, and &lt;a href=&#34;http://blog.vivekhaldar.com/post/3996068979/the-levels-of-emacs-proficiency&#34;&gt;several&lt;/a&gt; of my &lt;a href=&#34;http://sites.google.com/site/steveyegge2/effective-emacs&#34;&gt;favorite&lt;/a&gt; programmers highly advocate it. But, I wanted to pick up vim, because it is obviously the far superior text editor, and the default on Linux, and probably will help me not get Emacs &lt;a href=&#34;http://xahlee.blogspot.com/2010/06/famous-emacs-people-with-hand-injuries.html&#34;&gt;RSI&lt;/a&gt; but, perversely, it is not nearly as easy to extend as Emacs. &lt;p /&gt; So, the debate raged in my head for three years, and I stupidly got better at neither. Then, the other day, it clicked. Vim is the greatest text editor of them all, with text objects, highly combine-able commands, and modal editing. Emacs is the greatest IDE of all, with an awesome programming language built-in and thousands of classes and libraries to build on. Vim is built in the tradition of a small, sharp UNIX tool; Emacs in the tradition of HAVING thousands of small sharp tools. &lt;p /&gt; Finally, in a rush, it clicked into place with earth-shattering force: I can make Vim inside Emacs, with lisp, but I really could not remake Emacs inside Vim. &lt;p /&gt;Suddenly, in one glorious moment, the world all made sense. Vim, the greatest text editor, should be a part of Emacs, the greatest IDE! My searching had been in vain, there was no way to compare them, they are totally different tools!&lt;p /&gt; In my typical child-like innocence, I rolled up my sleeves, opened up an instance of Emacs, and started making Vim. A few hours later, Google pointed out the obvious: Emacs already has a vi mode built-in (viper). Better yet, with a simple file in the right place, I had &lt;a href=&#34;http://www.emacswiki.org/emacs-es/Vimpulse&#34;&gt;vimpulse &lt;/a&gt;(the practically complete Vim mode) installed and ready to go. Suddenly, a huge weight lifted off my chest. I am free to use the best tool for the job, and, like Huck Finn, float off down the river, leaving silly feuds behind me. If my actions here seem unnatural, an abomination, an unholy union, I encourage you, leave behind the fan-boyism, pick up your tools, and come build something with men who see their tools for what they truly are: &lt;span style=&#34;text-decoration:underline;&#34;&gt;not a good hill to die on&lt;/span&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>