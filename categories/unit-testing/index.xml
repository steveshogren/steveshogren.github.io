<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unit Testing on Deliberate Software</title>
    <link>http://deliberate-software.com/categories/unit-testing/</link>
    <description>Recent content in Unit Testing on Deliberate Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://deliberate-software.com/categories/unit-testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Promiscuous Pairing</title>
      <link>http://deliberate-software.com/pairprogramming/</link>
      <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/pairprogramming/</guid>
      <description>

&lt;p&gt;Let me start with a disclaimer: solutions are only valuable if they solve a
problem. Please don&amp;rsquo;t use this post to browbeat your colleagues. Programming
productivity hasn&amp;rsquo;t yet been scientifically measured. Therefore &lt;strong&gt;every&lt;/strong&gt;
process, language, or paradigm is recommended on personal preference or &amp;ldquo;gut
feeling&amp;rdquo;. I will lay out my preferences and &amp;ldquo;gut feelings&amp;rdquo;, but do not mistake
them for rigorous claims of productivity.&lt;/p&gt;

&lt;p&gt;My current team has pair-programmed and followed strict TDD on a single codebase
for over ten years. The practices started from reading the literature on Extreme
Programming, which resonated with both the developers and leadership. As the
team changed, we continued to follow the practices.&lt;/p&gt;

&lt;p&gt;In the last five years, the developers choose to implement Arlo Belshee&amp;rsquo;s &lt;a href=&#34;http://csis.pace.edu/~grossman/dcs/XR4-PromiscuousPairing.pdf&#34;&gt;&amp;ldquo;Promiscuous Pairing&amp;rdquo;&lt;/a&gt;. We
switch pairs in short intervals: 180 minutes is our current preference.&lt;/p&gt;

&lt;p&gt;The pairing sessions start at 8:45AM and 1:00PM with the typical five-minute
stand-up. People report on any data that the rest of the team needs to hear,
including noteworthy technical details. Afterwards, the developers crowd around
a board with the current tasks in progress. We randomize the pairs, then each
pair decides what to work on from the current tasks.&lt;/p&gt;

&lt;p&gt;If a developer wants to not pair for a session, they go &amp;ldquo;odd&amp;rdquo;. We have a working
agreement that no production code can be written while odd. The odd person works
on automated testing, answering questions, researching technical debt,
investigating root causes of bugs, and authoring throwaway &amp;ldquo;spikes&amp;rdquo; for major
refactorings.&lt;/p&gt;

&lt;h2 id=&#34;pros:bd97cfb3b628f77ac97d1d5cdf96fc97&#34;&gt;Pros&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;No siloed information or &amp;ldquo;I don&amp;rsquo;t touch that section&amp;rdquo; areas&lt;/li&gt;
&lt;li&gt;The team ends up adopting a consistent set of styles, tools, shortcuts, workflow&lt;/li&gt;
&lt;li&gt;Developers can take vacation whenever they please&lt;/li&gt;
&lt;li&gt;Training is built in to the process from day one&lt;/li&gt;
&lt;li&gt;Developers quitting doesn&amp;rsquo;t throw the team into disarray&lt;/li&gt;
&lt;li&gt;Productivity is fairly stable across years&lt;/li&gt;
&lt;li&gt;Protected time every day for research, refactoring, and tech debt&lt;/li&gt;
&lt;li&gt;Frequent rotation gives a natural cadence for fixing broken CI builds&lt;/li&gt;
&lt;li&gt;Many of us spend a lot less time puttering around on Reddit, HN, etc&lt;/li&gt;
&lt;li&gt;Interruptions are much less disruptive, typically only one or two minutes to
get back into &amp;ldquo;flow&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cons:bd97cfb3b628f77ac97d1d5cdf96fc97&#34;&gt;Cons&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Huge system &amp;ldquo;owned by everyone&amp;rdquo; is a lot for new developers to handle - training takes a long time&lt;/li&gt;
&lt;li&gt;Juggling tasks can be complex (e.g. what gets put on hold when not at full capacity)&lt;/li&gt;
&lt;li&gt;Support issues get passed around from pair to pair&lt;/li&gt;
&lt;li&gt;Some developers feel pairing is demeaning, disrespectful, or beneath them&lt;/li&gt;
&lt;li&gt;General feeling you are &amp;ldquo;not important&amp;rdquo; to the team&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;partly-good-partly-bad:bd97cfb3b628f77ac97d1d5cdf96fc97&#34;&gt;Partly Good, Partly Bad&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pairing is polarizing

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-&lt;/strong&gt; Hiring is slow: many developers hate pairing&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-&lt;/strong&gt; Poor new hire retention

&lt;ul&gt;
&lt;li&gt;Some love the &lt;em&gt;idea&lt;/em&gt; of pairing, not the &lt;em&gt;practice&lt;/em&gt; of pairing; they discover that and leave&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; Low employee churn: those that love pairing stick around far longer than industry average&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No task ownership

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-&lt;/strong&gt; Less emotional reward when completing a task&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; Less in-fighting about typical &amp;lsquo;code-ownership&amp;rsquo; bike-shed issues&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; No one cares if a task is rejected by QA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rapid pair-switching can cause design churn on a task

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-&lt;/strong&gt; Tasks can take longer to complete&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+&lt;/strong&gt; Tough tasks get prototyped several times and seen by whole team&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ve found this set of trade-offs works very well with our team. The team is
ten developers all doing active development on a 3.4 million line enterprise
application. Our team has a wide set of skills and skill ranges.&lt;/p&gt;

&lt;h2 id=&#34;how-to-get-started:bd97cfb3b628f77ac97d1d5cdf96fc97&#34;&gt;How To Get Started&lt;/h2&gt;

&lt;p&gt;This system works best with a given a set of preconditions.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The whole team has to love pairing and want to adopt it&lt;/p&gt;

&lt;p&gt;If even a minority of developers hates pairing, it will be tortuous to force
them to do it. In our experience, &amp;gt;80% of developer hate pairing. It would
be better to split the team and codebase. Forcing even a single developer to
pair can be disastrous for morale and productivity. No one wants to pair
with someone who is sullen and bitter. When pairing, misery cannot be
hidden.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Management has to accept not having assigned tasks&lt;/p&gt;

&lt;p&gt;Assigning tasks reduces the beneficial effects of pair switching. Typically
the assigned developer ends up &amp;ldquo;doing all the work with an observer&amp;rdquo;. This
is much less effective. The &amp;ldquo;observer&amp;rdquo; ends up tuning out, since the
assignee &amp;ldquo;probably has it figured out&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Proficiency at pairing is a discrete skill&lt;/p&gt;

&lt;p&gt;Many seasoned developers find themselves awkward and uncomfortable when
pairing for the first few months. Pairing cannot be assessed in any
meaningful way by just &amp;ldquo;trying it for a week&amp;rdquo; anymore than typing can be
assessed over hand-writing in just a week. Feelings of discomfort and
awkwardness in the first few months are completely normal and should not be
the criteria used to decide to continue the practice.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Let any pair make any decision&lt;/p&gt;

&lt;p&gt;Any pair should be authorized to make any decision to implement their
current task. They must however be ready to have that decision undone or
changed if the next pair finds it was too large, a poor design, out of
scope, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Accept that others are better than you&lt;/p&gt;

&lt;p&gt;When trying out pairing, productivity doesn&amp;rsquo;t have to drop! Many developers
at first are uncomfortable by the rapid speed. The law of averages says half
the developers on the team will find their pair going much faster than they
are used to! These feelings of inadequacy often lead to developers wanting
to discontinue the practice. Over time, everyone realizes that it is okay to
not be the fastest, and instead take self-worth in what skills they do
bring. Maybe they are not the fastest, but they are good at catching little
details, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a development system, this absolutely cannot be handed down from management.
It has to be implemented &amp;ldquo;by the people and for the people&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:bd97cfb3b628f77ac97d1d5cdf96fc97&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have seen promiscuous pairing completely change our organization. As a team,
we accomplish far more than we would otherwise. We are able to tackle new
systems, languages, and tools with ease. When someone learns a new valuable
technique, it spreads organically through the team.&lt;/p&gt;

&lt;p&gt;Feel free to tweet at me if you have any questions or clarifications!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modern Dependency Injection</title>
      <link>http://deliberate-software.com/modern-di/</link>
      <pubDate>Sat, 11 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/modern-di/</guid>
      <description>

&lt;p&gt;Dependency Injection can be greatly simplified while retaining all of its power.&lt;/p&gt;

&lt;h3 id=&#34;the-unnecessary-boilerplate:c289f8e530077f15501b76fa92fff59a&#34;&gt;The Unnecessary Boilerplate&lt;/h3&gt;

&lt;p&gt;Injection of an interface through the constructor is a common way to replace a
dependency for unit-test mocking. Unfortunately, it is an extremely verbose
pattern.&lt;/p&gt;

&lt;p&gt;Look how much boilerplate is needed just to mock out a call to
&lt;code&gt;DateTime.Now&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 1 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 2 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 3 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 4 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 5 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 6 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 7 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 8 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 9 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;10 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;11 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;12 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;readonly&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;13 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;14 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;15 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;16 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;17 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;18 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;19 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;20 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;21 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;22 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;23 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We learned to mock this way because Java did not have lambdas at the time the
pattern was invented! Now that both Java and C# have lambdas, the existing DI
pattern can be improved.&lt;/p&gt;

&lt;h3 id=&#34;for-unit-test-mocking:c289f8e530077f15501b76fa92fff59a&#34;&gt;For Unit Test Mocking&lt;/h3&gt;

&lt;p&gt;Thanks to the power of lambdas, the previously highlighted lines (1-19) can be
removed!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;1 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;2 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;3 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;4 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;5 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;6 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;7 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Much better! The code is easier to read, understand, and &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;mock in a unit test&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;for-polymorphism:c289f8e530077f15501b76fa92fff59a&#34;&gt;For Polymorphism&lt;/h3&gt;

&lt;p&gt;If you still need to replace the function with another for polymorphic dispatch,
use constructor injection of just the lambda. Be forewarned, you probably need
this much less than you think!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 1 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 2 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 3 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 4 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 5 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 6 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 7 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 8 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 9 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;10 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;11 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;12 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;13 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;If you are heavily invested in unit-testing, you might find you need very little
actual interface polymorphism. To see where you really use interface
polymorphism, find the interfaces in your codebase only have a single concrete
class in production. Each interface with a single concrete class is test-only
boilerplate that can safely replaced with a lambda!&lt;/p&gt;

&lt;p&gt;For more examples, &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;check out SimpleMock!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>F# Unit Testing With SimpleMock</title>
      <link>http://deliberate-software.com/f-number-unit-testing/</link>
      <pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/f-number-unit-testing/</guid>
      <description>

&lt;p&gt;If you are considering using F#, you might be curious how to handle unit test
mocking, especially if you want to use both modules and classes. In a language
like C# or Java, the common method is to a DI container or handmade constructor
injection on a class. These &amp;ldquo;entry points&amp;rdquo; allow for a unit test to replace a
real dependency with a test-only replacement.&lt;/p&gt;

&lt;p&gt;I previously posted an example that shows a much simpler way to inject
dependencies called the &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;SimpleMock pattern&lt;/a&gt;. The SimpleMock pattern can also be
used in F#, even if you are only using modules.&lt;/p&gt;

&lt;h2 id=&#34;simplemock-in-f-modules:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;SimpleMock in F# Modules&lt;/h2&gt;

&lt;p&gt;We will assume you are mocking inside a module and not a class. Mocking inside
an F# class would look much the same as it does in C#, which we showed in the
SimpleMock post. Here is a sample program that does some work and persists the
results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To apply the SimpleMock pattern, we can use argument currying by adding a simple
function wrapper.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let addAndSave&#39; saveSum x y = 
  let sum = x + y
  saveSum sum
  sum
let addAndSave = addAndSave&#39; DBModule.saveSum

// Test code
let addAndSave_Test =
  let calledVar = ref 0
  let result = addAndSave&#39; (fun sum -&amp;gt; calledVar := sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, !calledVar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We started by renaming the &lt;code&gt;addAndSave&lt;/code&gt; function with a trailing &lt;code&gt;&#39;&lt;/code&gt;. We
created a new &lt;code&gt;addAndSave&lt;/code&gt; that calls &lt;code&gt;addAndSave&#39;&lt;/code&gt; with the correct
dependency for the first argument, leaving the rest of the arguments to be
called later. Currying is what allows this ability. The new &lt;code&gt;addAndSave&lt;/code&gt;
function only needs the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; parameters. At test time, we called &lt;code&gt;addAndSave&#39;&lt;/code&gt;, passing in the needed dependency, but using a lambda as the
&amp;ldquo;fake&amp;rdquo;. The injection is as close to the dependency use as possible!&lt;/p&gt;

&lt;h2 id=&#34;bonus-simplemock-fake-helper:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;Bonus: SimpleMock Fake Helper&lt;/h2&gt;

&lt;p&gt;The earlier replacement for DBModule.saveSum is a bit complex, and it does not
show us how many times the fake was called. We can easily make a helper that
takes parameters and returns them when called, along withe count of times it was
called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TestFakeResults() =
  member val timesCalled = 0 with get,set
  member val args: obj list = [] with get,set

let makeFake_OneArg () =
  let results = new TestFakeResults()
  let fake = (fun p1 -&amp;gt;
                  results.args &amp;lt;- p1 :: results.args
                  results.timesCalled &amp;lt;- results.timesCalled + 1
                  ())
  (fake, results)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code might be hard to comprehend at first! We have made a generic
helper that can create any single argument fake we need. We return a tuple,
containing the fake lambda and an instance of &lt;code&gt;TestFakeResults&lt;/code&gt;. The fake
lambda will populate the &lt;code&gt;TestFakeResults&lt;/code&gt;, which we can access in the test
via the second arg of the tuple.&lt;/p&gt;

&lt;p&gt;We can now re-write the previous test using &lt;code&gt;makeFake_OneArg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Test code
let addAndSave_Test =
  let (fakeSave, fakeSaveCalling) = makeFake_OneArg()
  let result = addAndSave&#39; fakeSave 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaveCalling.args.[0])
  Assert.AreEqual(1, fakeSaveCalling.timesCalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TestFakeResults can return information about the way it was called,
including the list of all arguments. If we felt we needed the extra
expressiveness, we could also use a mocking library like RhinoMocks or Moq. The
TestFakeResults and its constructor are not essential to the pattern. The most
important part is learning to unit test in F# with confidence.&lt;/p&gt;

&lt;h1 id=&#34;double-bonus-when-to-use-a-class-instead-of-a-record:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;Double Bonus: When to Use a Class Instead of a Record&lt;/h1&gt;

&lt;p&gt;When I first wrote this post, I used a record instead of a class for the &lt;code&gt;TestFakeResults&lt;/code&gt; type. If you have been bitten by the functional programming bug,
you might have wondered at my usage of a mutable class. Here are two alternates
of &lt;code&gt;makeFake_OneArg&lt;/code&gt; which use records. You can probably see why I switched to a class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TestFakeResults = {timesCalled:int, args obj list}

// Using Record Alternate 1
let makeFake_OneArg_RecordAlternate1 () = 
  let t = ref 0
  let a : obj list ref = ref []
  let fake = (fun p1 -&amp;gt;
                  a := p1 :: !a
                  t := !t + 1
                  ())
  (fake, (fun () -&amp;gt;
                {TestFakeRecord.timesCalled = !t;
                 args = !a}))

// Using Record Alternate 2
let makeFake_OneArg_RecordAlternate2 () = 
  let result = ref {TestFakeRecord.timesCalled = 0; args = []}
  let fake = (fun p1 -&amp;gt;
              result := {timesCalled = (!result).timesCalled + 1;
                         args = p1 :: (!result).args}
              ())
  (fake, (fun () -&amp;gt; !result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only way to use a record is to delay its construction via a lambda which
must be executed by the test code. Both are complex: what we need is a mutable
data structure which we can access via a reference. A record is not that. We can
approximate it using tricks, but ultimately I find both alternatives to be too
complex to justify their use. Sometimes a mutable data structure is the best
choice to solve your problem efficiently. The power of F# is that it gives us
the ability to choose the best tool for the job: records for immutability,
classes for mutability.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SimpleMock: Language Agnostic Unit Test Mocking</title>
      <link>http://deliberate-software.com/simplemock-unit-test-mocking/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/simplemock-unit-test-mocking/</guid>
      <description>

&lt;p&gt;SimpleMock is a pattern for reducing TDD damage. You can use the pattern to
organize your testing code without mocking or complicated dependency injection.&lt;/p&gt;

&lt;p&gt;SimpleMock works in any language with closures that can be passed around by
reference, so off the top of my head: C#, Java, F#, Scala, PHP, C++, Ruby, and
Python. I&amp;rsquo;m sure you can think of others.&lt;/p&gt;

&lt;h2 id=&#34;example:442bb35a3947650665613cec7b90f820&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;Here is a brief (if a bit silly) example of the final pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class LineCounter {
    internal Func&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; _readLines = File.ReadLines;

    public string CountLines(string filename) {
        return _readLines(filename).Count();
    }
}

/// Test Code
[TestCase]
public void TestLineCounter () {
    var sut = new LineCounter();
    // &amp;quot;SimpleMock&amp;quot; of File.ReadLines
    sut._readLines = (string x) =&amp;gt; new List&amp;lt;string&amp;gt;{&amp;quot;test&amp;quot;, &amp;quot;that&amp;quot;};

    var result = sut.CountLines(&amp;quot;test&amp;quot;);

    Assert.AreEqual(2, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;benefits:442bb35a3947650665613cec7b90f820&#34;&gt;Benefits&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Reduced boilerplate&lt;/li&gt;
&lt;li&gt;Saves interfaces for real polymorphism&lt;/li&gt;
&lt;li&gt;Simplifies test code&lt;/li&gt;
&lt;li&gt;Reduces testing concerns in production code&lt;/li&gt;
&lt;li&gt;Removes need for fragile IoC containers&lt;/li&gt;
&lt;li&gt;Encourages better abstraction design&lt;/li&gt;
&lt;li&gt;Can convert one class at a time!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The SimpleMock pattern promotes a better design of your abstractions and simpler
tests. The pattern also reduces boilerplate and the pollution of your production
code with testing concerns.&lt;/p&gt;

&lt;p&gt;If you aren&amp;rsquo;t familiar with the normal pattern of unit test mocking using
interfaces, dependency injection, and mock libraries, scroll down to &amp;ldquo;The
Non-SimpleMock Way&amp;rdquo; at the end of the post.&lt;/p&gt;

&lt;h2 id=&#34;simplemock-pattern:442bb35a3947650665613cec7b90f820&#34;&gt;SimpleMock Pattern&lt;/h2&gt;

&lt;p&gt;The SimpleMock pattern is aptly named.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Replace Test-Only Interfaces With Functions&lt;/li&gt;
&lt;li&gt;Define Dependencies Inline&lt;/li&gt;
&lt;li&gt;Write Better Abstractions&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;step-one-replace-test-only-interfaces-with-functions:442bb35a3947650665613cec7b90f820&#34;&gt;Step One: Replace Test-Only Interfaces With Functions&lt;/h2&gt;

&lt;p&gt;My examples are in C# because that is what I got paid to write today - it is
freshest in memory. C# has an incredible ability to create and pass around
lambdas and function references. Here is an example of using functions instead
of interfaces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}
public class Translator {
    private Func&amp;lt;DateTime&amp;gt; _getCurrentTime;

    public Translator() : this(new CurrentTime().GetCurrentTime) {}

    public Translator(Func&amp;lt;DateTime&amp;gt; getCurrentTime) {
        this._getCurrentTime = getCurrentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;

    var sut = new Translator(() =&amp;gt; now);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The test code is quite simple! No longer do we need the dependency on third
party mocking libraries, or the relatively complicated setup logic. Instead we
can simply inject the lambda at runtime, replacing that pointer. We didn&amp;rsquo;t need
the whole interface, really we just needed the simple signature of the function.&lt;/p&gt;

&lt;h2 id=&#34;step-2-define-dependencies-inline:442bb35a3947650665613cec7b90f820&#34;&gt;Step 2: Define Dependencies Inline&lt;/h2&gt;

&lt;p&gt;We can take it even a step further. Why use constructor injection at all? Since
all we really want is a single mutable dispatch table row, why not just make it
that way?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Translator {
    internal Func&amp;lt;DateTime&amp;gt; _getCurrentTime = new CurrentTime().GetCurrentTime;

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;
    var sut = new Translator();
    sut._getCurrentTime = () =&amp;gt; now;

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve cleaned up our nasty multi-line indirection into a single dispatch line.
&amp;ldquo;Go to definition&amp;rdquo; now takes me to the actual line with the actual called
function. We&amp;rsquo;ve replaced a dependency on a class based interface with a function
signature. The function signature &lt;em&gt;is&lt;/em&gt; the interface!&lt;/p&gt;

&lt;p&gt;You probably noticed we have lost something with this final version. We have
lost the ability to inject polymorphic behavior through the constructor. If you
need it, simply go back to injecting the interface in the constructor or by
passing it into the function itself. In practice, I have found this is needed
very rarely, making the SimpleMock pattern a better tool to reach for first.&lt;/p&gt;

&lt;h2 id=&#34;step-3-write-better-abstractions:442bb35a3947650665613cec7b90f820&#34;&gt;Step 3: Write Better Abstractions&lt;/h2&gt;

&lt;p&gt;Lastly, SimpleMock actually promotes better designs. For example, a coworker was
writing some tests today and ran into a complicated situation. Take the
following sanitized code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Action&amp;lt;Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Action&amp;lt;Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public void IgnoreAndRemoveThings(Thing t1, Thing t2) {
        ignoreElements(t1);
        ignoreElements(t2);
        removeIgnoredElements(t1);
        removeIgnoredElements(t2);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would you check that each section was called? Our naive solution was a
complicated lambda with a &amp;ldquo;timesCalled&amp;rdquo; counter and an if statement to assert
against each argument, but it turns nasty quickly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;/// Nasty test code
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();

    var ignoredCalledTimes = 0;
    sut.ignoreElements = (t) =&amp;gt; {
        ignoredCalledTimes++;
        if (ignoredCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };
    var removedCalledTimes = 0;
    sut.removeIgnoredElements = (t) =&amp;gt; {
        removedCalledTimes++;
        if (removedCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };

    var t1 = new Thing();
    var t2 = new Thing();

    var result = sut.IgnoreAndRemoveThings(t1, t2);
    Assert.AreEqual(2, removedCalledTimes);
    Assert.AreEqual(2, ignoredCalledTimes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yuck! The test is an absolute catastrophe. I see a mess of mixed concerns.
Conditionals?! In a test?! Unconscionable.&lt;/p&gt;

&lt;p&gt;In situations like this, we have two easy options. Option one is to just use
a third party mocking library, replacing the functions from inside the test
code. This gives us access to all the sophisticated mocking tools available.&lt;/p&gt;

&lt;p&gt;My preferred option is seeking to decomplect the production code by using better
abstractions.&lt;/p&gt;

&lt;p&gt;I have found that strong reliance of mocking libraries enables worse designs.
Consider the code, what makes it so hard to test? Not knowing which element is
called when, doing the same work on two parameters, and reference mutation all
make this a poor abstraction. Why not simplify?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Func&amp;lt;Thing, Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Func&amp;lt;Thing, Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public List&amp;lt;Thing&amp;gt; IgnoreAndRemoveThings(List&amp;lt;Thing&amp;gt; ts) {
        return ts.Select(t =&amp;gt; removeIgnoredElements(ignoreElements(t)));
    }
}

/// Simpler test
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();
    var expected = new Thing();
    var ts = new List&amp;lt;Thing&amp;gt;{new Thing()};

    sut.ignoreElements = (t) =&amp;gt; new Thing();

    sut.removeIgnoredElements = (t) =&amp;gt; {
        Assert.AreEqual(t, sut.ignoreElements(t));
        return expected;
    };

    var result = sut.IgnoreAndRemoveThings(ts);

    Assert.AreEqual(expected, result.First())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much better! Yes, we had to change a few signatures. We get the same work done,
but now the code is actually a lot more useful. Our test code is comparable with
anything you&amp;rsquo;d find using a mocking library. I am absolutely okay with using a
mocking library when needed, but I always carefully consider my abstractions and
design first.&lt;/p&gt;

&lt;p&gt;If mocking libraries and IoC containers are the chainsaws of the testing world,
then SimpleMock is the garden shears. Sometimes the chainsaw is the only tool
for the job, and that is fine. But for most work around the yard, you can leave
the chainsaw in the shed.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:442bb35a3947650665613cec7b90f820&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Iâ€™ve shown how you can really simplify your code with SimpleMock. The dispatch
row is clear and easy to read. We have removed some third party mocking
dependencies. You can remove a lot of the boilerplate &amp;ldquo;for making it more
testable&amp;rdquo; from your code. The test code is greatly simplified, and injection a
breeze. The result: much simpler code, just as easy to test.&lt;/p&gt;

&lt;p&gt;Thanks to Shuwei Chen for helping me put this together!&lt;/p&gt;

&lt;h2 id=&#34;the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;The Non-SimpleMock Way&lt;/h2&gt;

&lt;p&gt;If you are familiar with unit test mocking with interfaces, this part is
probably boring. Feel free to skip.&lt;/p&gt;

&lt;p&gt;The traditional way of performing C# unit test mocking involves dependency
injection and interface mocking using a mocking library. For dependency
injection, it is common to use a tool like Ninject or hand-rolled constructor
injection. For mocking, a library like Moq or Rhino Mocks is standard. Here is
an example of a class and its testing code without any business logic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ICurrentTime {
    DateTime GetCurrentTime();
}

public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}

public class Translator {
    private readonly ICurrentTime ct;

    public Translator() : this(new CurrentTime()) {}

    public Translator(ICurrentTime currentTime) {
        this.ct = currentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, ct.GetCurrentTime().ToString(), input);
    }
}

/// Test Code with Moq
[TestCase]
public void TestCurrentTimeTranslator () {
    var rightNow = DateTime.Now;
    var mock = new Mock&amp;lt;ICurrentTime&amp;gt;();

    mock.Setup(a=&amp;gt;a.GetCurrentTime()).Returns(rightNow);

    var sut = new Translator(mock.Object);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(rightNow.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve done much C# unit testing, this should look familiar. We want to
inject some code that is potentially long-running or dynamic. We put that code
into a class, add an interface, then inject that interface into the class we
want to test. To test it, we mock the interface, creating a different concrete
class at test runtime which implements that interface. We can setup that mock to
respond with anything, which we use for assertions.&lt;/p&gt;

&lt;h2 id=&#34;what-s-wrong-with-the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;What&amp;rsquo;s Wrong with the Non-SimpleMock Way?&lt;/h2&gt;

&lt;p&gt;The first problem is we have created a whole interface just for testing.
Interfaces are for polymorphism, but we don&amp;rsquo;t really need polymorphism for this
class. We simply want to mock it. The constructor injection is also test code
polluting our business logic.&lt;/p&gt;

&lt;p&gt;What we have done is create a very small and primitive dispatch table. The
table has one row: something that has a function with the signature of &lt;code&gt;() -&amp;gt; DateTime&lt;/code&gt; or, as it is known in C#: &lt;code&gt;Func&amp;lt;DateTime&amp;gt;&lt;/code&gt;.  We will need to make
this primitive dispatch table for every single mock in every single class we
wish to test. That&amp;rsquo;s a lot of boilerplate!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Six Unusual Reasons why Clojure is a Delight</title>
      <link>http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight/</link>
      <pubDate>Mon, 09 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight/</guid>
      <description>

&lt;p&gt;Clojure is a delightful language, and here are six uncommonly
discussed reasons why.&lt;/p&gt;

&lt;h2 id=&#34;1-dead-simple-unit-test-mocking:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;1 - Dead Simple Unit Test Mocking&lt;/h2&gt;

&lt;p&gt;Clojure is the easiest language to unit test I have ever
seen. &amp;ldquo;Mocking&amp;rdquo; a function in a test only requires a simple
replacement of the function definition. No extraneous interfaces, no
dependency injection, no mocking framework.  The built-in function &lt;code&gt;with-redefs&lt;/code&gt;
will replace any function in any library or
namespace with a new definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn next-id [connection]
  (+ 1 (get-current-id connection)))

(testing &amp;quot;next-id&amp;quot;
  ;; bind get-current-id to a lambda that always returns 4 
  (with-redefs [get-current-id (fn [_] 4)]
    (is (= 5 (next-id nil)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &amp;ldquo;mock&amp;rdquo; the &lt;code&gt;get-current-id&lt;/code&gt; function to always return 4 inside
the scope of &lt;code&gt;with-redefs&lt;/code&gt;. Couldn&amp;rsquo;t be more simple! The binding
only is in scope for code inside and called by the s-expression of the
with-redefs, so no need to unbind it after the test.&lt;/p&gt;

&lt;h2 id=&#34;2-amazing-editing:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;2 - Amazing Editing&lt;/h2&gt;

&lt;p&gt;Many arguments have been made over those contentious
parentheses. While the most powerful use of s-expressions is to easily
allow macros, for the day to day, s-expressions have a very important
use: amazing editing!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://danmidwood.com/assets/animated-paredit/paredit-slurp-barf.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;With ParEdit (available in most editors), it is trivial to select,
move, replace, grow, or shrink any s-expression, string, map, or
list. &lt;a href=&#34;http://danmidwood.com/content/2014/11/21/animated-paredit.html&#34;&gt;This animated guide&lt;/a&gt;
shows excellent examples of ParEdit that are too
complex to explain here.&lt;/p&gt;

&lt;p&gt;Languages that don&amp;rsquo;t have a surrounding delimiter for expressions
leave you jumping around with the mouse and arrow keys a whole lot more.
Because it is so much easier to write a parser to select &lt;code&gt;(add 1 2)&lt;/code&gt;
than it is for &lt;code&gt;add(1, 2)&lt;/code&gt;, the tooling can be so much better.&lt;/p&gt;

&lt;p&gt;No local editing tool I have seen comes close to Vim with ParEdit for
effective editing.&lt;/p&gt;

&lt;h2 id=&#34;3-live-attached-repl:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;3 - Live Attached Repl&lt;/h2&gt;

&lt;p&gt;Developing in Clojure against a running version of the program is a
huge bonus for development speed. While possible to get similar
behavior with an attached debugger in other languages, the fluidity of
an always-on live attached repl is incredible. At any point, it is
possible to run and rerun any given expression to see the
results. More than once, I have seen an exception caused by calling a
certain function. I trace that function to see the exact inputs that
cause the exception, and am able to quickly run every line of the
offending function to see the source.&lt;/p&gt;

&lt;p&gt;If a debugger sheds light on a single line at a time when running an
application, a live attached repl sheds light on the entire
application.&lt;/p&gt;

&lt;h2 id=&#34;4-no-fuss-polymorphism:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;4 - No-fuss Polymorphism&lt;/h2&gt;

&lt;p&gt;One of the best claims about &amp;ldquo;traditional&amp;rdquo; Java OO is
polymorphism. The ability to make an interface with concrete classes
gives the powerful ability to replace behavior dynamically. The
trouble is, Java&amp;rsquo;s polymorphic dynamic dispatch is single dispatch - the
decision of which method to call is limited to a single thing: the
type of the callee. If this was the only type of dynamic dispatch you
ever knew of, it might be hard for you to consciously realize it was
ever a limitation, especially if you&amp;rsquo;ve never seen examples of
multiple dispatch.&lt;/p&gt;

&lt;p&gt;While most of the time, in any language with first class functions, it
is possible to achieve a similar effect by passing functions, it is
also possible to get a similar value with something called multimethods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti speak :animal)
(defmethod speak :dog [this] (str &amp;quot;woof says &amp;quot; (:name this)))
(defmethod speak :cat [this] (str &amp;quot;mow says &amp;quot; (:name this)))

(speak {:animal :dog :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;woof says Spike&amp;quot;
(speak {:animal :cat :id 2 :name &amp;quot;Mr Cat&amp;quot;})
;; =&amp;gt; &amp;quot;mow says Mr Cat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we use the &lt;code&gt;:animal&lt;/code&gt; keyword to be the &amp;ldquo;route&amp;rdquo; function,
and the two methods fill in two of the possible concrete types. We are
not limited to just a keyword, we can dispatch on anything on the
passed map, for example, the oddness of the id:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti odds? (comp odd? :id))
(defmethod odds? true [d] &amp;quot;odd id&amp;quot;)
(defmethod odds? false [c] &amp;quot;even id&amp;quot;)

(odds? {:animal :dog :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;odd id&amp;quot;
(odds? {:animal :cat :id 2 :name &amp;quot;Mr Cat&amp;quot;})
;; =&amp;gt; &amp;quot;even id&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While both examples are a bit silly, they should demonstrate the power
of simple polymorphism. But you might think, what about inheritance?
Multimethods allow that too!&lt;/p&gt;

&lt;h2 id=&#34;5-simple-multiple-inheritance:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;5 - Simple Multiple Inheritance&lt;/h2&gt;

&lt;p&gt;We don&amp;rsquo;t build inheritance on a single type, but on a hierarchy of
keywords. Those can be dispatched on just like any other
keyword. First, an example hierarchy of keywords using the built-in
functions &lt;code&gt;derive&lt;/code&gt; and &lt;code&gt;isa?&lt;/code&gt;. These &lt;code&gt;::&lt;/code&gt; keywords are
namespaced, which prevents collisions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(derive ::cat ::mammal)
(derive ::dog ::mammal)
(derive ::dog ::hairy)
(derive ::poodle ::dog)

(isa? ::poodle ::dog)
;; =&amp;gt; true
(isa? ::poodle ::mammal)
;; =&amp;gt; true
(isa? ::poodle ::hairy)
;; =&amp;gt; true
(isa? ::poodle ::cat)
;; =&amp;gt; false
(isa? ::mammal ::hairy)
;; =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;::dog&lt;/code&gt; is-a &lt;code&gt;::mammal&lt;/code&gt; and is-a &lt;code&gt;::hairy&lt;/code&gt;, the
classical diamond problem (without the common ancestor, which is
possible, but unneeded for the example).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti speak :animal)
(defmethod speak ::poodle [d] &amp;quot;chirps&amp;quot;)
(defmethod speak ::mammal [c] &amp;quot;breathes&amp;quot;)

(speak {:animal ::poodle :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;chirps&amp;quot;
(speak {:animal ::dog :id 2 :name &amp;quot;Mr Dog&amp;quot;})
;; =&amp;gt; &amp;quot;breathes&amp;quot;

(defmulti shave :animal)
(defmethod shave ::poodle [d] &amp;quot;shivers&amp;quot;)
(defmethod shave ::hairy [c] &amp;quot;stuggles&amp;quot;)
(defmethod shave ::mammal [c] &amp;quot;maybe cant be shaved!&amp;quot;)
(prefer-method shave ::hairy ::mammal)

(shave {:animal ::poodle :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;shivers&amp;quot;
(shave {:animal ::dog :id 2 :name &amp;quot;Rufs&amp;quot;})
;; =&amp;gt; &amp;quot;stuggles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see the &lt;code&gt;::dog&lt;/code&gt; keyword doesn&amp;rsquo;t have an explicit speak or shave
implementation, which is fine, because it will then use the &amp;ldquo;preferred&amp;rdquo;
parent implementation, which returns &amp;ldquo;breathes&amp;rdquo; for speak or
&amp;ldquo;struggles&amp;rdquo; for shave. Since we can have a keyword be the child of
multiple parents, we get a multiple inherited behavior, where the
preferred match is the one returned.&lt;/p&gt;

&lt;p&gt;This is possible because the default equality check of multimethod is
the &lt;code&gt;isa?&lt;/code&gt; function. Because of this, uses of multimethod
hierarchies can have inherited behavior for complex structures.&lt;/p&gt;

&lt;h2 id=&#34;6-mostly-monadic:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;6 - Mostly Monadic&lt;/h2&gt;

&lt;p&gt;Languages like Haskell and F# have tools like the maybe monad that add
safety to operations. For example, using the maybe monad can
completely prevent null reference exceptions by making you ensure you
&amp;ldquo;unpack&amp;rdquo; the value every time.&lt;/p&gt;

&lt;p&gt;How does Clojure address this? In a typical Clojure way, which gives
80% of the value for 20% of the effort, Clojure has a great
relationship with empty lists and nil. Rather than wrapping every
value that is nullable in a type, Clojure&amp;rsquo;s default functions all
&lt;em&gt;mostly&lt;/em&gt; deal with nil and empty without throwing exceptions. For
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(get {:id 5} :id)
;; =&amp;gt; 5
(get nil :id)
;; =&amp;gt; nil

(first [3 2 1])
;; =&amp;gt; 3
(first nil)
;; =&amp;gt; nil
(count nil)
;; =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows functions to be chained without fear that along the way a
nil will get returned.&lt;/p&gt;

&lt;p&gt;Since most of the core functions are &amp;ldquo;smart&amp;rdquo; about nil, you gain much
of the value and safety of monads without most of the
hassle. Ultimately, a more rich type system would allow for custom
types which can be domain specific, but in day-to-day working,
primitive safety is still a huge win.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;These are a few simple features that keep me coming back to Clojure,
even from languages like F# and Haskell. While Clojure is a bit more
wordy than the ML family, and not as type safe, the simplicity of
these features keep me coming back for more!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>End To End Web Service Testing</title>
      <link>http://deliberate-software.com/end-to-end-web-service-testing/</link>
      <pubDate>Fri, 12 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/end-to-end-web-service-testing/</guid>
      <description>&lt;p&gt;
  At work last month, I was assigned to fix some bugs in an
  asynchronous legacy code base. My supervisor gave me a month to see
  what I could do, and to see if I could fix a few tricky bugs. The
  code is divided into two sections, a client application and a web
  server. Both the client application and the server have their own
  persistence, and they communicate through a soap web service.
&lt;/p&gt;
&lt;p&gt;
  I wanted to try and write some sort of end-to-end tests around this,
  but I could not figure out how to get around that web service. I
  don&amp;#039;t want my tests to rely on a server having to always be up,
  so I initially was planning on writing tests from the client
  database to the web service, where I would just stub some responses.
  I got about an hour into that plan, before I realized I would then
  have to do that same thing on the server, and that sort of testing
  will not really tell me what the code &lt;i&gt;does&lt;/i&gt;. I needed to cover
  this whole process end-to-end.
&lt;/p&gt;
&lt;p&gt;
 I walked around for a bit, thinking. Then it hit me, both the server
 and client code are written in VB.NET, and, except for the web service, work
 just like plain old highly-coupled code. Hmmm.
&lt;/p&gt;
&lt;p&gt;
 For the first pass, I wrote an interface to wrap the web service,
 then used dependency injection to inject a fake web service that (and
 here is the cool part) simply calls around the web service entirely
 to the server code directly and injects a different database
 connection string, so the server talks to a second database I have
 prepared.
&lt;/p&gt;
&lt;p&gt;
 Just like that, I can run, all on my machine, 99 percent of the code
 in a single end-to-end test. I can even setup several client
 databases, and rotate them out, to &amp;quot;swap&amp;quot; between several
 clients in the middle of the tests.
&lt;/p&gt;
&lt;p&gt;
 I added a few &amp;quot;integration&amp;quot; tests that do talk to a real
 published testing web service, just to make sure everything is still
 in place correctly.
&lt;/p&gt;
&lt;p&gt;
  Now, I said this was asynchronous, and it is, the executed
  system-under-test kicks off a thread to talk to the web service, and
  so to get it to test, I needed to wait for the thread to finish,
  then do my assertions.
&lt;/p&gt;
&lt;p&gt;
 I used a system where the spun off thread will set a boolean when it
 has finished running, to let the main thread know it has finished,
 and the main thread just keeps checking that boolean until it is
 true. While hackish, that is my current working solution, as no more
 then one thread is ever spun off at a time, I can just have my test
 wait for the thread to finish, then complete the required assertions.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing Is To Programming What Math Is To Engineering</title>
      <link>http://deliberate-software.com/testing-is-to-programming-what-math-is-to-eng/</link>
      <pubDate>Mon, 26 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/testing-is-to-programming-what-math-is-to-eng/</guid>
      <description>&lt;p&gt;
  In ancient times, plenty of builders did their work without math,
  and I would guess that a good portion of them likely did it faster
  then their math-doing counterparts.
&lt;/p&gt;
&lt;p &gt;
  I am certain that when builders first started using math to prove
  that buildings would stand up safely, they were mocked by their
  math-less counterparts. I can hear them now, &#34;Oh, Stephos, it takes
  you 5 times longer to prove your building will stand up, real men
  can just &lt;em&gt;see&lt;/em&gt; that it will work&#34;. Even in modern times, many
  people build houses and small buildings that probably don&#39;t even
  need the math to really &#34;prove&#34; they work, but they perform the due
  diligence anyway. On the other hand, some people today still build
  houses, sheds, tree-houses, lofts, and fire pits without any
  drawings or math at at all, and why should they? They are
  responsible for the risk.
&lt;/p&gt;
&lt;p &gt;
  This is all fine, but, builders who shy away from math also don&#39;t
  build airliners, space shuttles, and skyscrapers. An aircraft
  designer who doesn&#39;t feel like using math to prove their aircraft
  will fly is handed an &#34;Experimental&#34; sticker and gravely patted on
  the back.
&lt;/p&gt;
&lt;p &gt;
  Today, programming is at the same place as both
  ancient &lt;strong&gt;and&lt;/strong&gt; modern engineering: many projects can
  be done &#34;by eye&#34;, and some of the most experienced programmers are
  able to build immense projects alone without any sort of automated
  testing at all. When you go to a forum and ask for help, you are
  just as likely to hear from a &#34;space shuttle&#34; programmer as you are
  to hear from a &#34;tin shack&#34; programmer. The &#34;space shuttle&#34;
  programmer would be horrified to hear of working without automated
  testing and rigorous review practices, whereas the &#34;tin shack&#34;
  programmer would be horrified to think of the time wasted to
  even &lt;em&gt;learn the procedures&lt;/em&gt; to automatically prove his code
  works as it should. The &#34;space shuttle&#34; programmer might work on the
  same internal financial project for months or years, finally
  releasing with zero defects; the &#34;tin shack&#34; programmer might churn
  out several quick web sites a day. Neither project
  is &lt;em&gt;better&lt;/em&gt; then the other, they both might be perfect for
  what their business needs.
&lt;/p&gt;
&lt;p&gt;
  I have heard several times from very good lone wolf programmers that
  testing just slows them down, and in some ways, it does appear to be
  a slowdown for them. Unfortunately, the cost to build even
  medium-sized projects with several workers without automated testing
  is only felt when it is too late, when the deadlines (and costs) are
  spiraling out of control.
&lt;/p&gt;
&lt;p&gt;
  The disciplined application of mathematics transformed and
  solidified the field of engineering into a field far more vast and
  capable of some of the most incredible constructions imaginable.
  Would we have smart-phones, GPS, modern cars, and airliners if
  engineering had just avoided mathematics? Just imagine what the
  field of programming could grow into if we continue to learn and
  grow our testing, designing, and writing of software.
&lt;/p&gt;
&lt;p&gt;
  I propose that automated testing is to programming what math was
  to ancient engineering.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dont Mock Concrete Classes</title>
      <link>http://deliberate-software.com/dont-mock-concrete-classes/</link>
      <pubDate>Tue, 24 May 2011 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/dont-mock-concrete-classes/</guid>
      <description>&lt;p&gt;(They have thin skin)&lt;/p&gt;
&lt;p&gt;I have been
reading &lt;a href=&#34;http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;amp;s=books&amp;amp;qid=1303935530&amp;amp;sr=8-1&#34;
target=&#34;_blank&#34;&gt;G.O.O.S.&lt;/a&gt; and honestly, much of it has been just a
reiteration. Until chapter 20, that is. I get to the section Don&#39;t
Mock Concrete Classes, and it clicks.
&lt;/p&gt;
&lt;p&gt;
 Mocking concrete classes used to be my bread and butter. Almost every
 unit test I wrote for the last year had several mocked concrete
 implementations, to pass in as dependencies of the system under test.
&lt;/p&gt;
&lt;p&gt;
What do I mean by that? Imagine a class that takes one dependency
through the constructor like this:
&lt;/p&gt;
``` php
class Velocity {
  public function __construct (PayoffCalc $PayoffCalc) {
    $this-&gt;_PayoffCalc = $PayoffCalc;
  }
  public function toFloat() {
    $paymentPerDay = $this-&gt;_PayoffCalc-&gt;getPaymentPerDay();
    return $this-&gt;_calculate($paymentPerDay);
  }
}
```
&lt;p&gt;
Would have a test driving it, looking like this:
&lt;/p&gt;
``` php
public function test_velocity_validDailyPayment() {
  $paymentPerDay = 3;
  $expectedVelocity = 1392;
  //Mock PayoffCalc-&gt;getPaymentPerDay() to return 3
  $PayoffCalc = $this-&gt;getMock(&#39;PayoffCalc&#39;, array(&#39;getPaymentPerDay&#39;)); 
  $PayoffCalc-&gt;expects($this-&gt;once())
             -&gt;method(&#39;getPaymentPerDay&#39;)
             -&gt;will($this-&gt;returnValue($paymentPerDay));
  $Velocity = new Velocity($PayoffCalc);
  $this-&gt;assertEquals($expectedVelocity, $Velocity-&gt;toFloat());
}
```
&lt;/p&gt;
&lt;p&gt;
For several months now, writing unit tests this way has become
increasingly irritating to me, for several reasons. First off, notice
how phpunit does a mock? With a string for the classname and the
method to mock. Obviously, in small scale this duplication is
manageable, but imagine for a second thousands of unit tests all
mocking this way, and you will realize it gets out of hand fast. More
than once in the last year I have set out to refactor a classname or
method signature, to have dozens of failing unit tests, because they
all mock the &lt;em&gt;string&lt;/em&gt; of the old name.
&lt;/p&gt;
&lt;p&gt;
 Secondly, and more importantly, I find this to be brittle because you
 are locking yourself into an implementation of the class you need
 mocked. What if I wanted to move that getPaymentPerDay to a different
 class? Or I changed that version of getPaymentPerDay to
 getPaymentPerMonth? I would have to traipse through every one of
 those brittle mocks and rewrite their duplicated, crystalline
 structure.
&lt;/p&gt;
&lt;p&gt;
 Stupid.
&lt;/p&gt;
&lt;p&gt;
My inner frustration was so great as to cause me to start thinking up
all sorts of mad ways to get around this issue. Store the code needed
to build that mock as text on the class itself, to be parsed and
executed on the fly? Check. Create massive hierarchical testing
libraries to build the mocks? Check. And all these did was mask the
real issue. &lt;strong&gt;I was mocking the concrete
implementation.&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 So, what would mocking the interface be? Well, PayoffCalc actually
 has two public methods: getPayoffDate() and getPaymentPerDay(). The
 Velocity class only needs getPaymentPerDay(), but by mocking the
 concrete class, we are forcing it to depend on
 the &lt;strong&gt;whole&lt;/strong&gt; (undefined) interface of PayoffCalc.
 Velocity does not need getPayoffDate(), but it is in the interface we
 give it (in the form of the concrete PayoffCalc).
&lt;/p&gt;
&lt;p&gt;
 Whoa. Sounds
 like &lt;a href=&#34;http://en.wikipedia.org/wiki/Interface_segregation_principle&#34;
 target=&#34;_blank&#34;&gt;ISP&lt;/a&gt;. Written about by Bob Martin. Fifteen years
 ago. *Forehead smack*
&lt;/p&gt;
&lt;p&gt;
I make an interface for this concept of PaymentPerDayRetriever, for
lack of a
better &lt;a href=&#34;http://martinfowler.com/bliki/RoleInterface.html&#34;
target=&#34;_blank&#34;&gt;Role&lt;/a&gt;.
&lt;/p&gt;
``` php
interface PaymentPerDayRetriever {
  public function getPaymentPerDay();
}
```
&lt;p&gt;
Then use the interface in the test:
&lt;/p&gt;
``` php
public function test_velocity_validDailyPayment() {
    $paymentPerDay = 3;
    $expectedVelocity = 1392;
    //Mock PayoffCalc-&gt;getPaymentPerDay() to return 3
    $PayoffCalc = $this-&gt;getMock(&#39;PaymentPerDayRetriever&#39;);
    $PayoffCalc-&gt;expects($this-&gt;any())
        -&gt;method(&#39;getPaymentPerDay&#39;)
        -&gt;will($this-&gt;returnValue($paymentPerDay));
       $Velocity = new Velocity($PayoffCalc);
    $this-&gt;assertEquals($expectedVelocity, $Velocity-&gt;toFloat());
}
```
&lt;p&gt;
By mocking the interface, I have freed my Velocity class from knowing
about the rest of the old PayoffCalc interface, and when I realize
later that my PayoffCalc really is doing two totally separate things,
I can just move the PaymentPerDayRetriever interface to
getPaymentPerDay&#39;s new home (probably on the PaymentRepository, not
shown here).
&lt;/p&gt;
&lt;p&gt;
 While this example only used one method per interface, in reality, it
 would have all the methods necessary to complete that aspect of the
 class.
&lt;/p&gt;
&lt;p&gt;
Fascinating.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Actionscript Unit Testing</title>
      <link>http://deliberate-software.com/actionscript-unit-testing/</link>
      <pubDate>Wed, 04 May 2011 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/actionscript-unit-testing/</guid>
      <description>&lt;p&gt;I am trying to test a project that is huge and many of the
&amp;quot;classes&amp;quot; are only defined as linkages from the main monster
fla. I followed &lt;a href=&#34;http://marstonstudio.com/2007/07/28/asunit-testing-with-flash-cs3-and-actionscript-3/&#34; target=&#34;_blank&#34;&gt;ASUnit Tutorial&lt;/a&gt; and got it to work with their simple examples. But when I went to test a factory and child class I had just written (hey, I would have tdd&amp;#039;d, but then I would not have know if it was failing for the right reason), it would not compile, hanging up on some of those undefined &amp;quot;exported linkage&amp;quot; classes. I could not find anything about that online, I assume because developers who would want to write unit tests wouldn&amp;#039;t rely on those exported linkage classes anyway.&lt;p /&gt; After waiting for a day or two and moving on, I asked the guy who maintains this project. His knee-jerk solution? Call the new AsUnitTestRunner() right in the first line of the constructor for the main fla&amp;#039;s class. I was skeptical at best, but it worked! My guess is those exported linkages are imported into the project scope through some sort of implicit import on the constructor of the class tied to the .fla with the linkages. Sheesh.&lt;p /&gt; Obviously, we want to start defining those exported linkage classes as actual code, so we can run our tests without un-commenting the new AsUnitTestRunner() and then building the project, but it is a start in the right direction.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>