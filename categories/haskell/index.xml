<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on deliberate software</title>
    <link>http://deliberate-software.com/categories/haskell/</link>
    <description>Recent content in Haskell on deliberate software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://deliberate-software.com/categories/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Wrangling State In Haskell</title>
      <link>http://deliberate-software.com/haskell-state/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/haskell-state/</guid>
      <description>&lt;p&gt;Part 2 of my series &amp;ldquo;Wrangling State&amp;rdquo;. Part 1
&lt;a href=&#34;http://deliberate-software.com/clojure-state/&#34;&gt;Wrangling State In Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Haskell is a pure language, so you can only deal with application state by
passing parameters to functions. It is possible to pass parameters more
conveniently, but ultimately, every parameter needs to be passed.&lt;/p&gt;

&lt;p&gt;Here is a simple application for logging a timestamp to a file.&lt;/p&gt;

&lt;p&gt;First, &lt;strong&gt;Pass As Parameter&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;loadFile :: Filename -&amp;gt; IO String
loadFile fileName =
  BS.unpack &amp;lt;$&amp;gt; Str.readFile fileName

saveFile :: Filename -&amp;gt; String -&amp;gt; IO ()
saveFile fileName contents = 
  Str.writeFile fileName (BS.pack contents)

clearFile :: Filename -&amp;gt; IO ()
clearFile fileName = saveFile fileName &amp;quot;&amp;quot;

appendToFile :: Filename -&amp;gt; String -&amp;gt; IO ()
appendToFile fileName stuff = do
    contents &amp;lt;- loadFile fileName
    saveFile fileName (contents++stuff)

main fileName &amp;quot;-c&amp;quot; = clearFile fileName
main fileName &amp;quot;-log&amp;quot; = do
  now &amp;lt;- getCurrentTime
  appendToFile fileName ((show now)++ &amp;quot;\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We take in the file name and the command to perform, either to clear the file or
to append a new timestamp. While simple, this gets cumbersome in a large
application. Imagine passing a database connection through every single function
that eventually calls the database.&lt;/p&gt;

&lt;p&gt;Haskell can have unnamed parameters that are not defined in the argument list.
Sometimes this can improve legibility, other times it can worsen it. To use this
feature, the function signature must contain the value missing. The parameter(s)
must be the &amp;ldquo;last&amp;rdquo; parameter(s) to the function for this to work.&lt;/p&gt;

&lt;p&gt;Here is the same code with &lt;strong&gt;Unnamed Parameters&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;loadFile :: Filename -&amp;gt; IO String
loadFile = (liftM BS.unpack) . Str.readFile

saveFile :: String -&amp;gt; Filename -&amp;gt; IO ()
saveFile contents fileName =
  Str.writeFile fileName (BS.pack contents)

clearFile :: Filename -&amp;gt; IO ()
clearFile = saveFile &amp;quot;&amp;quot;

appendToFile :: String -&amp;gt; Filename -&amp;gt; IO ()
appendToFile stuff = (&amp;gt;&amp;gt;=) &amp;lt;$&amp;gt; loadFile &amp;lt;*&amp;gt; ((. (++stuff)) . (flip saveFile))

main fileName &amp;quot;-c&amp;quot; = clearFile fileName
main fileName &amp;quot;-log&amp;quot; = do
  now &amp;lt;- getCurrentTime
  appendToFile ((show now)++ &amp;quot;\n&amp;quot;) fileName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not all usages of &lt;code&gt;Filename&lt;/code&gt; can be easily unnamed. We did use it in
&lt;code&gt;loadFile&lt;/code&gt; and &lt;code&gt;clearFile&lt;/code&gt;. It does allow the &amp;ldquo;differences&amp;rdquo; to stand out
more. For example, &lt;code&gt;clearFile&lt;/code&gt; is just a &lt;code&gt;saveFile&lt;/code&gt; with an empty string
for the first parameter. We can see the differences clearly without the extra
parameter adding noise.&lt;/p&gt;

&lt;p&gt;We added it to &lt;code&gt;appendToFile&lt;/code&gt;, using point-free style. I find that it makes
it much harder to scan and read.&lt;/p&gt;

&lt;p&gt;Lastly, it is possible to encode such values into the type. The type of the
function itself can imply a value that can be retrieved. For example, the Reader
type can be combined with the IO type using ReaderT.&lt;/p&gt;

&lt;p&gt;Here is the code using the &lt;strong&gt;Reader Type&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;loadFile :: ReaderT Filename IO String
loadFile = do
  fileName &amp;lt;- ask
  liftIO $ BS.unpack &amp;lt;$&amp;gt; Str.readFile fileName

saveFile :: String -&amp;gt; ReaderT Filename IO ()
saveFile contents = do
  fileName &amp;lt;- ask
  liftIO $ Str.writeFile fileName (BS.pack contents)

clearFile :: ReaderT Filename IO ()
clearFile = saveFile &amp;quot;&amp;quot;

appendToFile :: String -&amp;gt; ReaderT Filename IO ()
appendToFile stuff = do
    contents &amp;lt;- loadFile
    saveFile (contents++stuff)

main fileName &amp;quot;-c&amp;quot; = runReaderT clearFile fileName
main fileName &amp;quot;-log&amp;quot; = do
  now &amp;lt;- getCurrentTime
  runReaderT (appendToFile ((show now)++ &amp;quot;\n&amp;quot;)) fileName
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice now how &lt;code&gt;appendToFile&lt;/code&gt; and &lt;code&gt;clearFile&lt;/code&gt; have the signature:
&lt;code&gt;ReaderT Filename IO ()&lt;/code&gt;, indicating that anything below them can &lt;code&gt;ask&lt;/code&gt;
for the Filename, while still performing an &lt;code&gt;IO&lt;/code&gt; action. The &amp;ldquo;entry-point&amp;rdquo;
calls in &lt;code&gt;main&lt;/code&gt; need to be initialized with the &lt;code&gt;runReaderT&lt;/code&gt; and the
&lt;code&gt;Filename&lt;/code&gt; we want to pass.&lt;/p&gt;

&lt;p&gt;For this case, the &lt;code&gt;ReaderT&lt;/code&gt; is substantially more readable. The &amp;ldquo;business
value&amp;rdquo; functions &lt;code&gt;appendToFile&lt;/code&gt; and &lt;code&gt;clearFile&lt;/code&gt; do not have to define
and pass the parameters needed for the lower level functions &lt;code&gt;saveFile&lt;/code&gt; and
&lt;code&gt;loadFile&lt;/code&gt;. &lt;strong&gt;Reader Type&lt;/strong&gt; gives us the value of the &lt;strong&gt;Unnamed
Parameters&lt;/strong&gt; for legibility!&lt;/p&gt;

&lt;p&gt;For something like a database connection that might be used pervasively, the
&lt;strong&gt;Reader Type&lt;/strong&gt; is essential for legible code. The low level functions that need
the &lt;code&gt;Filename&lt;/code&gt; are able to call &lt;code&gt;ask&lt;/code&gt; to retrieve it.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Dependencies&lt;/th&gt;
&lt;th&gt;Complexity&lt;/th&gt;
&lt;th&gt;Adding New State&lt;/th&gt;
&lt;th&gt;Best When&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Pass As Parameter&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Explicit&lt;/td&gt;
&lt;td&gt;Less Complex&lt;/td&gt;
&lt;td&gt;Harder&lt;/td&gt;
&lt;td&gt;State only needed in a few functions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Unnamed Parameter&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Explicit&lt;/td&gt;
&lt;td&gt;Less Complex&lt;/td&gt;
&lt;td&gt;Harder&lt;/td&gt;
&lt;td&gt;Functions can be made more readable&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Reader Type&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Explicit&lt;/td&gt;
&lt;td&gt;More Complex&lt;/td&gt;
&lt;td&gt;Easier&lt;/td&gt;
&lt;td&gt;State needed throughout the application&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Compared to &lt;a href=&#34;http://deliberate-software.com/clojure-state/&#34;&gt;Clojure&lt;/a&gt;, Haskell has no way to
call a function &amp;ldquo;incorrectly&amp;rdquo;. All in-memory state is passed explicitly.&lt;/p&gt;

&lt;p&gt;Haskell&amp;rsquo;s type system prevents the programmer from forgetting state.
Unfortunately, it is still possible to pass as any parameter a value that is
invalid. The explicit nature of Haskell parameters does not prevent passing a
database connection string that does not exist, or a pointer to an incorrectly
setup data structure.&lt;/p&gt;

&lt;p&gt;Haskell is opinionated, and forces you to consider all the state up front before
calling a function. While this makes it harder to forget about state, it also
makes abstractions more leaky. Instead of relying on a function which may or may
not use a database, you must know and pass the database connection.&lt;/p&gt;

&lt;p&gt;Even though I believe the Haskell type system makes abstractions more leaky, I
prefer having to think up front about all my state. I find it makes the code
more clear, and helps me control what functions have access to state.&lt;/p&gt;

&lt;p&gt;Edit: Thanks to &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/4go5dr/wrangling_state_in_haskell/d2j9aqz&#34;&gt;/u/kccqzy&lt;/a&gt; on reddit for offering a way to make
&lt;code&gt;appendToFile&lt;/code&gt; use point-free style.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Haskell is the Dark Souls of Programming</title>
      <link>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</guid>
      <description>

&lt;p&gt;Please don&amp;rsquo;t hit me, Haskell does a great job of that already.&lt;/p&gt;

&lt;p&gt;I love Haskell for the same reasons I love Dark Souls. Fantastic and inscrutable
lore, a great &lt;del&gt;combat&lt;/del&gt; type system, a cliff-wall difficulty curve, and
unending punishment.&lt;/p&gt;

&lt;p&gt;I want to collect some statistics from the GitHub API.&lt;/p&gt;

&lt;h3 id=&#34;step-one-stack:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step One - Stack&lt;/h3&gt;

&lt;p&gt;I download stack and start a project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; cd /home/jack/programming &amp;amp;&amp;amp; stack new github-stats &amp;amp;&amp;amp; cd github-stats
Downloading template &amp;quot;new-template&amp;quot; to create project &amp;quot;github-stats&amp;quot; in github-stats/ ... 
 ......
All done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good. Does it work?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  &amp;gt; stack build &amp;amp;&amp;amp; stack exec -- github-stats-exe 
   github-stats-0.1.0.0: configure
   ..... 
   Registering github-stats-0.1.0.0...
   someFunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awww yisss. This is going to be so easy!&lt;/p&gt;

&lt;h3 id=&#34;step-two-https-get-request:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step Two - HTTPS GET Request&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/tomb_of_the_giants.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Now I need to query the GitHub API. Not my first time to the rodeo, I generate a
personal access token from GitHub and copy it to a local file. What query should
I run first? How about the count for all ASM tetris repositories? Poking around
the &lt;a href=&#34;https://developer.github.com/v3/search/#search-repositories&#34;&gt;docs&lt;/a&gt; comes up
with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET https://api.github.com/search/repositories?q=tetris+language:assembly&amp;amp;sort=stars&amp;amp;order=desc
User-Agent: steveshogren
Authorization: token PUT_TOKEN_HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;{.. &amp;ldquo;total_count&amp;rdquo;: 354}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Easy life. Now how do you GET a resource in Haskell? Ah,
&lt;a href=&#34;https://hackage.haskell.org/package/HTTP-4000.3.2/docs/Network-HTTP.html&#34;&gt;Network.HTTP&lt;/a&gt;!
I copy the front page sample into &lt;code&gt;src/Lib.hs&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Lib
    ( someFunc
    ) where

x = simpleHTTP (getRequest &amp;quot;https://www.github.com/&amp;quot;) &amp;gt;&amp;gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = 
   print x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So simple! This is why laugh at my NodeJS loving friends!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doesn&amp;rsquo;t compile. Durp, hackage is a package library, I need to add this to my
cabal. What is the name of the package? HTTP-4000? HTTP-4000.3.2? Nothing in
hackage seems to indicate what goes into the cabal file. I discover it is just
HTTP through trial and error. I update my cabal file&amp;hellip; in all three
build-depends&amp;hellip;?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  build-depends:       base &amp;gt;= 4.7 &amp;amp;&amp;amp; &amp;lt; 5
                       , HTTP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hrm, same error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, durp, I&amp;rsquo;d need an import. (WHY ISN&amp;rsquo;T THIS IN THE CODE SAMPLE?!) Also, print
doesn&amp;rsquo;t work, I need &lt;code&gt;putStrLn&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Network.HTTP

x = simpleHTTP (getRequest &amp;quot;https://www.github.com/&amp;quot;) &amp;gt;&amp;gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = x &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here goes!!!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; &amp;gt; stack build &amp;amp;&amp;amp; stack exec -- github-stats-exe
github-stats-exe: user error (https not supported)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat. Further inspection of the docs shows a line WAAY DOWN in paragraph 5.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: This package only supports HTTP;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/nope_better.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;When &lt;del&gt;playing Dark Souls&lt;/del&gt;programming Haskell, sometimes the best move
is to run away. I search again. &lt;code&gt;haskell https request&lt;/code&gt; returns
&amp;ldquo;http-conduit&amp;rdquo; as the best choice. After adding http-conduit to my cabal, I come
up with this beast without any surprises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query :: IO String
query = do
    initReq &amp;lt;- parseUrl &amp;quot;https://api.github.com/search/repositories&amp;quot;
    let r = initReq
                   { method = &amp;quot;GET&amp;quot;
                    , requestHeaders = [(hUserAgent, &amp;quot;steveshogren&amp;quot;)
                                      , (hAuthorization, &amp;quot;token PUT_TOKEN_HERE&amp;quot;)]}
    let request = setQueryString [(&amp;quot;q&amp;quot;, Just &amp;quot;tetris+language:assembly&amp;quot;)
                                 ,(&amp;quot;order&amp;quot;, Just &amp;quot;desc&amp;quot;)
                                 ,(&amp;quot;sort&amp;quot;, Just &amp;quot;stars&amp;quot;)] r
    manager &amp;lt;- newManager tlsManagerSettings
    res &amp;lt;- httpLbs request manager
    return . show . responseBody $ res

someFunc :: IO ()
someFunc = do
   query &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huzzah! Results! I&amp;rsquo;m getting back a monster string of json data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;\&amp;ldquo;{\\&amp;ldquo;total_count\\&amp;rdquo;:66, &amp;hellip;.}\&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/praisethesun.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-three-parsing-json:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step Three - Parsing JSON&lt;/h3&gt;

&lt;p&gt;Time to parse this mega JSON string. Aeson seems to be the biggest contender. To
use Aeson and get the total_count value from the return, I needed the following
additions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResultCount allows me to use &lt;code&gt;decode&lt;/code&gt; from aeson instead of &lt;code&gt;show&lt;/code&gt; to
parse the &amp;ldquo;total_count&amp;rdquo; from the JSON response into an Int. Sure enough, it
does!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Lib
    ( someFunc
    ) where

import Control.Monad
import Network
import Network.HTTP.Conduit
import Network.HTTP.Types.Header
import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount

query :: IO (Maybe Int)
query = do
    initReq &amp;lt;- parseUrl &amp;quot;https://api.github.com/search/repositories&amp;quot;
    let r = initReq
                   { method = &amp;quot;GET&amp;quot;
                    , requestHeaders = [(hUserAgent, &amp;quot;steveshogren&amp;quot;)
                                      , (hAuthorization, &amp;quot;token PUT_TOKEN_HERE&amp;quot;)]}
    let request = setQueryString [(&amp;quot;q&amp;quot;, Just &amp;quot;tetris+language:assembly&amp;quot;)
                                 ,(&amp;quot;order&amp;quot;, Just &amp;quot;desc&amp;quot;)
                                 ,(&amp;quot;sort&amp;quot;, Just &amp;quot;stars&amp;quot;)] r
    manager &amp;lt;- newManager tlsManagerSettings
    res &amp;lt;- httpLbs request manager
    return . liftM total_count . decode . responseBody $ res

someFunc :: IO ()
someFunc = query &amp;gt;&amp;gt;= print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puts out: &lt;code&gt;Just 66&lt;/code&gt;. Success! Wait. 66 isn&amp;rsquo;t the same count I got when
running from the browser. Check again. Sure enough, browser comes up with a
totally different count.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/come_at_me_bro.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Maybe the query request isn&amp;rsquo;t correct? Adding a &lt;code&gt;print request&lt;/code&gt; on line 31
after building the request shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Request {
  host                 = &amp;quot;api.github.com&amp;quot;
  port                 = 443
  secure               = True
  requestHeaders       = [(&amp;quot;User-Agent&amp;quot;,&amp;quot;steveshogren&amp;quot;),(&amp;quot;Authorization&amp;quot;,&amp;quot;token PUT_TOKEN_HERE&amp;quot;)]
  path                 = &amp;quot;/search/repositories&amp;quot;
  queryString          = &amp;quot;?q=tetris%2Blanguage%3Aassembly&amp;amp;order=desc&amp;amp;sort=stars&amp;quot;
  method               = &amp;quot;GET&amp;quot;
  proxy                = Nothing
  rawBody              = False
  redirectCount        = 10
  responseTimeout      = Just (-3425)
  requestVersion       = HTTP/1.1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The queryString isn&amp;rsquo;t right! It encoded my &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;! After an hour of
reading through docs and researching URL encoding specs, it dawns on me. &lt;code&gt;+&lt;/code&gt;
is an encoded whitespace.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No face-palm gif could ever represent the shear magnitude of my current
emotions&amp;hellip; You&amp;rsquo;ll have to use your imagination&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I change my query to &lt;code&gt;&amp;quot;tetris language:assembly&amp;quot;&lt;/code&gt; and the right
count comes back! &lt;code&gt;Just 354&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I finally have something that correctly fetches a count of repositories from
GitHub and parses it into an Int. After over four hours of &lt;del&gt;Dark
Souls&lt;/del&gt;Haskell punishment, we deserve to enjoy a bonfire!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/solaire_sitting.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h2 id=&#34;edit-bonus-round:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Edit: Bonus Round!&lt;/h2&gt;

&lt;p&gt;Thanks to
&lt;a href=&#34;http://bitemyapp.com/posts/2016-02-06-haskell-is-not-trivial-not-unfair.html&#34;&gt;Chris Allen&lt;/a&gt;
and
&lt;a href=&#34;https://www.reddit.com/r/programming/comments/44hdl6/haskell_is_the_dark_souls_of_programming/czqaxfu&#34;&gt;/u/JeanParker&lt;/a&gt;
for pointing me towards &lt;a href=&#34;http://www.serpentine.com/wreq/&#34;&gt;wreq&lt;/a&gt;, which weirdly
didn&amp;rsquo;t come up when I looked around for libs yesterday. Yep, it was 6th on the
Google when searching for &lt;code&gt;haskell https get&lt;/code&gt;. &lt;code&gt;Network.HTTP&lt;/code&gt; is the
top three results, and that doesn&amp;rsquo;t even &lt;em&gt;do&lt;/em&gt; https.&lt;/p&gt;

&lt;p&gt;¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/p&gt;

&lt;p&gt;Armed with their helpful suggestions, I knocked this out this morning.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Network.Wreq
import Control.Lens
import Data.Aeson
import Data.Aeson.Lens
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as BS

opts :: String -&amp;gt; String -&amp;gt; Options
opts lang token = defaults &amp;amp; param &amp;quot;q&amp;quot; .~ [T.pack $ &amp;quot;tetris language:&amp;quot; ++ lang]
                        &amp;amp; param &amp;quot;order&amp;quot; .~ [&amp;quot;desc&amp;quot;]
                        &amp;amp; param &amp;quot;sort&amp;quot; .~ [&amp;quot;stars&amp;quot;]
                        &amp;amp; header &amp;quot;Authorization&amp;quot; .~ [BS.pack $ &amp;quot;token &amp;quot; ++ token]

query lang = do
    token &amp;lt;- readFile &amp;quot;token&amp;quot;
    r &amp;lt;- getWith (opts lang token) &amp;quot;https://api.github.com/search/repositories&amp;quot;
    return $ r ^? responseBody . key &amp;quot;total_count&amp;quot; . _Number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MUCH better. This includes reading my token from file called &amp;ldquo;token&amp;rdquo; so I don&amp;rsquo;t
accidentally commit it. Also includes building up the different query options
based on inputs, which was the next step. Thanks y&amp;rsquo;all.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pixel gifs sourced from
&lt;a href=&#34;http://zedotagger.deviantart.com/gallery/54317550/Dark-Souls&#34;&gt;zedotagger&lt;/a&gt; on
deviantart, thanks zedotagger!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Programming Language Safety Score Mark 2</title>
      <link>http://deliberate-software.com/safety-rank-part-2/</link>
      <pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/safety-rank-part-2/</guid>
      <description>

&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://deliberate-software.com/javascripts/sliders2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I want to make a model that predicts bugs.&lt;/p&gt;

&lt;p&gt;I previously wrote a table for scoring language safety:
&lt;a href=&#34;http://deliberate-software.com/programming-language-safety-algorithm&#34;&gt;Programming Language Safety Score&lt;/a&gt;,
but it was extremely time consuming to score new languages or make modifications.&lt;/p&gt;

&lt;h2 id=&#34;simplify-simplify:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Simplify, Simplify&lt;/h2&gt;

&lt;p&gt;After being told I was &lt;a href=&#34;https://en.wikipedia.org/wiki/Overfitting&#34;&gt;overfitting&lt;/a&gt;
the data, I&amp;rsquo;ve attempted to clean up by simply checking if each category is
enforced, possible, or impossible. I score each as either 1 (language enforced),
0 (possible, but you have to remember to do it), or -1 (impossible). When the
magnitudes of the new model are compared with the previous model, they come out
very similar. The shape of the curve pretty much stays the same, which I was
told indicates that the character count weighting was a variable that didn&amp;rsquo;t
matter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/rplot.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The code I used to generate the plot and normalize the scores can be found here:
&lt;a href=&#34;https://github.com/steveshogren/datasciencecoursera/blob/817dec79e36b6e9a6c5a8fd5700aff7cc394b9d4/scoreplot.R&#34;&gt;scorePlot.R&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;safety-definitions:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Safety Definitions&lt;/h2&gt;

&lt;p&gt;A definition of the safety checks is as follows:&lt;/p&gt;

&lt;div ng-app=&#34;TableApp2&#34;&gt;
&lt;div ng-controller=&#34;TableCtrl&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td&gt;{{ check.name }} &lt;/td&gt;
&lt;td&gt; {{ check.desc }}  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

The new scores are shown here, with a lot more languages added in:

&lt;p class=&#34;lead&#34;&gt;
&lt;div style=&#34;overflow-x:scroll&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;
&lt;th&gt;Safety Check&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[0]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[1]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[2]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[3]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34; score-row name=&#34;check.name&#34; row-key=&#34;check.key&#34;&gt;&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Totals&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ lang }}
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Magnitude&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ percentageTotals(lang) }}%
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Current Languages:
&lt;span ng-repeat=&#34;lang in allLanguages&#34;&gt;
{{ getName(lang) }}: {{ allLangTotals[$index] }},
&lt;/select&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-what-s-the-point:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;So, What&amp;rsquo;s the Point?&lt;/h2&gt;

&lt;p&gt;To see how this model corresponds with data in the real world, I used the GitHub
API to query for the number of bugs created in repositories with more than 15
forks created in a span from 2011 to 2015. Commits were counted by summing the
commit counts of all contributors.&lt;/p&gt;

&lt;p&gt;I decided to rely on the count of commits as a standard for a unit of work. My
assumption was that across fifty different projects, the commit sizes would
average out. Once the unit of work was decided on, I wanted to find the ratio of
bugs per commit for each language.&lt;/p&gt;

&lt;p&gt;I collected the ratio of bugs logged per commit for each repository, and after
grouping by primary language, removed the top and bottom 25% using the
bug/commit ratio, which is a common practice in statistics to help find a more
accurate average. I summed the bugs and commits of those remaining repositories
grouped by language, finding a total average bug/commit ratio for each language
grouping. Here is that data, sorted by safety score.&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Bugs&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Bug/Commits&lt;/th&gt;
&lt;tr ng-repeat=&#34;lang in languageRatios&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.bugs }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getBugsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Here are the languages sorted by safety score with bug/commit ratios:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/errorChart.jpg&#34;&gt;&lt;/img&gt;
&lt;img src=&#34;http://deliberate-software.com/images/bugsAverage.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;I took the magnitude of the safety scores and the bug/commit ratios. After
inverting the safety scores, I overlaid them both onto a single graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/bothMags.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Immediately it is obvious that Ruby, Python, PHP, and Clojure all seem to strongly
buck the trend, but otherwise the languages follow a pretty consistent slope
down in bugs. Taking the correlation gives a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient&#34;&gt;correlation coefficient&lt;/a&gt;
of .55&lt;/p&gt;

&lt;h2 id=&#34;what-about-unit-tests:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;What About Unit Tests?&lt;/h2&gt;

&lt;p&gt;Thinking that Ruby, Clojure, PHP, and Python might not correlate well due to some
other factor, I collected data on how many tests each repository had. I counted
the number of files containing &amp;ldquo;test&amp;rdquo; or &amp;ldquo;spec&amp;rdquo;, which gave the following,
sorted by tests per commit:&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Tests&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Tests/Commits&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;lang in sorter(languageRatios)&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.test }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getTestsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;PHP, Python, and Ruby all have a higher then average number of tests, but
Clojure does not. Additionally, Go, Scala, and Java all also have a higher than
average number of tests, yet they score relatively average in bugs/commit.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In conclusion, the current safety model I have proposed seems to account for a
moderate reduction in bugs per commit across the sampled languages, but is not
the only factor. It currently is unable to account for a significantly lower
than expected bug count in Ruby and Clojure.&lt;/p&gt;

&lt;h2 id=&#34;special-thanks:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Special Thanks&lt;/h2&gt;

&lt;p&gt;Special thanks to (in alphabetical order):
&lt;a href=&#34;https://twitter.com/traffichazard/&#34;&gt;Patrick Boe&lt;/a&gt; (Haskell, Sniff Test),
&lt;a href=&#34;http://asymmetrical-view.com/&#34;&gt;Kyle Burton&lt;/a&gt; (General Advice),
Nils Creque (Listening Board),
Max Haley (Python, Ruby, Teaching me how to math),
&lt;a href=&#34;https://github.com/danielmiladinov&#34;&gt;Daniel Miladinov&lt;/a&gt; (Java, Scala, Morale Support),
Keith O&amp;rsquo;Brien (Ruby and JS),
&lt;a href=&#34;https://github.com/arlaneenalra&#34;&gt;Chris Salch&lt;/a&gt; (CoffeeScript and JS),
and &lt;a href=&#34;https://github.com/timvisher&#34;&gt;Tim Visher&lt;/a&gt; (Clojure).&lt;/p&gt;

&lt;p&gt;Additional thanks to the posters on
&lt;a href=&#34;https://www.reddit.com/r/rust/comments/3egx49/language_safety_score_mark_2/&#34;&gt;/r/rust&lt;/a&gt;,
including &lt;a href=&#34;https://www.reddit.com/user/notriddle&#34;&gt;/u/notriddle&lt;/a&gt;,
&lt;a href=&#34;https://www.reddit.com/user/killercup&#34;&gt;/u/killercup&lt;/a&gt;, and
&lt;a href=&#34;https://www.reddit.com/user/diegobernardes&#34;&gt;/u/diegobernardes&lt;/a&gt; who put together the Rust score.&lt;/p&gt;

&lt;h2 id=&#34;complaints-department:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Complaints Department&lt;/h2&gt;

&lt;p&gt;Did I mess up something about a language here, or am I missing a safety check? I&amp;rsquo;ll happily take pull
requests for new languages:
&lt;a href=&#34;https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders2.js&#34;&gt;blog source&lt;/a&gt;. Just
pick an existing language, edit the name and values, and &amp;ldquo;copy to clipboard&amp;rdquo; to
build your own language data structure. Send it to me in a PR and I&amp;rsquo;ll include
it along with a thanks on the page.&lt;/p&gt;

&lt;div ng-show=&#34;showRealName&#34;&gt;
&lt;span&gt;Select Language:
&lt;select ng-options=&#34;lang.name for lang in allLanguages&#34; ng-model=&#34;selectedLang&#34;&gt;&lt;/select&gt;
&lt;button ng-click=&#34;copyToClipboard(selectedLang)&#34;&gt;Copy Changes to Clipboard&lt;/button&gt;
&lt;/span&gt;
&lt;span&gt;&lt;input ng-model=&#34;selectedLang.name&#34;&gt;&lt;/input&gt;&lt;/span&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt;&lt;th&gt;Option&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td style=&#34;background-color:{{scoreClass(score(selectedLang[check.key]))}} &#34;&gt;
{{ check.name }}: {{score(selectedLang[check.key]) }}
&lt;/td&gt;
&lt;td&gt;
&lt;select ng-options=&#34;enforcedNice(e) for e in enforcedTypes&#34; ng-model=&#34;selectedLang[check.key].enforced&#34;&gt;&lt;/select&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>