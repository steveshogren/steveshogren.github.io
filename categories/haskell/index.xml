<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haskell on deliberate software</title>
    <link>https://deliberate-software.com/categories/haskell/</link>
    <description>Recent content in haskell on deliberate software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Apr 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://deliberate-software.com/categories/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Wrangling State In Haskell</title>
      <link>https://deliberate-software.com/haskell-state/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://deliberate-software.com/haskell-state/</guid>
      <description>Part 2 of my series &amp;ldquo;Wrangling State&amp;rdquo;. Part 1 Wrangling State In Clojure
Haskell is a pure language, so you can only deal with application state by passing parameters to functions. It is possible to pass parameters more conveniently, but ultimately, every parameter needs to be passed.
Here is a simple application for logging a timestamp to a file.
First, Pass As Parameter:
loadFile :: Filename -&amp;gt; IO String loadFile fileName = BS.</description>
    </item>
    
    <item>
      <title>Haskell is the Dark Souls of Programming</title>
      <link>https://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</guid>
      <description>Please don&amp;rsquo;t hit me, Haskell does a great job of that already.
I love Haskell for the same reasons I love Dark Souls. Fantastic and inscrutable lore, a great combat type system, a cliff-wall difficulty curve, and unending punishment.
I want to collect some statistics from the GitHub API.
Step One - Stack I download stack and start a project:
&amp;gt; cd /home/jack/programming &amp;amp;&amp;amp; stack new github-stats &amp;amp;&amp;amp; cd github-stats Downloading template &amp;#34;new-template&amp;#34; to create project &amp;#34;github-stats&amp;#34; in github-stats/ .</description>
    </item>
    
    <item>
      <title>Programming Language Safety Score Mark 2</title>
      <link>https://deliberate-software.com/safety-rank-part-2/</link>
      <pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://deliberate-software.com/safety-rank-part-2/</guid>
      <description>I want to make a model that predicts bugs.
I previously wrote a table for scoring language safety: Programming Language Safety Score, but it was extremely time consuming to score new languages or make modifications.
Simplify, Simplify After being told I was overfitting the data, I&amp;rsquo;ve attempted to clean up by simply checking if each category is enforced, possible, or impossible. I score each as either 1 (language enforced), 0 (possible, but you have to remember to do it), or -1 (impossible).</description>
    </item>
    
  </channel>
</rss>