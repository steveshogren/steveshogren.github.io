<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csharp on Deliberate Software</title>
    <link>http://deliberate-software.com/categories/csharp/</link>
    <description>Recent content in Csharp on Deliberate Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://deliberate-software.com/categories/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>OO-Design Part 2: Anemic Domain Models Are Healthy</title>
      <link>http://deliberate-software.com/anemic-domain-model/</link>
      <pubDate>Wed, 16 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/anemic-domain-model/</guid>
      <description>

&lt;p&gt;Part 2 of the series &lt;a href=&#34;http://deliberate-software.com/categories/oo-design/&#34;&gt;OO-Design&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The Anemic Domain Model is often quoted as an anti-pattern in Domain-Driven
Design. Martin Fowler goes so far as to term the alternative a
&lt;a href=&#34;http://www.martinfowler.com/bliki/AnemicDomainModel.html&#34;&gt;&amp;ldquo;rich domain model&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A rich domain model makes perfect sense until you attempt to write your first
unit test. You discover that rich domain models are very hard to test. Not only
that, but most examples of unit-testing use Anemic Domain Models! Do you really
have to pick between good testing and good design?&lt;/p&gt;

&lt;h2 id=&#34;let-s-talk-about-purity:2fa9b95203cb46cce1debbec40ac0550&#34;&gt;Let&amp;rsquo;s Talk About Purity&lt;/h2&gt;

&lt;p&gt;Functions are considered &lt;strong&gt;pure&lt;/strong&gt; if they produce the same output when given the
same input. Addition is a pure function. We expect &lt;code&gt;add(1,1)&lt;/code&gt; will always
produce &lt;code&gt;2&lt;/code&gt;. Pure functions are the easiest to test. The more logic you have
in pure functions, the easier your code is to test.&lt;/p&gt;

&lt;p&gt;Consider which of the following is easier to test. A &lt;strong&gt;pure function&lt;/strong&gt; with the
signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;GameState movePlayerNorth(GameState g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or an &lt;strong&gt;impure function&lt;/strong&gt; with the signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void movePlayerNorth()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first function has explicit inputs and outputs. The second function has
implicit, hidden state. While the &lt;code&gt;void&lt;/code&gt; function is easier to &lt;em&gt;call&lt;/em&gt;, it
impurity makes it much harder to &lt;em&gt;test&lt;/em&gt;. Testing a impure function requires
implicit state to be setup before each test. Since GameState is encapsulated,
you would need to either expose it (breaking encapsulation) or call dozens of
methods to get it into the correct state for your test!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Encapsulation is &lt;del&gt;a rich domain model&lt;/del&gt; &lt;strong&gt;impure&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The point of encapsulation is to hide state from the caller; it is impure by
definition. Impure functions require global or class-level state to operate.&lt;/p&gt;

&lt;p&gt;Pure functions have been maligned as a bad design. Purity has been given nasty
sounding names like &amp;ldquo;anemic domain model&amp;rdquo; or &amp;ldquo;exposed state&amp;rdquo;. In reality, there
is nothing wrong with pure programming, it produces good designs that are easy
to understand and test.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Purity is a good design!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We should strive for purity as much as possible. In most languages, purity is an
ideal to strive for, not a goal that can ever be fully achieved. Language
features like exceptions and null will always prevent complete purity.&lt;/p&gt;

&lt;p&gt;Purity in object-oriented languages is always on a continuum. Most codebases
have a variety of functions: some pure, some impure. On the one side you have
rich domain models with completely encapsulated state and void methods. On the
other side you have easily-tested code with pure functions and separate data
structures.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Encapsulation (Impure) |------------------------| Pure functions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need or desire testability, strive to put as much logic as possible
inside pure functions. Avoid encapsulated state: put all state in data
structures with all public fields. Strive to make your codebase as pure as
possible.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OO-Design Part 1: Increasing Reuse With Noun Interfaces</title>
      <link>http://deliberate-software.com/better-oo-design/</link>
      <pubDate>Mon, 31 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/better-oo-design/</guid>
      <description>

&lt;p&gt;Part 1 of the series &lt;a href=&#34;http://deliberate-software.com/categories/oo-design/&#34;&gt;OO-Design&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The SOLID patterns are not enough to design a reusable and testable code base.
Two concrete additions can significantly improve your codebase, while
maintaining the SOLID principals.&lt;/p&gt;

&lt;p&gt;The suggestions here do not run counter to traditional SOLID designs, they
enhance them. SOLID is a fine place to start, but it lacks a critical half of
good design: polymorphic data. We&amp;rsquo;ve found polymorphic data is far more common
than polymorphic behavior, so programs designed without that concept often are
far larger than they need to be.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Appropriate application of these concepts will reduce code and allow for easier unit testing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;terms:0dfbdcea5000bc0e2a150299cf5611d6&#34;&gt;Terms&lt;/h2&gt;

&lt;p&gt;For this post, let&amp;rsquo;s distinguish between &lt;em&gt;verb classes&lt;/em&gt; and &lt;em&gt;noun classes&lt;/em&gt;. Unit
testing often drives us to separate classes into data structures (the nouns) or
behavior classes, (the verbs).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Noun class&lt;/strong&gt; - has fields and properties filled with data, perhaps from an ORM.

&lt;ul&gt;
&lt;li&gt;Example: A &lt;code&gt;Contact&lt;/code&gt; class with a name, billing and shipping addresses,
a birthday, and a credit card.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verb class&lt;/strong&gt; - has functions and methods. Verb classes might have fields or
properties, but usually those only contain other verb classes that are
needed to compose work.

&lt;ul&gt;
&lt;li&gt;Example: A &lt;code&gt;CustomerBiller&lt;/code&gt; class that creates an invoice and sends it
to an address. Only needs a billing and shipping address and an amount.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Noun interface&lt;/strong&gt; - an interface put on a noun class. Used to allow multiple
nouns to be passed to a single verb. A very common use-case in business
applications.

&lt;ul&gt;
&lt;li&gt;Example: &lt;code&gt;ICustomer&lt;/code&gt; interface with a billing and shipping address
only. Can be used by &lt;code&gt;Contact&lt;/code&gt;, &lt;code&gt;Company&lt;/code&gt;, &lt;code&gt;Government&lt;/code&gt;,
or any other entity that might like to buy something.&lt;/li&gt;
&lt;li&gt;Allows a verb to operate on many types of data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verb interface&lt;/strong&gt; - an interface put on a verb class. Allows polymorphic
behavior. Less common than noun interfaces.

&lt;ul&gt;
&lt;li&gt;Example: &lt;code&gt;IChargeCustomer&lt;/code&gt; interface that allows different kinds of
charging: one that generates invoices, one that charges credit cards, etc.&lt;/li&gt;
&lt;li&gt;Allows several types of verbs to be grouped together&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;two-changes:0dfbdcea5000bc0e2a150299cf5611d6&#34;&gt;Two Changes&lt;/h2&gt;

&lt;p&gt;Two suggestions will guide your codebase to be easier to reuse and test.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extract Noun Interfaces&lt;/strong&gt; - Work to determine any missing noun interfaces.
This inversion allows for easier reuse. Any data structure that &amp;ldquo;fits&amp;rdquo; can
re-use that behavior.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rely on Verb Functions Not Verb Interfaces&lt;/strong&gt; - Replace Dependency
Injected verb interfaces with function signatures, explained in the
&lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;SimpleMock&lt;/a&gt;
guide. By relying on the function signature as the default unit of
abstraction, we remove test-only interfaces. This allows the dependent code to
have only the functions it needs, rather than everything from the interface.
When you really need polymorphic behavior, use a verb interface. Only use
verb interfaces for polymorphic behavior, not for unit test mocking.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is an example of the patterns in C#, but it also works in Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// Verb Class
public class Notifier {
    public void Broadcast(string type, Type from, int id) { /* Broadcast code here ...*/ }
}

// Noun Interface
public interface SalesLead {
    boolean IsCustomer {get; set;}
    DateTime ConversionDate {set;}
    int Id {get;}
    Type From {get;}
}

public class User : SalesLead { /* User code here ... */ }
public class Company : SalesLead { /* Contact code here ... */ }
public class Government : SalesLead { /* Government code here ... */ }

// Verb Class
public class SalesRepresentative {
    // Rely on Verb Functions Not Verb Interfaces
    internal Action&amp;lt;string, Type, int&amp;gt; broadcast = new Notifier().Broadcast;

    // Extract Noun Interfaces
    public void ConvertToCustomer(SalesLead lead) {
      if(lead.IsCustomer) {
          return;
      }
      lead.IsCustomer = true;
      lead.ConversionDate = DateTime.Now;
      broadcast(&amp;quot;CustomerConverted&amp;quot;, lead.From, lead.Id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this inversion of nouns and verbs seems counter to traditional OOP advice,
it is actually a very object-oriented design. Noun Interfaces allow for
polymorphic nouns. Polymorphic nouns allow are better suited to model a domain.&lt;/p&gt;

&lt;p&gt;In our example, a &lt;code&gt;User&lt;/code&gt; should not know how to convert itself to a
&lt;code&gt;Customer&lt;/code&gt;. A &lt;code&gt;User&lt;/code&gt; would not know they had to broadcast their updated
status, or that the date is important to record. To prove it models the domain
more effectively, notice how it even follows a more English pattern: &amp;ldquo;tell the
Sales Representative to convert this User&amp;rdquo;. This is much closer than the
typical: &amp;ldquo;User convert yourself To Customer&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Later, when we want to convert an Employee, a Company, or a Government, we know
what sort of interface is required to make them into a SalesLead that can be
converted. By relying on the interface, we are able to restrict
SalesRepresentative to only have access to the data necessary to convert.&lt;/p&gt;

&lt;h1 id=&#34;case-study:0dfbdcea5000bc0e2a150299cf5611d6&#34;&gt;Case Study&lt;/h1&gt;

&lt;p&gt;We recently examined a 1.3 million line codebase used to collect and track
interest rates and payments from a user. We found only four uses of verb
interfaces for polymorphic behavior. On the other hand, there were hundreds of
noun interfaces used to allow multiple shapes of data to be acted on by the
same function.&lt;/p&gt;

&lt;p&gt;An obvious example is &lt;code&gt;IHaveIdentity&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface IHaveIdentity {
    Guid Id {get;}
    string Name {get;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tiny, simple noun interface enables incredible re-use. We found the
&lt;code&gt;IHaveIdentity&lt;/code&gt; noun interface on many of our noun classes. It is used by
hundreds of verb classes throughout the codebase. Verbs like
&lt;code&gt;MakeDropDownList&lt;/code&gt;, &lt;code&gt;QueryById&lt;/code&gt;, &lt;code&gt;QueryNamesMatching&lt;/code&gt;, and
&lt;code&gt;CreateAuditTrail&lt;/code&gt;. Those verb classes were easily reused, because any new
noun class that fits the noun interface works automatically! If we had tried to
put interfaces on those verbs, we&amp;rsquo;d have a lot of classes with no behavior other
than just delegating to another class.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:0dfbdcea5000bc0e2a150299cf5611d6&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;These patterns enable significant reuse of functionality. By defaulting to noun
interfaces, you will find most of your verb classes can be re-used without any
change. When you need actual polymorphic behavior, use a verb interface. For the
more common case of unit test behavior replacement, the
&lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;SimpleMock&lt;/a&gt; pattern makes for an easy way to
keep your codebase clean and best model the domain.&lt;/p&gt;

&lt;p&gt;Next in the series: &lt;a href=&#34;http://deliberate-software.com/anemic-domain-model/&#34;&gt;OO-Design Part 2: Anemic Domain Models Are Healthy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modern Dependency Injection</title>
      <link>http://deliberate-software.com/modern-di/</link>
      <pubDate>Sat, 11 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/modern-di/</guid>
      <description>

&lt;p&gt;Dependency Injection can be greatly simplified while retaining all of its power.&lt;/p&gt;

&lt;h3 id=&#34;the-unnecessary-boilerplate:c289f8e530077f15501b76fa92fff59a&#34;&gt;The Unnecessary Boilerplate&lt;/h3&gt;

&lt;p&gt;Injection of an interface through the constructor is a common way to replace a
dependency for unit-test mocking. Unfortunately, it is an extremely verbose
pattern.&lt;/p&gt;

&lt;p&gt;Look how much boilerplate is needed just to mock out a call to
&lt;code&gt;DateTime.Now&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 1 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 2 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 3 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 4 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 5 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 6 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 7 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 8 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 9 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;10 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;11 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;12 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;readonly&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;13 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;14 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;15 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;16 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICurrentTime&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;17 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;18 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;19 &lt;/span&gt;&lt;span class=&#34;hll&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;20 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;21 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GetCurrentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;22 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;23 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We learned to mock this way because Java did not have lambdas at the time the
pattern was invented! Now that both Java and C# have lambdas, the existing DI
pattern can be improved.&lt;/p&gt;

&lt;h3 id=&#34;for-unit-test-mocking:c289f8e530077f15501b76fa92fff59a&#34;&gt;For Unit Test Mocking&lt;/h3&gt;

&lt;p&gt;Thanks to the power of lambdas, the previously highlighted lines (1-19) can be
removed!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt;1 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;2 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;3 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;4 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;5 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;6 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;7 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Much better! The code is easier to read, understand, and &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;mock in a unit test&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;for-polymorphism:c289f8e530077f15501b76fa92fff59a&#34;&gt;For Polymorphism&lt;/h3&gt;

&lt;p&gt;If you still need to replace the function with another for polymorphic dispatch,
use constructor injection of just the lambda. Be forewarned, you probably need
this much less than you think!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;lineno&#34;&gt; 1 &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Formatter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 2 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;internal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 3 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 4 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 5 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 6 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Formatter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DateTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 7 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 8 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt; 9 &lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;10 &lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;11 &lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;quot;{0}: {1}&amp;quot;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;currentTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;12 &lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;lineno&#34;&gt;13 &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;If you are heavily invested in unit-testing, you might find you need very little
actual interface polymorphism. To see where you really use interface
polymorphism, find the interfaces in your codebase only have a single concrete
class in production. Each interface with a single concrete class is test-only
boilerplate that can safely replaced with a lambda!&lt;/p&gt;

&lt;p&gt;For more examples, &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;check out SimpleMock!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SimpleMock: Language Agnostic Unit Test Mocking</title>
      <link>http://deliberate-software.com/simplemock-unit-test-mocking/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/simplemock-unit-test-mocking/</guid>
      <description>

&lt;p&gt;SimpleMock is a pattern for reducing TDD damage. You can use the pattern to
organize your testing code without mocking or complicated dependency injection.&lt;/p&gt;

&lt;p&gt;SimpleMock works in any language with closures that can be passed around by
reference, so off the top of my head: C#, Java, F#, Scala, PHP, C++, Ruby, and
Python. I&amp;rsquo;m sure you can think of others.&lt;/p&gt;

&lt;h2 id=&#34;example:442bb35a3947650665613cec7b90f820&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;Here is a brief (if a bit silly) example of the final pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class LineCounter {
    internal Func&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; _readLines = File.ReadLines;

    public string CountLines(string filename) {
        return _readLines(filename).Count();
    }
}

/// Test Code
[TestCase]
public void TestLineCounter () {
    var sut = new LineCounter();
    // &amp;quot;SimpleMock&amp;quot; of File.ReadLines
    sut._readLines = (string x) =&amp;gt; new List&amp;lt;string&amp;gt;{&amp;quot;test&amp;quot;, &amp;quot;that&amp;quot;};

    var result = sut.CountLines(&amp;quot;test&amp;quot;);

    Assert.AreEqual(2, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;benefits:442bb35a3947650665613cec7b90f820&#34;&gt;Benefits&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Reduced boilerplate&lt;/li&gt;
&lt;li&gt;Saves interfaces for real polymorphism&lt;/li&gt;
&lt;li&gt;Simplifies test code&lt;/li&gt;
&lt;li&gt;Reduces testing concerns in production code&lt;/li&gt;
&lt;li&gt;Removes need for fragile IoC containers&lt;/li&gt;
&lt;li&gt;Encourages better abstraction design&lt;/li&gt;
&lt;li&gt;Can convert one class at a time!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The SimpleMock pattern promotes a better design of your abstractions and simpler
tests. The pattern also reduces boilerplate and the pollution of your production
code with testing concerns.&lt;/p&gt;

&lt;p&gt;If you aren&amp;rsquo;t familiar with the normal pattern of unit test mocking using
interfaces, dependency injection, and mock libraries, scroll down to &amp;ldquo;The
Non-SimpleMock Way&amp;rdquo; at the end of the post.&lt;/p&gt;

&lt;h2 id=&#34;simplemock-pattern:442bb35a3947650665613cec7b90f820&#34;&gt;SimpleMock Pattern&lt;/h2&gt;

&lt;p&gt;The SimpleMock pattern is aptly named.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Replace Test-Only Interfaces With Functions&lt;/li&gt;
&lt;li&gt;Define Dependencies Inline&lt;/li&gt;
&lt;li&gt;Write Better Abstractions&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;step-one-replace-test-only-interfaces-with-functions:442bb35a3947650665613cec7b90f820&#34;&gt;Step One: Replace Test-Only Interfaces With Functions&lt;/h2&gt;

&lt;p&gt;My examples are in C# because that is what I got paid to write today - it is
freshest in memory. C# has an incredible ability to create and pass around
lambdas and function references. Here is an example of using functions instead
of interfaces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}
public class Translator {
    private Func&amp;lt;DateTime&amp;gt; _getCurrentTime;

    public Translator() : this(new CurrentTime().GetCurrentTime) {}

    public Translator(Func&amp;lt;DateTime&amp;gt; getCurrentTime) {
        this._getCurrentTime = getCurrentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;

    var sut = new Translator(() =&amp;gt; now);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The test code is quite simple! No longer do we need the dependency on third
party mocking libraries, or the relatively complicated setup logic. Instead we
can simply inject the lambda at runtime, replacing that pointer. We didn&amp;rsquo;t need
the whole interface, really we just needed the simple signature of the function.&lt;/p&gt;

&lt;h2 id=&#34;step-2-define-dependencies-inline:442bb35a3947650665613cec7b90f820&#34;&gt;Step 2: Define Dependencies Inline&lt;/h2&gt;

&lt;p&gt;We can take it even a step further. Why use constructor injection at all? Since
all we really want is a single mutable dispatch table row, why not just make it
that way?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Translator {
    internal Func&amp;lt;DateTime&amp;gt; _getCurrentTime = new CurrentTime().GetCurrentTime;

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;
    var sut = new Translator();
    sut._getCurrentTime = () =&amp;gt; now;

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve cleaned up our nasty multi-line indirection into a single dispatch line.
&amp;ldquo;Go to definition&amp;rdquo; now takes me to the actual line with the actual called
function. We&amp;rsquo;ve replaced a dependency on a class based interface with a function
signature. The function signature &lt;em&gt;is&lt;/em&gt; the interface!&lt;/p&gt;

&lt;p&gt;You probably noticed we have lost something with this final version. We have
lost the ability to inject polymorphic behavior through the constructor. If you
need it, simply go back to injecting the interface in the constructor or by
passing it into the function itself. In practice, I have found this is needed
very rarely, making the SimpleMock pattern a better tool to reach for first.&lt;/p&gt;

&lt;h2 id=&#34;step-3-write-better-abstractions:442bb35a3947650665613cec7b90f820&#34;&gt;Step 3: Write Better Abstractions&lt;/h2&gt;

&lt;p&gt;Lastly, SimpleMock actually promotes better designs. For example, a coworker was
writing some tests today and ran into a complicated situation. Take the
following sanitized code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Action&amp;lt;Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Action&amp;lt;Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public void IgnoreAndRemoveThings(Thing t1, Thing t2) {
        ignoreElements(t1);
        ignoreElements(t2);
        removeIgnoredElements(t1);
        removeIgnoredElements(t2);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would you check that each section was called? Our naive solution was a
complicated lambda with a &amp;ldquo;timesCalled&amp;rdquo; counter and an if statement to assert
against each argument, but it turns nasty quickly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;/// Nasty test code
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();

    var ignoredCalledTimes = 0;
    sut.ignoreElements = (t) =&amp;gt; {
        ignoredCalledTimes++;
        if (ignoredCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };
    var removedCalledTimes = 0;
    sut.removeIgnoredElements = (t) =&amp;gt; {
        removedCalledTimes++;
        if (removedCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };

    var t1 = new Thing();
    var t2 = new Thing();

    var result = sut.IgnoreAndRemoveThings(t1, t2);
    Assert.AreEqual(2, removedCalledTimes);
    Assert.AreEqual(2, ignoredCalledTimes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yuck! The test is an absolute catastrophe. I see a mess of mixed concerns.
Conditionals?! In a test?! Unconscionable.&lt;/p&gt;

&lt;p&gt;In situations like this, we have two easy options. Option one is to just use
a third party mocking library, replacing the functions from inside the test
code. This gives us access to all the sophisticated mocking tools available.&lt;/p&gt;

&lt;p&gt;My preferred option is seeking to decomplect the production code by using better
abstractions.&lt;/p&gt;

&lt;p&gt;I have found that strong reliance of mocking libraries enables worse designs.
Consider the code, what makes it so hard to test? Not knowing which element is
called when, doing the same work on two parameters, and reference mutation all
make this a poor abstraction. Why not simplify?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Func&amp;lt;Thing, Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Func&amp;lt;Thing, Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public List&amp;lt;Thing&amp;gt; IgnoreAndRemoveThings(List&amp;lt;Thing&amp;gt; ts) {
        return ts.Select(t =&amp;gt; removeIgnoredElements(ignoreElements(t)));
    }
}

/// Simpler test
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();
    var expected = new Thing();
    var ts = new List&amp;lt;Thing&amp;gt;{new Thing()};

    sut.ignoreElements = (t) =&amp;gt; new Thing();

    sut.removeIgnoredElements = (t) =&amp;gt; {
        Assert.AreEqual(t, sut.ignoreElements(t));
        return expected;
    };

    var result = sut.IgnoreAndRemoveThings(ts);

    Assert.AreEqual(expected, result.First())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much better! Yes, we had to change a few signatures. We get the same work done,
but now the code is actually a lot more useful. Our test code is comparable with
anything you&amp;rsquo;d find using a mocking library. I am absolutely okay with using a
mocking library when needed, but I always carefully consider my abstractions and
design first.&lt;/p&gt;

&lt;p&gt;If mocking libraries and IoC containers are the chainsaws of the testing world,
then SimpleMock is the garden shears. Sometimes the chainsaw is the only tool
for the job, and that is fine. But for most work around the yard, you can leave
the chainsaw in the shed.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:442bb35a3947650665613cec7b90f820&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I’ve shown how you can really simplify your code with SimpleMock. The dispatch
row is clear and easy to read. We have removed some third party mocking
dependencies. You can remove a lot of the boilerplate &amp;ldquo;for making it more
testable&amp;rdquo; from your code. The test code is greatly simplified, and injection a
breeze. The result: much simpler code, just as easy to test.&lt;/p&gt;

&lt;p&gt;Thanks to Shuwei Chen for helping me put this together!&lt;/p&gt;

&lt;h2 id=&#34;the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;The Non-SimpleMock Way&lt;/h2&gt;

&lt;p&gt;If you are familiar with unit test mocking with interfaces, this part is
probably boring. Feel free to skip.&lt;/p&gt;

&lt;p&gt;The traditional way of performing C# unit test mocking involves dependency
injection and interface mocking using a mocking library. For dependency
injection, it is common to use a tool like Ninject or hand-rolled constructor
injection. For mocking, a library like Moq or Rhino Mocks is standard. Here is
an example of a class and its testing code without any business logic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ICurrentTime {
    DateTime GetCurrentTime();
}

public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}

public class Translator {
    private readonly ICurrentTime ct;

    public Translator() : this(new CurrentTime()) {}

    public Translator(ICurrentTime currentTime) {
        this.ct = currentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, ct.GetCurrentTime().ToString(), input);
    }
}

/// Test Code with Moq
[TestCase]
public void TestCurrentTimeTranslator () {
    var rightNow = DateTime.Now;
    var mock = new Mock&amp;lt;ICurrentTime&amp;gt;();

    mock.Setup(a=&amp;gt;a.GetCurrentTime()).Returns(rightNow);

    var sut = new Translator(mock.Object);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(rightNow.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve done much C# unit testing, this should look familiar. We want to
inject some code that is potentially long-running or dynamic. We put that code
into a class, add an interface, then inject that interface into the class we
want to test. To test it, we mock the interface, creating a different concrete
class at test runtime which implements that interface. We can setup that mock to
respond with anything, which we use for assertions.&lt;/p&gt;

&lt;h2 id=&#34;what-s-wrong-with-the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;What&amp;rsquo;s Wrong with the Non-SimpleMock Way?&lt;/h2&gt;

&lt;p&gt;The first problem is we have created a whole interface just for testing.
Interfaces are for polymorphism, but we don&amp;rsquo;t really need polymorphism for this
class. We simply want to mock it. The constructor injection is also test code
polluting our business logic.&lt;/p&gt;

&lt;p&gt;What we have done is create a very small and primitive dispatch table. The
table has one row: something that has a function with the signature of &lt;code&gt;() -&amp;gt; DateTime&lt;/code&gt; or, as it is known in C#: &lt;code&gt;Func&amp;lt;DateTime&amp;gt;&lt;/code&gt;.  We will need to make
this primitive dispatch table for every single mock in every single class we
wish to test. That&amp;rsquo;s a lot of boilerplate!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming Language Safety Score Mark 2</title>
      <link>http://deliberate-software.com/safety-rank-part-2/</link>
      <pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/safety-rank-part-2/</guid>
      <description>

&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://deliberate-software.com/javascripts/sliders2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I want to make a model that predicts bugs.&lt;/p&gt;

&lt;p&gt;I previously wrote a table for scoring language safety:
&lt;a href=&#34;http://deliberate-software.com/programming-language-safety-algorithm&#34;&gt;Programming Language Safety Score&lt;/a&gt;,
but it was extremely time consuming to score new languages or make modifications.&lt;/p&gt;

&lt;h2 id=&#34;simplify-simplify:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Simplify, Simplify&lt;/h2&gt;

&lt;p&gt;After being told I was &lt;a href=&#34;https://en.wikipedia.org/wiki/Overfitting&#34;&gt;overfitting&lt;/a&gt;
the data, I&amp;rsquo;ve attempted to clean up by simply checking if each category is
enforced, possible, or impossible. I score each as either 1 (language enforced),
0 (possible, but you have to remember to do it), or -1 (impossible). When the
magnitudes of the new model are compared with the previous model, they come out
very similar. The shape of the curve pretty much stays the same, which I was
told indicates that the character count weighting was a variable that didn&amp;rsquo;t
matter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/rplot.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The code I used to generate the plot and normalize the scores can be found here:
&lt;a href=&#34;https://github.com/steveshogren/datasciencecoursera/blob/817dec79e36b6e9a6c5a8fd5700aff7cc394b9d4/scoreplot.R&#34;&gt;scorePlot.R&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;safety-definitions:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Safety Definitions&lt;/h2&gt;

&lt;p&gt;A definition of the safety checks is as follows:&lt;/p&gt;

&lt;div ng-app=&#34;TableApp2&#34;&gt;
&lt;div ng-controller=&#34;TableCtrl&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td&gt;{{ check.name }} &lt;/td&gt;
&lt;td&gt; {{ check.desc }}  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

The new scores are shown here, with a lot more languages added in:

&lt;p class=&#34;lead&#34;&gt;
&lt;div style=&#34;overflow-x:scroll&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;
&lt;th&gt;Safety Check&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[0]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[1]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[2]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[3]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34; score-row name=&#34;check.name&#34; row-key=&#34;check.key&#34;&gt;&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Totals&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ lang }}
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Magnitude&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ percentageTotals(lang) }}%
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Current Languages:
&lt;span ng-repeat=&#34;lang in allLanguages&#34;&gt;
{{ getName(lang) }}: {{ allLangTotals[$index] }},
&lt;/select&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-what-s-the-point:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;So, What&amp;rsquo;s the Point?&lt;/h2&gt;

&lt;p&gt;To see how this model corresponds with data in the real world, I used the GitHub
API to query for the number of bugs created in repositories with more than 15
forks created in a span from 2011 to 2015. Commits were counted by summing the
commit counts of all contributors.&lt;/p&gt;

&lt;p&gt;I decided to rely on the count of commits as a standard for a unit of work. My
assumption was that across fifty different projects, the commit sizes would
average out. Once the unit of work was decided on, I wanted to find the ratio of
bugs per commit for each language.&lt;/p&gt;

&lt;p&gt;I collected the ratio of bugs logged per commit for each repository, and after
grouping by primary language, removed the top and bottom 25% using the
bug/commit ratio, which is a common practice in statistics to help find a more
accurate average. I summed the bugs and commits of those remaining repositories
grouped by language, finding a total average bug/commit ratio for each language
grouping. Here is that data, sorted by safety score.&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Bugs&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Bug/Commits&lt;/th&gt;
&lt;tr ng-repeat=&#34;lang in languageRatios&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.bugs }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getBugsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Here are the languages sorted by safety score with bug/commit ratios:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/errorChart.jpg&#34;&gt;&lt;/img&gt;
&lt;img src=&#34;http://deliberate-software.com/images/bugsAverage.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;I took the magnitude of the safety scores and the bug/commit ratios. After
inverting the safety scores, I overlaid them both onto a single graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/bothMags.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Immediately it is obvious that Ruby, Python, PHP, and Clojure all seem to strongly
buck the trend, but otherwise the languages follow a pretty consistent slope
down in bugs. Taking the correlation gives a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient&#34;&gt;correlation coefficient&lt;/a&gt;
of .55&lt;/p&gt;

&lt;h2 id=&#34;what-about-unit-tests:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;What About Unit Tests?&lt;/h2&gt;

&lt;p&gt;Thinking that Ruby, Clojure, PHP, and Python might not correlate well due to some
other factor, I collected data on how many tests each repository had. I counted
the number of files containing &amp;ldquo;test&amp;rdquo; or &amp;ldquo;spec&amp;rdquo;, which gave the following,
sorted by tests per commit:&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Tests&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Tests/Commits&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;lang in sorter(languageRatios)&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.test }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getTestsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;PHP, Python, and Ruby all have a higher then average number of tests, but
Clojure does not. Additionally, Go, Scala, and Java all also have a higher than
average number of tests, yet they score relatively average in bugs/commit.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In conclusion, the current safety model I have proposed seems to account for a
moderate reduction in bugs per commit across the sampled languages, but is not
the only factor. It currently is unable to account for a significantly lower
than expected bug count in Ruby and Clojure.&lt;/p&gt;

&lt;h2 id=&#34;special-thanks:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Special Thanks&lt;/h2&gt;

&lt;p&gt;Special thanks to (in alphabetical order):
&lt;a href=&#34;https://twitter.com/traffichazard/&#34;&gt;Patrick Boe&lt;/a&gt; (Haskell, Sniff Test),
&lt;a href=&#34;http://asymmetrical-view.com/&#34;&gt;Kyle Burton&lt;/a&gt; (General Advice),
Nils Creque (Listening Board),
Max Haley (Python, Ruby, Teaching me how to math),
&lt;a href=&#34;https://github.com/danielmiladinov&#34;&gt;Daniel Miladinov&lt;/a&gt; (Java, Scala, Morale Support),
Keith O&amp;rsquo;Brien (Ruby and JS),
&lt;a href=&#34;https://github.com/arlaneenalra&#34;&gt;Chris Salch&lt;/a&gt; (CoffeeScript and JS),
and &lt;a href=&#34;https://github.com/timvisher&#34;&gt;Tim Visher&lt;/a&gt; (Clojure).&lt;/p&gt;

&lt;p&gt;Additional thanks to the posters on
&lt;a href=&#34;https://www.reddit.com/r/rust/comments/3egx49/language_safety_score_mark_2/&#34;&gt;/r/rust&lt;/a&gt;,
including &lt;a href=&#34;https://www.reddit.com/user/notriddle&#34;&gt;/u/notriddle&lt;/a&gt;,
&lt;a href=&#34;https://www.reddit.com/user/killercup&#34;&gt;/u/killercup&lt;/a&gt;, and
&lt;a href=&#34;https://www.reddit.com/user/diegobernardes&#34;&gt;/u/diegobernardes&lt;/a&gt; who put together the Rust score.&lt;/p&gt;

&lt;h2 id=&#34;complaints-department:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Complaints Department&lt;/h2&gt;

&lt;p&gt;Did I mess up something about a language here, or am I missing a safety check? I&amp;rsquo;ll happily take pull
requests for new languages:
&lt;a href=&#34;https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders2.js&#34;&gt;blog source&lt;/a&gt;. Just
pick an existing language, edit the name and values, and &amp;ldquo;copy to clipboard&amp;rdquo; to
build your own language data structure. Send it to me in a PR and I&amp;rsquo;ll include
it along with a thanks on the page.&lt;/p&gt;

&lt;div ng-show=&#34;showRealName&#34;&gt;
&lt;span&gt;Select Language:
&lt;select ng-options=&#34;lang.name for lang in allLanguages&#34; ng-model=&#34;selectedLang&#34;&gt;&lt;/select&gt;
&lt;button ng-click=&#34;copyToClipboard(selectedLang)&#34;&gt;Copy Changes to Clipboard&lt;/button&gt;
&lt;/span&gt;
&lt;span&gt;&lt;input ng-model=&#34;selectedLang.name&#34;&gt;&lt;/input&gt;&lt;/span&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt;&lt;th&gt;Option&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td style=&#34;background-color:{{scoreClass(score(selectedLang[check.key]))}} &#34;&gt;
{{ check.name }}: {{score(selectedLang[check.key]) }}
&lt;/td&gt;
&lt;td&gt;
&lt;select ng-options=&#34;enforcedNice(e) for e in enforcedTypes&#34; ng-model=&#34;selectedLang[check.key].enforced&#34;&gt;&lt;/select&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Case Study: Superior Domain Modeling in F#</title>
      <link>http://deliberate-software.com/pattern-matching-case-study/</link>
      <pubDate>Sat, 14 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/pattern-matching-case-study/</guid>
      <description>&lt;p&gt;Domain modeling in F# is significantly easier and safer than with the
traditional .NET languages. This is because of the increased safety of
pattern matching and the expressiveness of discriminated unions. These
concepts are not in C# or VB.NET, and therefore bring a new tool to
the table.&lt;/p&gt;

&lt;p&gt;To illustrate this, I found some old code I&amp;rsquo;d written to interact with
a legacy system. The system uses many single enums on a record to keep
track of statuses. When one changes, it can cause others to change as
well.&lt;/p&gt;

&lt;p&gt;Here is a typical function that combines two enums to recalculate a
third.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static PositionType GetPositionType (MovementType movementType, ApplyToParty applyToParty)
{
    if ((movementType == MovementType.Deliver &amp;amp;&amp;amp; applyToParty == ApplyToParty.Principal)
        || (movementType == MovementType.Return &amp;amp;&amp;amp; applyToParty == ApplyToParty.Counterparty))
        return PositionType.Held;
    if ((movementType == MovementType.Return &amp;amp;&amp;amp; applyToParty == ApplyToParty.Principal)
        || (movementType == MovementType.Deliver &amp;amp;&amp;amp; applyToParty == ApplyToParty.Counterparty))
        return PositionType.Posted;

    return PositionType.Undefined;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With some regularity, new records are added to these types of enums,
causing a dangerous search and update across the system fixing all the
if/else or switch/case statements.&lt;/p&gt;

&lt;p&gt;Right off the bat, pattern matching is a huge win here, taking a hard
to comprehend function and making the domain concepts clear.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let GetPositionType = function
    | Deliver, Principal | Return, Counterparty -&amp;gt; Held
    | Return, Principal | Deliver, Counterparty -&amp;gt; Posted
    | MovementType.Undefined, _ | _, ApplyToParty.Undefined -&amp;gt; PositionType.Undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we add a new status to any of these, we will get a compiler warning
in every place letting us know. If that alone was the win, we&amp;rsquo;d be
still be ahead by a lot. The domain is so clear here, I can print this
code out and hand it to my BA to ensure the logic is correct.&lt;/p&gt;

&lt;p&gt;Next though, this got me thinking. Why does this set of three enums
have to be calculated? Why are they even separate? Ah, of course,
right now they are stored in the database and ORM objects, each with a
separate field and set of enum ids. Changing that would be costly.&lt;/p&gt;

&lt;p&gt;What I want is a domain layer a level higher than the typical database
ORM classes, something to convert my ORM classes into that will be
able to do work in a safer way.&lt;/p&gt;

&lt;p&gt;Rather than three enums that are supposed to change in lock step (but
might get out of date), I really want a concept of the three combined
and &amp;ldquo;frozen&amp;rdquo; together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Direction = 
    | Held_Deliver_Principal
    | Held_Return_Counterparty
    | Posted_Return_Principal
    | Posted_Deliver_Counterparty
    
let GetDirection = function
   | Deliver, Principal  -&amp;gt; Held_Deliver_Principal
   | Return, Counterparty -&amp;gt; Held_Return_Counterparty
   | Return, Principal -&amp;gt; Posted_Return_Principal
   | Deliver, Counterparty -&amp;gt; Posted_Deliver_Counterparty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I have a combined Direction that merges the three concepts into
one. It is impossible with this new merged type to have an invalid
state across the three. Getting any of the types back out to convert
into the ORM classes or do some work is as simple as another match:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let GetMovementTypeToSaveInORM = function
   | Held_Deliver_Principal | Posted_Deliver_Counterparty -&amp;gt; Deliver
   | Posted_Return_Principal | Held_Return_Counterparty -&amp;gt; Return

let GetSendFn = function
   | Held_Deliver_Principal | Posted_Return_Principal -&amp;gt; SendMessageToPrincipal
   | Held_Return_Counterparty | Posted_Deliver_Counterparty -&amp;gt; SendMessageToCounterparty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While it is possible to make an equivalent C# enum and combine these
in a similar way, it is inherently unsafe (nothing to guarantee you
covered every case) and therefore appropriately uncommon. The typical
answer for safe polymorphic dispatch in C# is to use an interface and
classes. Unfortunately, something still has to dispatch on that enum
id, either inside a class or at the time of class instantiation. That
is a vector for errors.&lt;/p&gt;

&lt;p&gt;Because F# interops so well with C#, it is possible to build in a
domain layer in F# immediately that calls down to your C# ORM
classes. Converting from a set of dangerous C# enums into a
constrained and safe F# discriminated union is easy and will simplify
your domain to its essence.&lt;/p&gt;

&lt;p&gt;For reasons like this, when I have to build something with a rich
domain, I reach for F#.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming Language Safety Ranking</title>
      <link>http://deliberate-software.com/programming-language-safety-algorithm/</link>
      <pubDate>Tue, 17 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/programming-language-safety-algorithm/</guid>
      <description>&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://deliberate-software.com/javascripts/sliders.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I think the time has come for a standard programming language safety
score. I want to use this model to help show that the concept of
safety is much more nuanced than a binary bit of &amp;ldquo;has strong-static
types&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;When someone says &amp;ldquo;programming language safety&amp;rdquo;, it typically invokes
thoughts of unit tests, long build times, and red squiggles in an
IDE. But, in day-to-day development, there are so many times when we
are bitten by things that somehow just slip through the cracks.&lt;/p&gt;

&lt;p&gt;I put together this scoring model to get a sense of how safe a
language is at the primitive level, and if it isn&amp;rsquo;t safe by default,
how much it costs to manually make it safe. Since all abstractions
eventually result in a series of primitive operations, I decided that
focusing only on primitives would still be a valuable (if incomplete)
data point. While any good library will handle all primitive checks
and present the consumer with a well-designed abstraction, in the end,
the consumer is still left wiring libraries together, building their
own primitive abstractions for integration. Due to the impossibility of
measuring the quality of abstractions in all libraries for a language,
I left that entirely out of scope of this model, unless it is designed
as a primitive check.&lt;/p&gt;

&lt;p&gt;By focusing on only primitive operations: making and calling
functions, naming data, working with sequences, and dealing with
language primitive data types, I slimmed down the large range of
possible error vectors to a small handful. While in some languages it
is common to use user-defined classes to wrap around a set of
primitives, those classes are still doing the same primitive work,
just hidden behind a user-created abstraction. The more ways it is
possible to make a &amp;ldquo;mistake&amp;rdquo; with a primitive, the more difficult it
is to build such good abstractions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This model is not about language &amp;quot;power&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This model is not about ranking the &amp;ldquo;power&amp;rdquo;, &amp;ldquo;expressiveness&amp;rdquo;, or
&amp;ldquo;abstract-ability&amp;rdquo; of a language. In any language that supports
abstractions (functions, classes, modules, naming data), I am
convinced, given enough code, all Turing complete langauges can do the
same work. This model is only about the costs to prevent unexpected
&amp;ldquo;confusion&amp;rdquo; between the programmer and the machine at the primitive
level.&lt;/p&gt;

&lt;p&gt;Rather than focus on what is &lt;em&gt;possible&lt;/em&gt; with a language, I will
instead focus on what is typically idiomatic to that community. For
example, if it is possible to achieve a level of safety in a language
but by doing something uncommon, that should not be counted.&lt;/p&gt;

&lt;p&gt;To score a language, simply figure out how many characters it costs to
&amp;ldquo;prevent&amp;rdquo; a certain type of error, and add that to the
total. Newlines, spaces, and tabs do not count, but all other
punctuation does. If a specific check is language enforced, like F#&amp;rsquo;s
Option or C#&amp;rsquo;s parameter type enforcement, that is given a -30 (by
default) to make up for the lack of unit tests and code exercising
needed to run that &amp;ldquo;path&amp;rdquo;. Do not count import lines for libraries, as
importing the module will have a negligible effect on the code size
and complexity.&lt;/p&gt;

&lt;p&gt;If there is a safety feature that is not possible to achieve
programmatically, we will add +30 (by default) for a &amp;ldquo;every change run
and debug to fix&amp;rdquo; cost, such as Java not having a way to prevent stack
overflow exceptions caused by recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A lower score is &amp;quot;safer&amp;quot;, needing less (or no) code to achieve the same level of safety.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than tell you my thoughts (or survey for) hard-coded
weightings, all checks are weighted the same by default. Feel free to
apply your own weightings, to better match to your or your team&amp;rsquo;s
specific needs and preferences. The languages are masked by default to
protect the innocent. You can unmask the names and see the code used
below the table.&lt;/p&gt;

&lt;div ng-app=&#34;TableApp&#34;&gt;
&lt;div ng-controller=&#34;TableCtrl&#34;&gt;

Language Enforced Bonus:
{{ enforcedScore }} 
&lt;input ng-model=&#34;enforcedScore&#34; type=&#34;range&#34; min=&#34;0&#34; max=&#34;50&#34; /&gt;

Language Inability Penalty:
{{ inabilityPenalty }} 
&lt;input ng-model=&#34;inabilityPenalty&#34; type=&#34;range&#34; min=&#34;0&#34; max=&#34;50&#34; /&gt;

Show Weights &lt;input type=&#34;checkbox&#34; ng-model=&#34;showWeights&#34; /&gt;
&lt;p class=&#34;lead&#34;&gt;
&lt;div style=&#34;overflow-x:scroll&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;
&lt;th&gt;Safety Check&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[0]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[1]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[2]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[3]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34; score-row name=&#34;check.name&#34; row-key=&#34;check.key&#34;&gt;&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Totals&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ lang }} 
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Magnitude&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ percentageTotals(lang) }}% 
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h3&gt;&lt;input ng-model=&#34;showRealName&#34; type=&#34;checkbox&#34; /&gt;&lt;span
ng-click=&#34;showRealName = !!!showRealName&#34;&gt;Click to see backing code and unmask names&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Current Languages:
&lt;span ng-repeat=&#34;lang in allLanguages&#34;&gt;
{{ getName(lang) }}: {{ allLangTotals[$index] }},
&lt;/select&gt;&lt;/p&gt;

&lt;p&gt;I want to see your language represented here! I&amp;rsquo;ll happily take pull
requests for new languages: &lt;a href=&#34;https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders.js&#34;&gt;blog source&lt;/a&gt;. Just
use the &amp;ldquo;edit language&amp;rdquo; and &amp;ldquo;copy to clipboard&amp;rdquo; to build your own
language data structure.&lt;/p&gt;

&lt;p&gt;I would love to see every major language represented, including major
language &amp;ldquo;idiom communities&amp;rdquo;. For example, Clojure and Typed Clojure
are vastly different in abilities. Similarly &amp;ldquo;Scala - The Better Java&amp;rdquo;
and &amp;ldquo;Scala - The JVM Haskell&amp;rdquo; have vastly different idioms with
apparently very separate communities.&lt;/p&gt;

&lt;p&gt;Hope this is a helpful way to think about language safety!&lt;/p&gt;

&lt;p&gt;Special thanks to (in alphabetical order):
Patrick Boe &lt;a href=&#34;https://twitter.com/traffichazard/&#34;&gt;(twitter)&lt;/a&gt;,
Kyle Burton &lt;a href=&#34;http://asymmetrical-view.com/&#34;&gt;(blog)&lt;/a&gt;,
Daniel Miladinov &lt;a href=&#34;https://github.com/danielmiladinov&#34;&gt;(github)&lt;/a&gt;,
Chris Salch &lt;a href=&#34;https://github.com/arlaneenalra&#34;&gt;(github)&lt;/a&gt;, and
Tim Visher &lt;a href=&#34;https://github.com/timvisher&#34;&gt;(github)&lt;/a&gt;&lt;/p&gt;

&lt;div ng-show=&#34;showRealName&#34;&gt; Feel free to put in your own examples by playing
with the samples below. Code surrounded with &lt;! !&gt; is ignored from the tally,
since it would vary heavily based on the language and desired result. Variable
and type names are kept at single characters, which are counted. Feel free to
add in your own language below, and use the copy feature to extract the data
structure to use in a pull request.

&lt;div&gt;Select Language:
&lt;select ng-options=&#34;lang.name for lang in allLanguages&#34; ng-model=&#34;selectedLang&#34;&gt;&lt;/select&gt;
&lt;/div&gt;
&lt;button ng-click=&#34;showEdit = !showEdit&#34;&gt;Edit Language&lt;/button&gt;
&lt;button ng-click=&#34;copyToClipboard(selectedLang)&#34;&gt;Copy Changes to Clipboard&lt;/button&gt;
&lt;div ng-show=&#34;showEdit&#34;&gt;
&lt;span&gt;&lt;input ng-model=&#34;selectedLang.name&#34;&gt;&lt;/input&gt;&lt;/span&gt;
&lt;div ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;h3&gt;{{ check.name }} : {{ score(selectedLang[check.key]) }}  &lt;/h3&gt;
&lt;p&gt;
&lt;textarea class=&#34;widetextarea&#34; rows=&#34;5&#34; ng-model=&#34;selectedLang[check.key].desc&#34;&gt;&lt;/textarea&gt; 
&lt;div&gt;
Code: &lt;select ng-options=&#34;enforcedNice(e) for e in enforcedTypes&#34; ng-model=&#34;selectedLang[check.key].enforced&#34;&gt;&lt;/select&gt;
&lt;div class=&#34;tablecode&#34;&gt;1234567890123456789012345678901234567890&lt;/div&gt;
&lt;div class=&#34;tablecode&#34; &gt; {{ cleanCode(selectedLang[check.key].rawCode) }}  &lt;/div&gt;
&lt;input type=&#34;text&#34; style=&#34;width:90%;&#34; ng-model=&#34;selectedLang[check.key].rawCode&#34; /&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div ng-show=&#34;!showEdit&#34;&gt;
&lt;span&gt;{{ selectedLang.name }} &lt;/span&gt;
&lt;div ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;h3&gt;{{ check.name }} : {{ score(selectedLang[check.key]) }}  &lt;/h3&gt;
&lt;p&gt;
{{ selectedLang[check.key].desc }} 
&lt;div&gt;
Code: {{ enforcedNice(selectedLang[check.key].enforced)  }} 
&lt;div class=&#34;tablecode&#34; ng-if=&#34;selectedLang[check.key].rawCode&#34;&gt;1234567890123456789012345678901234567890&lt;/div&gt;
&lt;div class=&#34;tablecode&#34; &gt; {{ cleanCode(selectedLang[check.key].rawCode) }}  &lt;/div&gt;
&lt;input type=&#34;text&#34; style=&#34;width:90%;&#34; ng-model=&#34;selectedLang[check.key].rawCode&#34; /&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>