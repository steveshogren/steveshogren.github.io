<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical Skills on Deliberate Software</title>
    <link>http://deliberate-software.com/categories/technical-skills/</link>
    <description>Recent content in Technical Skills on Deliberate Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Feb 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://deliberate-software.com/categories/technical-skills/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Avoid Pop Culture Architecture</title>
      <link>http://deliberate-software.com/pop-culture-architecture/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/pop-culture-architecture/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;ActiveRecord is so hot right now!&amp;rdquo; - comment in 2006&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pop Culture Architecture is the current &amp;ldquo;fad&amp;rdquo; of the day. I have seen it be
microservices, business capabilities, CQRS, service-oriented architecture,
Domain-Driven Design, test driven development, ORMs, ActiveRecord, and MVC. Each
of these have been fashionable at some point.&lt;/p&gt;

&lt;p&gt;Fashion is ultimately a signaling mechanism for status. We are attracted to
fashionable architectures because they signal we have worked on elite teams. The
more difficult or costly the trade-offs of the architecture, the more elite and
special our team must have been to implement it successfully.&lt;/p&gt;

&lt;h2 id=&#34;example-microservices:5f95d372c851097c31e5c149858c384a&#34;&gt;Example: Microservices&lt;/h2&gt;

&lt;p&gt;Microservices is a current fashionable design. Microservices have very clear
pros and cons. They come with the ability to have a huge team or a fragmented
deployment that potentially allows for horizontal scaling. For that ability, you
will pay the immense costs: loss of strong consistency and transactions, a
labyrinthine operational footprint and deployment, increased communication
effort, expensive integration testing, and a code base that takes longer to
program. &lt;a href=&#34;http://martinfowler.com/articles/microservice-trade-offs.html&#34;&gt;(1)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you have a small team or system that does not need horizontal scaling on
every single component, a microservice architecture is unlikely to solve your
communication or trust issues. You will spend dollars on deployment, consistency
issues, distributed debugging, and basic programming just to save a penny on
communication and teamwork.
&lt;a href=&#34;http://www.stackbuilders.com/news/the-hidden-costs-of-microservices&#34;&gt;(2)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For most teams, the logical conclusion probably will be: a microservice
architecture solves problems we don&amp;rsquo;t have.&lt;/p&gt;

&lt;p&gt;Microservices remain fashionable because they indicate work at the size and
scale of a handful of elite companies. You would only likely encounter a couple
hundred companies in the world that have a development staff so large or loads
so high as to truly require such a system. Because of the rarity of actual need,
it is a perfect signaling mechanism for status.&lt;/p&gt;

&lt;p&gt;Saying that you implemented a microservice architecture implies &amp;ldquo;my team was so
large or my product so popular, my team could afford to pay almost any cost to
meet the demand.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Carefully consider your architecture decisions. Do not allow fashion to dictate
your choices. Take pride in selecting the appropriate architecture for the
project, no matter how unpopular.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Haskell is the Dark Souls of Programming</title>
      <link>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/haskell-is-the-dark-souls-of-programming/</guid>
      <description>

&lt;p&gt;Please don&amp;rsquo;t hit me, Haskell does a great job of that already.&lt;/p&gt;

&lt;p&gt;I love Haskell for the same reasons I love Dark Souls. Fantastic and inscrutable
lore, a great &lt;del&gt;combat&lt;/del&gt; type system, a cliff-wall difficulty curve, and
unending punishment.&lt;/p&gt;

&lt;p&gt;I want to collect some statistics from the GitHub API.&lt;/p&gt;

&lt;h3 id=&#34;step-one-stack:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step One - Stack&lt;/h3&gt;

&lt;p&gt;I download stack and start a project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; cd /home/jack/programming &amp;amp;&amp;amp; stack new github-stats &amp;amp;&amp;amp; cd github-stats
Downloading template &amp;quot;new-template&amp;quot; to create project &amp;quot;github-stats&amp;quot; in github-stats/ ... 
 ......
All done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good. Does it work?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  &amp;gt; stack build &amp;amp;&amp;amp; stack exec -- github-stats-exe 
   github-stats-0.1.0.0: configure
   ..... 
   Registering github-stats-0.1.0.0...
   someFunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awww yisss. This is going to be so easy!&lt;/p&gt;

&lt;h3 id=&#34;step-two-https-get-request:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step Two - HTTPS GET Request&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/tomb_of_the_giants.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Now I need to query the GitHub API. Not my first time to the rodeo, I generate a
personal access token from GitHub and copy it to a local file. What query should
I run first? How about the count for all ASM tetris repositories? Poking around
the &lt;a href=&#34;https://developer.github.com/v3/search/#search-repositories&#34;&gt;docs&lt;/a&gt; comes up
with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET https://api.github.com/search/repositories?q=tetris+language:assembly&amp;amp;sort=stars&amp;amp;order=desc
User-Agent: steveshogren
Authorization: token PUT_TOKEN_HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;{.. &amp;ldquo;total_count&amp;rdquo;: 354}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Easy life. Now how do you GET a resource in Haskell? Ah,
&lt;a href=&#34;https://hackage.haskell.org/package/HTTP-4000.3.2/docs/Network-HTTP.html&#34;&gt;Network.HTTP&lt;/a&gt;!
I copy the front page sample into &lt;code&gt;src/Lib.hs&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;module Lib
    ( someFunc
    ) where

x = simpleHTTP (getRequest &amp;quot;https://www.github.com/&amp;quot;) &amp;gt;&amp;gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = 
   print x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So simple! This is why laugh at my NodeJS loving friends!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doesn&amp;rsquo;t compile. Durp, hackage is a package library, I need to add this to my
cabal. What is the name of the package? HTTP-4000? HTTP-4000.3.2? Nothing in
hackage seems to indicate what goes into the cabal file. I discover it is just
HTTP through trial and error. I update my cabal file&amp;hellip; in all three
build-depends&amp;hellip;?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;  build-depends:       base &amp;gt;= 4.7 &amp;amp;&amp;amp; &amp;lt; 5
                       , HTTP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hrm, same error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stack build
src/Lib.hs:5:5: Not in scope: ‘simpleHTTP’
src/Lib.hs:5:17: Not in scope: ‘getRequest’
src/Lib.hs:5:77: Not in scope: ‘getResponseBody’
Compilation failed.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, durp, I&amp;rsquo;d need an import. (WHY ISN&amp;rsquo;T THIS IN THE CODE SAMPLE?!) Also, print
doesn&amp;rsquo;t work, I need &lt;code&gt;putStrLn&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Network.HTTP

x = simpleHTTP (getRequest &amp;quot;https://www.github.com/&amp;quot;) &amp;gt;&amp;gt;= fmap (take 100) . getResponseBody

someFunc :: IO ()
someFunc = x &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here goes!!!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; &amp;gt; stack build &amp;amp;&amp;amp; stack exec -- github-stats-exe
github-stats-exe: user error (https not supported)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wat. Further inspection of the docs shows a line WAAY DOWN in paragraph 5.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: This package only supports HTTP;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/nope_better.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;When &lt;del&gt;playing Dark Souls&lt;/del&gt;programming Haskell, sometimes the best move
is to run away. I search again. &lt;code&gt;haskell https request&lt;/code&gt; returns
&amp;ldquo;http-conduit&amp;rdquo; as the best choice. After adding http-conduit to my cabal, I come
up with this beast without any surprises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;query :: IO String
query = do
    initReq &amp;lt;- parseUrl &amp;quot;https://api.github.com/search/repositories&amp;quot;
    let r = initReq
                   { method = &amp;quot;GET&amp;quot;
                    , requestHeaders = [(hUserAgent, &amp;quot;steveshogren&amp;quot;)
                                      , (hAuthorization, &amp;quot;token PUT_TOKEN_HERE&amp;quot;)]}
    let request = setQueryString [(&amp;quot;q&amp;quot;, Just &amp;quot;tetris+language:assembly&amp;quot;)
                                 ,(&amp;quot;order&amp;quot;, Just &amp;quot;desc&amp;quot;)
                                 ,(&amp;quot;sort&amp;quot;, Just &amp;quot;stars&amp;quot;)] r
    manager &amp;lt;- newManager tlsManagerSettings
    res &amp;lt;- httpLbs request manager
    return . show . responseBody $ res

someFunc :: IO ()
someFunc = do
   query &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huzzah! Results! I&amp;rsquo;m getting back a monster string of json data.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;\&amp;ldquo;{\\&amp;ldquo;total_count\\&amp;rdquo;:66, &amp;hellip;.}\&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/praisethesun.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-three-parsing-json:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Step Three - Parsing JSON&lt;/h3&gt;

&lt;p&gt;Time to parse this mega JSON string. Aeson seems to be the biggest contender. To
use Aeson and get the total_count value from the return, I needed the following
additions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ResultCount allows me to use &lt;code&gt;decode&lt;/code&gt; from aeson instead of &lt;code&gt;show&lt;/code&gt; to
parse the &amp;ldquo;total_count&amp;rdquo; from the JSON response into an Int. Sure enough, it
does!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Lib
    ( someFunc
    ) where

import Control.Monad
import Network
import Network.HTTP.Conduit
import Network.HTTP.Types.Header
import GHC.Generics
import Data.Aeson

data ResultCount = ResultCount {
  total_count :: Int }
  deriving (Generic, Show)

instance ToJSON ResultCount
instance FromJSON ResultCount

query :: IO (Maybe Int)
query = do
    initReq &amp;lt;- parseUrl &amp;quot;https://api.github.com/search/repositories&amp;quot;
    let r = initReq
                   { method = &amp;quot;GET&amp;quot;
                    , requestHeaders = [(hUserAgent, &amp;quot;steveshogren&amp;quot;)
                                      , (hAuthorization, &amp;quot;token PUT_TOKEN_HERE&amp;quot;)]}
    let request = setQueryString [(&amp;quot;q&amp;quot;, Just &amp;quot;tetris+language:assembly&amp;quot;)
                                 ,(&amp;quot;order&amp;quot;, Just &amp;quot;desc&amp;quot;)
                                 ,(&amp;quot;sort&amp;quot;, Just &amp;quot;stars&amp;quot;)] r
    manager &amp;lt;- newManager tlsManagerSettings
    res &amp;lt;- httpLbs request manager
    return . liftM total_count . decode . responseBody $ res

someFunc :: IO ()
someFunc = query &amp;gt;&amp;gt;= print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puts out: &lt;code&gt;Just 66&lt;/code&gt;. Success! Wait. 66 isn&amp;rsquo;t the same count I got when
running from the browser. Check again. Sure enough, browser comes up with a
totally different count.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/come_at_me_bro.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Maybe the query request isn&amp;rsquo;t correct? Adding a &lt;code&gt;print request&lt;/code&gt; on line 31
after building the request shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;Request {
  host                 = &amp;quot;api.github.com&amp;quot;
  port                 = 443
  secure               = True
  requestHeaders       = [(&amp;quot;User-Agent&amp;quot;,&amp;quot;steveshogren&amp;quot;),(&amp;quot;Authorization&amp;quot;,&amp;quot;token PUT_TOKEN_HERE&amp;quot;)]
  path                 = &amp;quot;/search/repositories&amp;quot;
  queryString          = &amp;quot;?q=tetris%2Blanguage%3Aassembly&amp;amp;order=desc&amp;amp;sort=stars&amp;quot;
  method               = &amp;quot;GET&amp;quot;
  proxy                = Nothing
  rawBody              = False
  redirectCount        = 10
  responseTimeout      = Just (-3425)
  requestVersion       = HTTP/1.1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The queryString isn&amp;rsquo;t right! It encoded my &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;! After an hour of
reading through docs and researching URL encoding specs, it dawns on me. &lt;code&gt;+&lt;/code&gt;
is an encoded whitespace.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No face-palm gif could ever represent the shear magnitude of my current
emotions&amp;hellip; You&amp;rsquo;ll have to use your imagination&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I change my query to &lt;code&gt;&amp;quot;tetris language:assembly&amp;quot;&lt;/code&gt; and the right
count comes back! &lt;code&gt;Just 354&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I finally have something that correctly fetches a count of repositories from
GitHub and parses it into an Int. After over four hours of &lt;del&gt;Dark
Souls&lt;/del&gt;Haskell punishment, we deserve to enjoy a bonfire!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/solaire_sitting.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h2 id=&#34;edit-bonus-round:6807ae504e3906e54fafcf1fb117cd62&#34;&gt;Edit: Bonus Round!&lt;/h2&gt;

&lt;p&gt;Thanks to
&lt;a href=&#34;http://bitemyapp.com/posts/2016-02-06-haskell-is-not-trivial-not-unfair.html&#34;&gt;Chris Allen&lt;/a&gt;
and
&lt;a href=&#34;https://www.reddit.com/r/programming/comments/44hdl6/haskell_is_the_dark_souls_of_programming/czqaxfu&#34;&gt;/u/JeanParker&lt;/a&gt;
for pointing me towards &lt;a href=&#34;http://www.serpentine.com/wreq/&#34;&gt;wreq&lt;/a&gt;, which weirdly
didn&amp;rsquo;t come up when I looked around for libs yesterday. Yep, it was 6th on the
Google when searching for &lt;code&gt;haskell https get&lt;/code&gt;. &lt;code&gt;Network.HTTP&lt;/code&gt; is the
top three results, and that doesn&amp;rsquo;t even &lt;em&gt;do&lt;/em&gt; https.&lt;/p&gt;

&lt;p&gt;¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/p&gt;

&lt;p&gt;Armed with their helpful suggestions, I knocked this out this morning.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;import Network.Wreq
import Control.Lens
import Data.Aeson
import Data.Aeson.Lens
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as BS

opts :: String -&amp;gt; String -&amp;gt; Options
opts lang token = defaults &amp;amp; param &amp;quot;q&amp;quot; .~ [T.pack $ &amp;quot;tetris language:&amp;quot; ++ lang]
                        &amp;amp; param &amp;quot;order&amp;quot; .~ [&amp;quot;desc&amp;quot;]
                        &amp;amp; param &amp;quot;sort&amp;quot; .~ [&amp;quot;stars&amp;quot;]
                        &amp;amp; header &amp;quot;Authorization&amp;quot; .~ [BS.pack $ &amp;quot;token &amp;quot; ++ token]

query lang = do
    token &amp;lt;- readFile &amp;quot;token&amp;quot;
    r &amp;lt;- getWith (opts lang token) &amp;quot;https://api.github.com/search/repositories&amp;quot;
    return $ r ^? responseBody . key &amp;quot;total_count&amp;quot; . _Number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MUCH better. This includes reading my token from file called &amp;ldquo;token&amp;rdquo; so I don&amp;rsquo;t
accidentally commit it. Also includes building up the different query options
based on inputs, which was the next step. Thanks y&amp;rsquo;all.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/solaire_idle.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pixel gifs sourced from
&lt;a href=&#34;http://zedotagger.deviantart.com/gallery/54317550/Dark-Souls&#34;&gt;zedotagger&lt;/a&gt; on
deviantart, thanks zedotagger!&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>F# Unit Testing With SimpleMock</title>
      <link>http://deliberate-software.com/f-number-unit-testing/</link>
      <pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/f-number-unit-testing/</guid>
      <description>

&lt;p&gt;If you are considering using F#, you might be curious how to handle unit test
mocking, especially if you want to use both modules and classes. In a language
like C# or Java, the common method is to a DI container or handmade constructor
injection on a class. These &amp;ldquo;entry points&amp;rdquo; allow for a unit test to replace a
real dependency with a test-only replacement.&lt;/p&gt;

&lt;p&gt;I previously posted an example that shows a much simpler way to inject
dependencies called the &lt;a href=&#34;http://deliberate-software.com/simplemock-unit-test-mocking/&#34;&gt;SimpleMock pattern&lt;/a&gt;. The SimpleMock pattern can also be
used in F#, even if you are only using modules.&lt;/p&gt;

&lt;h2 id=&#34;simplemock-in-f-modules:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;SimpleMock in F# Modules&lt;/h2&gt;

&lt;p&gt;We will assume you are mocking inside a module and not a class. Mocking inside
an F# class would look much the same as it does in C#, which we showed in the
SimpleMock post. Here is a sample program that does some work and persists the
results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To apply the SimpleMock pattern, we can use argument currying by adding a simple
function wrapper.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let addAndSave&#39; saveSum x y = 
  let sum = x + y
  saveSum sum
  sum
let addAndSave = addAndSave&#39; DBModule.saveSum

// Test code
let addAndSave_Test =
  let calledVar = ref 0
  let result = addAndSave&#39; (fun sum -&amp;gt; calledVar := sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, !calledVar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We started by renaming the &lt;code&gt;addAndSave&lt;/code&gt; function with a trailing &lt;code&gt;&#39;&lt;/code&gt;. We
created a new &lt;code&gt;addAndSave&lt;/code&gt; that calls &lt;code&gt;addAndSave&#39;&lt;/code&gt; with the correct
dependency for the first argument, leaving the rest of the arguments to be
called later. Currying is what allows this ability. The new &lt;code&gt;addAndSave&lt;/code&gt;
function only needs the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; parameters. At test time, we called &lt;code&gt;addAndSave&#39;&lt;/code&gt;, passing in the needed dependency, but using a lambda as the
&amp;ldquo;fake&amp;rdquo;. The injection is as close to the dependency use as possible!&lt;/p&gt;

&lt;h2 id=&#34;bonus-simplemock-fake-helper:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;Bonus: SimpleMock Fake Helper&lt;/h2&gt;

&lt;p&gt;The earlier replacement for DBModule.saveSum is a bit complex, and it does not
show us how many times the fake was called. We can easily make a helper that
takes parameters and returns them when called, along withe count of times it was
called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TestFakeResults() =
  member val timesCalled = 0 with get,set
  member val args: obj list = [] with get,set

let makeFake_OneArg () =
  let results = new TestFakeResults()
  let fake = (fun p1 -&amp;gt;
                  results.args &amp;lt;- p1 :: results.args
                  results.timesCalled &amp;lt;- results.timesCalled + 1
                  ())
  (fake, results)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code might be hard to comprehend at first! We have made a generic
helper that can create any single argument fake we need. We return a tuple,
containing the fake lambda and an instance of &lt;code&gt;TestFakeResults&lt;/code&gt;. The fake
lambda will populate the &lt;code&gt;TestFakeResults&lt;/code&gt;, which we can access in the test
via the second arg of the tuple.&lt;/p&gt;

&lt;p&gt;We can now re-write the previous test using &lt;code&gt;makeFake_OneArg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Test code
let addAndSave_Test =
  let (fakeSave, fakeSaveCalling) = makeFake_OneArg()
  let result = addAndSave&#39; fakeSave 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaveCalling.args.[0])
  Assert.AreEqual(1, fakeSaveCalling.timesCalled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The TestFakeResults can return information about the way it was called,
including the list of all arguments. If we felt we needed the extra
expressiveness, we could also use a mocking library like RhinoMocks or Moq. The
TestFakeResults and its constructor are not essential to the pattern. The most
important part is learning to unit test in F# with confidence.&lt;/p&gt;

&lt;h1 id=&#34;double-bonus-when-to-use-a-class-instead-of-a-record:43b10499a7e4c1aeb47d57d551a820fe&#34;&gt;Double Bonus: When to Use a Class Instead of a Record&lt;/h1&gt;

&lt;p&gt;When I first wrote this post, I used a record instead of a class for the &lt;code&gt;TestFakeResults&lt;/code&gt; type. If you have been bitten by the functional programming bug,
you might have wondered at my usage of a mutable class. Here are two alternates
of &lt;code&gt;makeFake_OneArg&lt;/code&gt; which use records. You can probably see why I switched to a class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TestFakeResults = {timesCalled:int, args obj list}

// Using Record Alternate 1
let makeFake_OneArg_RecordAlternate1 () = 
  let t = ref 0
  let a : obj list ref = ref []
  let fake = (fun p1 -&amp;gt;
                  a := p1 :: !a
                  t := !t + 1
                  ())
  (fake, (fun () -&amp;gt;
                {TestFakeRecord.timesCalled = !t;
                 args = !a}))

// Using Record Alternate 2
let makeFake_OneArg_RecordAlternate2 () = 
  let result = ref {TestFakeRecord.timesCalled = 0; args = []}
  let fake = (fun p1 -&amp;gt;
              result := {timesCalled = (!result).timesCalled + 1;
                         args = p1 :: (!result).args}
              ())
  (fake, (fun () -&amp;gt; !result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only way to use a record is to delay its construction via a lambda which
must be executed by the test code. Both are complex: what we need is a mutable
data structure which we can access via a reference. A record is not that. We can
approximate it using tricks, but ultimately I find both alternatives to be too
complex to justify their use. Sometimes a mutable data structure is the best
choice to solve your problem efficiently. The power of F# is that it gives us
the ability to choose the best tool for the job: records for immutability,
classes for mutability.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SimpleMock: Language Agnostic Unit Test Mocking</title>
      <link>http://deliberate-software.com/simplemock-unit-test-mocking/</link>
      <pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/simplemock-unit-test-mocking/</guid>
      <description>

&lt;p&gt;SimpleMock is a pattern for reducing TDD damage. You can use the pattern to
organize your testing code without mocking or complicated dependency injection.&lt;/p&gt;

&lt;p&gt;SimpleMock works in any language with closures that can be passed around by
reference, so off the top of my head: C#, Java, F#, Scala, PHP, C++, Ruby, and
Python. I&amp;rsquo;m sure you can think of others.&lt;/p&gt;

&lt;h2 id=&#34;example:442bb35a3947650665613cec7b90f820&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;Here is a brief (if a bit silly) example of the final pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class LineCounter {
    internal Func&amp;lt;string, IEnumerable&amp;lt;string&amp;gt;&amp;gt; _readLines = File.ReadLines;

    public string CountLines(string filename) {
        return _readLines(filename).Count();
    }
}

/// Test Code
[TestCase]
public void TestLineCounter () {
    var sut = new LineCounter();
    // &amp;quot;SimpleMock&amp;quot; of File.ReadLines
    sut._readLines = (string x) =&amp;gt; new List&amp;lt;string&amp;gt;{&amp;quot;test&amp;quot;, &amp;quot;that&amp;quot;};

    var result = sut.CountLines(&amp;quot;test&amp;quot;);

    Assert.AreEqual(2, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;benefits:442bb35a3947650665613cec7b90f820&#34;&gt;Benefits&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Reduced boilerplate&lt;/li&gt;
&lt;li&gt;Saves interfaces for real polymorphism&lt;/li&gt;
&lt;li&gt;Simplifies test code&lt;/li&gt;
&lt;li&gt;Reduces testing concerns in production code&lt;/li&gt;
&lt;li&gt;Removes need for fragile IoC containers&lt;/li&gt;
&lt;li&gt;Encourages better abstraction design&lt;/li&gt;
&lt;li&gt;Can convert one class at a time!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The SimpleMock pattern promotes a better design of your abstractions and simpler
tests. The pattern also reduces boilerplate and the pollution of your production
code with testing concerns.&lt;/p&gt;

&lt;p&gt;If you aren&amp;rsquo;t familiar with the normal pattern of unit test mocking using
interfaces, dependency injection, and mock libraries, scroll down to &amp;ldquo;The
Non-SimpleMock Way&amp;rdquo; at the end of the post.&lt;/p&gt;

&lt;h2 id=&#34;simplemock-pattern:442bb35a3947650665613cec7b90f820&#34;&gt;SimpleMock Pattern&lt;/h2&gt;

&lt;p&gt;The SimpleMock pattern is aptly named.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Replace Test-Only Interfaces With Functions&lt;/li&gt;
&lt;li&gt;Define Dependencies Inline&lt;/li&gt;
&lt;li&gt;Write Better Abstractions&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;step-one-replace-test-only-interfaces-with-functions:442bb35a3947650665613cec7b90f820&#34;&gt;Step One: Replace Test-Only Interfaces With Functions&lt;/h2&gt;

&lt;p&gt;My examples are in C# because that is what I got paid to write today - it is
freshest in memory. C# has an incredible ability to create and pass around
lambdas and function references. Here is an example of using functions instead
of interfaces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}
public class Translator {
    private Func&amp;lt;DateTime&amp;gt; _getCurrentTime;

    public Translator() : this(new CurrentTime().GetCurrentTime) {}

    public Translator(Func&amp;lt;DateTime&amp;gt; getCurrentTime) {
        this._getCurrentTime = getCurrentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;

    var sut = new Translator(() =&amp;gt; now);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The test code is quite simple! No longer do we need the dependency on third
party mocking libraries, or the relatively complicated setup logic. Instead we
can simply inject the lambda at runtime, replacing that pointer. We didn&amp;rsquo;t need
the whole interface, really we just needed the simple signature of the function.&lt;/p&gt;

&lt;h2 id=&#34;step-2-define-dependencies-inline:442bb35a3947650665613cec7b90f820&#34;&gt;Step 2: Define Dependencies Inline&lt;/h2&gt;

&lt;p&gt;We can take it even a step further. Why use constructor injection at all? Since
all we really want is a single mutable dispatch table row, why not just make it
that way?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class Translator {
    internal Func&amp;lt;DateTime&amp;gt; _getCurrentTime = new CurrentTime().GetCurrentTime;

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, _getCurrentTime().ToString(), input);
    }
}

/// Test Code
[TestCase]
public void TestCurrentTimeTranslator () {
    var now = DateTime.Now;
    var sut = new Translator();
    sut._getCurrentTime = () =&amp;gt; now;

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(now.ToString() + &amp;quot;: test&amp;quot;, result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve cleaned up our nasty multi-line indirection into a single dispatch line.
&amp;ldquo;Go to definition&amp;rdquo; now takes me to the actual line with the actual called
function. We&amp;rsquo;ve replaced a dependency on a class based interface with a function
signature. The function signature &lt;em&gt;is&lt;/em&gt; the interface!&lt;/p&gt;

&lt;p&gt;You probably noticed we have lost something with this final version. We have
lost the ability to inject polymorphic behavior through the constructor. If you
need it, simply go back to injecting the interface in the constructor or by
passing it into the function itself. In practice, I have found this is needed
very rarely, making the SimpleMock pattern a better tool to reach for first.&lt;/p&gt;

&lt;h2 id=&#34;step-3-write-better-abstractions:442bb35a3947650665613cec7b90f820&#34;&gt;Step 3: Write Better Abstractions&lt;/h2&gt;

&lt;p&gt;Lastly, SimpleMock actually promotes better designs. For example, a coworker was
writing some tests today and ran into a complicated situation. Take the
following sanitized code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Action&amp;lt;Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Action&amp;lt;Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public void IgnoreAndRemoveThings(Thing t1, Thing t2) {
        ignoreElements(t1);
        ignoreElements(t2);
        removeIgnoredElements(t1);
        removeIgnoredElements(t2);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How would you check that each section was called? Our naive solution was a
complicated lambda with a &amp;ldquo;timesCalled&amp;rdquo; counter and an if statement to assert
against each argument, but it turns nasty quickly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;/// Nasty test code
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();

    var ignoredCalledTimes = 0;
    sut.ignoreElements = (t) =&amp;gt; {
        ignoredCalledTimes++;
        if (ignoredCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };
    var removedCalledTimes = 0;
    sut.removeIgnoredElements = (t) =&amp;gt; {
        removedCalledTimes++;
        if (removedCalledTimes == 1) {
            Assert.AreEqual(t1, t);
        } else {
            Assert.AreEqual(t2, t);
        }
    };

    var t1 = new Thing();
    var t2 = new Thing();

    var result = sut.IgnoreAndRemoveThings(t1, t2);
    Assert.AreEqual(2, removedCalledTimes);
    Assert.AreEqual(2, ignoredCalledTimes);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yuck! The test is an absolute catastrophe. I see a mess of mixed concerns.
Conditionals?! In a test?! Unconscionable.&lt;/p&gt;

&lt;p&gt;In situations like this, we have two easy options. Option one is to just use
a third party mocking library, replacing the functions from inside the test
code. This gives us access to all the sophisticated mocking tools available.&lt;/p&gt;

&lt;p&gt;My preferred option is seeking to decomplect the production code by using better
abstractions.&lt;/p&gt;

&lt;p&gt;I have found that strong reliance of mocking libraries enables worse designs.
Consider the code, what makes it so hard to test? Not knowing which element is
called when, doing the same work on two parameters, and reference mutation all
make this a poor abstraction. Why not simplify?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public class WorkDoer {
    internal Func&amp;lt;Thing, Thing&amp;gt; ignoreElements = new ThingIgnorer().IgnoreElements;
    internal Func&amp;lt;Thing, Thing&amp;gt; removeIgnoredElements = new ThingRemover().RemoveElements;

    public List&amp;lt;Thing&amp;gt; IgnoreAndRemoveThings(List&amp;lt;Thing&amp;gt; ts) {
        return ts.Select(t =&amp;gt; removeIgnoredElements(ignoreElements(t)));
    }
}

/// Simpler test
[TestCase]
public void TestWorkDoer () {
    var sut = new WorkDoer();
    var expected = new Thing();
    var ts = new List&amp;lt;Thing&amp;gt;{new Thing()};

    sut.ignoreElements = (t) =&amp;gt; new Thing();

    sut.removeIgnoredElements = (t) =&amp;gt; {
        Assert.AreEqual(t, sut.ignoreElements(t));
        return expected;
    };

    var result = sut.IgnoreAndRemoveThings(ts);

    Assert.AreEqual(expected, result.First())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much better! Yes, we had to change a few signatures. We get the same work done,
but now the code is actually a lot more useful. Our test code is comparable with
anything you&amp;rsquo;d find using a mocking library. I am absolutely okay with using a
mocking library when needed, but I always carefully consider my abstractions and
design first.&lt;/p&gt;

&lt;p&gt;If mocking libraries and IoC containers are the chainsaws of the testing world,
then SimpleMock is the garden shears. Sometimes the chainsaw is the only tool
for the job, and that is fine. But for most work around the yard, you can leave
the chainsaw in the shed.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:442bb35a3947650665613cec7b90f820&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I’ve shown how you can really simplify your code with SimpleMock. The dispatch
row is clear and easy to read. We have removed some third party mocking
dependencies. You can remove a lot of the boilerplate &amp;ldquo;for making it more
testable&amp;rdquo; from your code. The test code is greatly simplified, and injection a
breeze. The result: much simpler code, just as easy to test.&lt;/p&gt;

&lt;p&gt;Thanks to Shuwei Chen for helping me put this together!&lt;/p&gt;

&lt;h2 id=&#34;the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;The Non-SimpleMock Way&lt;/h2&gt;

&lt;p&gt;If you are familiar with unit test mocking with interfaces, this part is
probably boring. Feel free to skip.&lt;/p&gt;

&lt;p&gt;The traditional way of performing C# unit test mocking involves dependency
injection and interface mocking using a mocking library. For dependency
injection, it is common to use a tool like Ninject or hand-rolled constructor
injection. For mocking, a library like Moq or Rhino Mocks is standard. Here is
an example of a class and its testing code without any business logic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ICurrentTime {
    DateTime GetCurrentTime();
}

public class CurrentTime : ICurrentTime {
    public DateTime GetCurrentTime() {
        return DateTime.Now();
    }
}

public class Translator {
    private readonly ICurrentTime ct;

    public Translator() : this(new CurrentTime()) {}

    public Translator(ICurrentTime currentTime) {
        this.ct = currentTime;
    }

    public string Translate(string input) {
        return string.Format(&amp;quot;{0}: {1}&amp;quot;, ct.GetCurrentTime().ToString(), input);
    }
}

/// Test Code with Moq
[TestCase]
public void TestCurrentTimeTranslator () {
    var rightNow = DateTime.Now;
    var mock = new Mock&amp;lt;ICurrentTime&amp;gt;();

    mock.Setup(a=&amp;gt;a.GetCurrentTime()).Returns(rightNow);

    var sut = new Translator(mock.Object);

    var result = sut.Translate(&amp;quot;test&amp;quot;);

    Assert.AreEqual(rightNow.ToString() + &amp;quot;: test&amp;quot;, result);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve done much C# unit testing, this should look familiar. We want to
inject some code that is potentially long-running or dynamic. We put that code
into a class, add an interface, then inject that interface into the class we
want to test. To test it, we mock the interface, creating a different concrete
class at test runtime which implements that interface. We can setup that mock to
respond with anything, which we use for assertions.&lt;/p&gt;

&lt;h2 id=&#34;what-s-wrong-with-the-non-simplemock-way:442bb35a3947650665613cec7b90f820&#34;&gt;What&amp;rsquo;s Wrong with the Non-SimpleMock Way?&lt;/h2&gt;

&lt;p&gt;The first problem is we have created a whole interface just for testing.
Interfaces are for polymorphism, but we don&amp;rsquo;t really need polymorphism for this
class. We simply want to mock it. The constructor injection is also test code
polluting our business logic.&lt;/p&gt;

&lt;p&gt;What we have done is create a very small and primitive dispatch table. The
table has one row: something that has a function with the signature of &lt;code&gt;() -&amp;gt; DateTime&lt;/code&gt; or, as it is known in C#: &lt;code&gt;Func&amp;lt;DateTime&amp;gt;&lt;/code&gt;.  We will need to make
this primitive dispatch table for every single mock in every single class we
wish to test. That&amp;rsquo;s a lot of boilerplate!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming Language Safety Score Mark 2</title>
      <link>http://deliberate-software.com/safety-rank-part-2/</link>
      <pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/safety-rank-part-2/</guid>
      <description>

&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://deliberate-software.com/javascripts/sliders2.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I want to make a model that predicts bugs.&lt;/p&gt;

&lt;p&gt;I previously wrote a table for scoring language safety:
&lt;a href=&#34;http://deliberate-software.com/programming-language-safety-algorithm&#34;&gt;Programming Language Safety Score&lt;/a&gt;,
but it was extremely time consuming to score new languages or make modifications.&lt;/p&gt;

&lt;h2 id=&#34;simplify-simplify:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Simplify, Simplify&lt;/h2&gt;

&lt;p&gt;After being told I was &lt;a href=&#34;https://en.wikipedia.org/wiki/Overfitting&#34;&gt;overfitting&lt;/a&gt;
the data, I&amp;rsquo;ve attempted to clean up by simply checking if each category is
enforced, possible, or impossible. I score each as either 1 (language enforced),
0 (possible, but you have to remember to do it), or -1 (impossible). When the
magnitudes of the new model are compared with the previous model, they come out
very similar. The shape of the curve pretty much stays the same, which I was
told indicates that the character count weighting was a variable that didn&amp;rsquo;t
matter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/rplot.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The code I used to generate the plot and normalize the scores can be found here:
&lt;a href=&#34;https://github.com/steveshogren/datasciencecoursera/blob/817dec79e36b6e9a6c5a8fd5700aff7cc394b9d4/scoreplot.R&#34;&gt;scorePlot.R&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;safety-definitions:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Safety Definitions&lt;/h2&gt;

&lt;p&gt;A definition of the safety checks is as follows:&lt;/p&gt;

&lt;div ng-app=&#34;TableApp2&#34;&gt;
&lt;div ng-controller=&#34;TableCtrl&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td&gt;{{ check.name }} &lt;/td&gt;
&lt;td&gt; {{ check.desc }}  &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

The new scores are shown here, with a lot more languages added in:

&lt;p class=&#34;lead&#34;&gt;
&lt;div style=&#34;overflow-x:scroll&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;
&lt;th&gt;Safety Check&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[0]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[1]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[2]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[3]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34; score-row name=&#34;check.name&#34; row-key=&#34;check.key&#34;&gt;&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Totals&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ lang }}
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Magnitude&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ percentageTotals(lang) }}%
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Current Languages:
&lt;span ng-repeat=&#34;lang in allLanguages&#34;&gt;
{{ getName(lang) }}: {{ allLangTotals[$index] }},
&lt;/select&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-what-s-the-point:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;So, What&amp;rsquo;s the Point?&lt;/h2&gt;

&lt;p&gt;To see how this model corresponds with data in the real world, I used the GitHub
API to query for the number of bugs created in repositories with more than 15
forks created in a span from 2011 to 2015. Commits were counted by summing the
commit counts of all contributors.&lt;/p&gt;

&lt;p&gt;I decided to rely on the count of commits as a standard for a unit of work. My
assumption was that across fifty different projects, the commit sizes would
average out. Once the unit of work was decided on, I wanted to find the ratio of
bugs per commit for each language.&lt;/p&gt;

&lt;p&gt;I collected the ratio of bugs logged per commit for each repository, and after
grouping by primary language, removed the top and bottom 25% using the
bug/commit ratio, which is a common practice in statistics to help find a more
accurate average. I summed the bugs and commits of those remaining repositories
grouped by language, finding a total average bug/commit ratio for each language
grouping. Here is that data, sorted by safety score.&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Bugs&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Bug/Commits&lt;/th&gt;
&lt;tr ng-repeat=&#34;lang in languageRatios&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.bugs }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getBugsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Here are the languages sorted by safety score with bug/commit ratios:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/errorChart.jpg&#34;&gt;&lt;/img&gt;
&lt;img src=&#34;http://deliberate-software.com/images/bugsAverage.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;I took the magnitude of the safety scores and the bug/commit ratios. After
inverting the safety scores, I overlaid them both onto a single graph.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/bothMags.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Immediately it is obvious that Ruby, Python, PHP, and Clojure all seem to strongly
buck the trend, but otherwise the languages follow a pretty consistent slope
down in bugs. Taking the correlation gives a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient&#34;&gt;correlation coefficient&lt;/a&gt;
of .55&lt;/p&gt;

&lt;h2 id=&#34;what-about-unit-tests:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;What About Unit Tests?&lt;/h2&gt;

&lt;p&gt;Thinking that Ruby, Clojure, PHP, and Python might not correlate well due to some
other factor, I collected data on how many tests each repository had. I counted
the number of files containing &amp;ldquo;test&amp;rdquo; or &amp;ldquo;spec&amp;rdquo;, which gave the following,
sorted by tests per commit:&lt;/p&gt;

&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Language&lt;/th&gt;
&lt;th&gt;Tests&lt;/th&gt;
&lt;th&gt;Commits&lt;/th&gt;
&lt;th&gt;Repositories&lt;/th&gt;
&lt;th&gt;Tests/Commits&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;lang in sorter(languageRatios)&#34;&gt;
&lt;td&gt;{{ lang.name }} &lt;/td&gt;
&lt;td&gt;{{ lang.test }} &lt;/td&gt;
&lt;td&gt;{{ lang.commits }} &lt;/td&gt;
&lt;td&gt;{{ lang.repos }} &lt;/td&gt;
&lt;td&gt;{{ getTestsRatio(lang) }} &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;PHP, Python, and Ruby all have a higher then average number of tests, but
Clojure does not. Additionally, Go, Scala, and Java all also have a higher than
average number of tests, yet they score relatively average in bugs/commit.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In conclusion, the current safety model I have proposed seems to account for a
moderate reduction in bugs per commit across the sampled languages, but is not
the only factor. It currently is unable to account for a significantly lower
than expected bug count in Ruby and Clojure.&lt;/p&gt;

&lt;h2 id=&#34;special-thanks:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Special Thanks&lt;/h2&gt;

&lt;p&gt;Special thanks to (in alphabetical order):
&lt;a href=&#34;https://twitter.com/traffichazard/&#34;&gt;Patrick Boe&lt;/a&gt; (Haskell, Sniff Test),
&lt;a href=&#34;http://asymmetrical-view.com/&#34;&gt;Kyle Burton&lt;/a&gt; (General Advice),
Nils Creque (Listening Board),
Max Haley (Python, Ruby, Teaching me how to math),
&lt;a href=&#34;https://github.com/danielmiladinov&#34;&gt;Daniel Miladinov&lt;/a&gt; (Java, Scala, Morale Support),
Keith O&amp;rsquo;Brien (Ruby and JS),
&lt;a href=&#34;https://github.com/arlaneenalra&#34;&gt;Chris Salch&lt;/a&gt; (CoffeeScript and JS),
and &lt;a href=&#34;https://github.com/timvisher&#34;&gt;Tim Visher&lt;/a&gt; (Clojure).&lt;/p&gt;

&lt;p&gt;Additional thanks to the posters on
&lt;a href=&#34;https://www.reddit.com/r/rust/comments/3egx49/language_safety_score_mark_2/&#34;&gt;/r/rust&lt;/a&gt;,
including &lt;a href=&#34;https://www.reddit.com/user/notriddle&#34;&gt;/u/notriddle&lt;/a&gt;,
&lt;a href=&#34;https://www.reddit.com/user/killercup&#34;&gt;/u/killercup&lt;/a&gt;, and
&lt;a href=&#34;https://www.reddit.com/user/diegobernardes&#34;&gt;/u/diegobernardes&lt;/a&gt; who put together the Rust score.&lt;/p&gt;

&lt;h2 id=&#34;complaints-department:97a282fd1f3c6848927d72787ebd3b6e&#34;&gt;Complaints Department&lt;/h2&gt;

&lt;p&gt;Did I mess up something about a language here, or am I missing a safety check? I&amp;rsquo;ll happily take pull
requests for new languages:
&lt;a href=&#34;https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders2.js&#34;&gt;blog source&lt;/a&gt;. Just
pick an existing language, edit the name and values, and &amp;ldquo;copy to clipboard&amp;rdquo; to
build your own language data structure. Send it to me in a PR and I&amp;rsquo;ll include
it along with a thanks on the page.&lt;/p&gt;

&lt;div ng-show=&#34;showRealName&#34;&gt;
&lt;span&gt;Select Language:
&lt;select ng-options=&#34;lang.name for lang in allLanguages&#34; ng-model=&#34;selectedLang&#34;&gt;&lt;/select&gt;
&lt;button ng-click=&#34;copyToClipboard(selectedLang)&#34;&gt;Copy Changes to Clipboard&lt;/button&gt;
&lt;/span&gt;
&lt;span&gt;&lt;input ng-model=&#34;selectedLang.name&#34;&gt;&lt;/input&gt;&lt;/span&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;&lt;th&gt;Check&lt;/th&gt;&lt;th&gt;Option&lt;/th&gt;&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;td style=&#34;background-color:{{scoreClass(score(selectedLang[check.key]))}} &#34;&gt;
{{ check.name }}: {{score(selectedLang[check.key]) }}
&lt;/td&gt;
&lt;td&gt;
&lt;select ng-options=&#34;enforcedNice(e) for e in enforcedTypes&#34; ng-model=&#34;selectedLang[check.key].enforced&#34;&gt;&lt;/select&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Case Study: Superior Domain Modeling in F#</title>
      <link>http://deliberate-software.com/pattern-matching-case-study/</link>
      <pubDate>Sat, 14 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/pattern-matching-case-study/</guid>
      <description>&lt;p&gt;Domain modeling in F# is significantly easier and safer than with the
traditional .NET languages. This is because of the increased safety of
pattern matching and the expressiveness of discriminated unions. These
concepts are not in C# or VB.NET, and therefore bring a new tool to
the table.&lt;/p&gt;

&lt;p&gt;To illustrate this, I found some old code I&amp;rsquo;d written to interact with
a legacy system. The system uses many single enums on a record to keep
track of statuses. When one changes, it can cause others to change as
well.&lt;/p&gt;

&lt;p&gt;Here is a typical function that combines two enums to recalculate a
third.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;        public static PositionType GetPositionType (MovementType movementType, ApplyToParty applyToParty)
        {
            if ((movementType == MovementType.Deliver &amp;amp;&amp;amp; applyToParty == ApplyToParty.Principal)
                || (movementType == MovementType.Return &amp;amp;&amp;amp; applyToParty == ApplyToParty.Counterparty))
                return PositionType.Held;
            if ((movementType == MovementType.Return &amp;amp;&amp;amp; applyToParty == ApplyToParty.Principal)
                || (movementType == MovementType.Deliver &amp;amp;&amp;amp; applyToParty == ApplyToParty.Counterparty))
                return PositionType.Posted;

            return PositionType.Undefined;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With some regularity, new records are added to these types of enums,
causing a dangerous search and update across the system fixing all the
if/else or switch/case statements.&lt;/p&gt;

&lt;p&gt;Right off the bat, pattern matching is a huge win here, taking a hard
to comprehend function and making the domain concepts clear.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let GetPositionType = function
    | Deliver, Principal | Return, Counterparty -&amp;gt; Held
    | Return, Principal | Deliver, Counterparty -&amp;gt; Posted
    | MovementType.Undefined, _ | _, ApplyToParty.Undefined -&amp;gt; PositionType.Undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we add a new status to any of these, we will get a compiler warning
in every place letting us know. If that alone was the win, we&amp;rsquo;d be
still be ahead by a lot. The domain is so clear here, I can print this
code out and hand it to my BA to ensure the logic is correct.&lt;/p&gt;

&lt;p&gt;Next though, this got me thinking. Why does this set of three enums
have to be calculated? Why are they even separate? Ah, of course,
right now they are stored in the database and ORM objects, each with a
separate field and set of enum ids. Changing that would be costly.&lt;/p&gt;

&lt;p&gt;What I want is a domain layer a level higher than the typical database
ORM classes, something to convert my ORM classes into that will be
able to do work in a safer way.&lt;/p&gt;

&lt;p&gt;Rather than three enums that are supposed to change in lock step (but
might get out of date), I really want a concept of the three combined
and &amp;ldquo;frozen&amp;rdquo; together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Direction = 
    | Held_Deliver_Principal
    | Held_Return_Counterparty
    | Posted_Return_Principal
    | Posted_Deliver_Counterparty
    
let GetDirection = function
   | Deliver, Principal  -&amp;gt; Held_Deliver_Principal
   | Return, Counterparty -&amp;gt; Held_Return_Counterparty
   | Return, Principal -&amp;gt; Posted_Return_Principal
   | Deliver, Counterparty -&amp;gt; Posted_Deliver_Counterparty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I have a combined Direction that merges the three concepts into
one. It is impossible with this new merged type to have an invalid
state across the three. Getting any of the types back out to convert
into the ORM classes or do some work is as simple as another match:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let GetMovementTypeToSaveInORM = function
   | Held_Deliver_Principal | Posted_Deliver_Counterparty -&amp;gt; Deliver
   | Posted_Return_Principal | Held_Return_Counterparty -&amp;gt; Return

let GetSendFn = function
   | Held_Deliver_Principal | Posted_Return_Principal -&amp;gt; SendMessageToPrincipal
   | Held_Return_Counterparty | Posted_Deliver_Counterparty -&amp;gt; SendMessageToCounterparty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While it is possible to make an equivalent C# enum and combine these
in a similar way, it is inherently unsafe (nothing to guarantee you
covered every case) and therefore appropriately uncommon. The typical
answer for safe polymorphic dispatch in C# is to use an interface and
classes. Unfortunately, something still has to dispatch on that enum
id, either inside a class or at the time of class instantiation. That
is a vector for errors.&lt;/p&gt;

&lt;p&gt;Because F# interops so well with C#, it is possible to build in a
domain layer in F# immediately that calls down to your C# ORM
classes. Converting from a set of dangerous C# enums into a
constrained and safe F# discriminated union is easy and will simplify
your domain to its essence.&lt;/p&gt;

&lt;p&gt;For reasons like this, when I have to build something with a rich
domain, I reach for F#.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming Language Safety Ranking</title>
      <link>http://deliberate-software.com/programming-language-safety-algorithm/</link>
      <pubDate>Tue, 17 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/programming-language-safety-algorithm/</guid>
      <description>&lt;script src=&#34;https://ajax.googleapis.com/ajax/libs/angularjs/1.3.14/angular.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://deliberate-software.com/javascripts/sliders.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;I think the time has come for a standard programming language safety
score. I want to use this model to help show that the concept of
safety is much more nuanced than a binary bit of &amp;ldquo;has strong-static
types&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;When someone says &amp;ldquo;programming language safety&amp;rdquo;, it typically invokes
thoughts of unit tests, long build times, and red squiggles in an
IDE. But, in day-to-day development, there are so many times when we
are bitten by things that somehow just slip through the cracks.&lt;/p&gt;

&lt;p&gt;I put together this scoring model to get a sense of how safe a
language is at the primitive level, and if it isn&amp;rsquo;t safe by default,
how much it costs to manually make it safe. Since all abstractions
eventually result in a series of primitive operations, I decided that
focusing only on primitives would still be a valuable (if incomplete)
data point. While any good library will handle all primitive checks
and present the consumer with a well-designed abstraction, in the end,
the consumer is still left wiring libraries together, building their
own primitive abstractions for integration. Due to the impossibility of
measuring the quality of abstractions in all libraries for a language,
I left that entirely out of scope of this model, unless it is designed
as a primitive check.&lt;/p&gt;

&lt;p&gt;By focusing on only primitive operations: making and calling
functions, naming data, working with sequences, and dealing with
language primitive data types, I slimmed down the large range of
possible error vectors to a small handful. While in some languages it
is common to use user-defined classes to wrap around a set of
primitives, those classes are still doing the same primitive work,
just hidden behind a user-created abstraction. The more ways it is
possible to make a &amp;ldquo;mistake&amp;rdquo; with a primitive, the more difficult it
is to build such good abstractions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This model is not about language &amp;quot;power&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This model is not about ranking the &amp;ldquo;power&amp;rdquo;, &amp;ldquo;expressiveness&amp;rdquo;, or
&amp;ldquo;abstract-ability&amp;rdquo; of a language. In any language that supports
abstractions (functions, classes, modules, naming data), I am
convinced, given enough code, all Turing complete langauges can do the
same work. This model is only about the costs to prevent unexpected
&amp;ldquo;confusion&amp;rdquo; between the programmer and the machine at the primitive
level.&lt;/p&gt;

&lt;p&gt;Rather than focus on what is &lt;em&gt;possible&lt;/em&gt; with a language, I will
instead focus on what is typically idiomatic to that community. For
example, if it is possible to achieve a level of safety in a language
but by doing something uncommon, that should not be counted.&lt;/p&gt;

&lt;p&gt;To score a language, simply figure out how many characters it costs to
&amp;ldquo;prevent&amp;rdquo; a certain type of error, and add that to the
total. Newlines, spaces, and tabs do not count, but all other
punctuation does. If a specific check is language enforced, like F#&amp;rsquo;s
Option or C#&amp;rsquo;s parameter type enforcement, that is given a -30 (by
default) to make up for the lack of unit tests and code exercising
needed to run that &amp;ldquo;path&amp;rdquo;. Do not count import lines for libraries, as
importing the module will have a negligible effect on the code size
and complexity.&lt;/p&gt;

&lt;p&gt;If there is a safety feature that is not possible to achieve
programmatically, we will add +30 (by default) for a &amp;ldquo;every change run
and debug to fix&amp;rdquo; cost, such as Java not having a way to prevent stack
overflow exceptions caused by recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A lower score is &amp;quot;safer&amp;quot;, needing less (or no) code to achieve the same level of safety.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than tell you my thoughts (or survey for) hard-coded
weightings, all checks are weighted the same by default. Feel free to
apply your own weightings, to better match to your or your team&amp;rsquo;s
specific needs and preferences. The languages are masked by default to
protect the innocent. You can unmask the names and see the code used
below the table.&lt;/p&gt;

&lt;div ng-app=&#34;TableApp&#34;&gt;
&lt;div ng-controller=&#34;TableCtrl&#34;&gt;

Language Enforced Bonus:
{{ enforcedScore }} 
&lt;input ng-model=&#34;enforcedScore&#34; type=&#34;range&#34; min=&#34;0&#34; max=&#34;50&#34; /&gt;

Language Inability Penalty:
{{ inabilityPenalty }} 
&lt;input ng-model=&#34;inabilityPenalty&#34; type=&#34;range&#34; min=&#34;0&#34; max=&#34;50&#34; /&gt;

Show Weights &lt;input type=&#34;checkbox&#34; ng-model=&#34;showWeights&#34; /&gt;
&lt;p class=&#34;lead&#34;&gt;
&lt;div style=&#34;overflow-x:scroll&#34;&gt;
&lt;table class=&#34;langtable&#34;&gt;
&lt;tr&gt;
&lt;th&gt;Safety Check&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[0]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[1]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[2]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;th&gt;
&lt;select ng-options=&#34;getName(lang) for lang in allLanguages&#34; ng-model=&#34;languages[3]&#34;&gt;&lt;/select&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr ng-repeat=&#34;check in langChecks&#34; score-row name=&#34;check.name&#34; row-key=&#34;check.key&#34;&gt;&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Totals&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ lang }} 
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;totals&#34;&gt;&lt;td&gt;Magnitude&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td ng-repeat=&#34;lang in langTotals track by $index&#34;&gt;
{{ percentageTotals(lang) }}% 
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;h3&gt;&lt;input ng-model=&#34;showRealName&#34; type=&#34;checkbox&#34; /&gt;&lt;span
ng-click=&#34;showRealName = !!!showRealName&#34;&gt;Click to see backing code and unmask names&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Current Languages:
&lt;span ng-repeat=&#34;lang in allLanguages&#34;&gt;
{{ getName(lang) }}: {{ allLangTotals[$index] }},
&lt;/select&gt;&lt;/p&gt;

&lt;p&gt;I want to see your language represented here! I&amp;rsquo;ll happily take pull
requests for new languages: &lt;a href=&#34;https://github.com/steveshogren/blog-source/blob/master/source/javascripts/sliders.js&#34;&gt;blog source&lt;/a&gt;. Just
use the &amp;ldquo;edit language&amp;rdquo; and &amp;ldquo;copy to clipboard&amp;rdquo; to build your own
language data structure.&lt;/p&gt;

&lt;p&gt;I would love to see every major language represented, including major
language &amp;ldquo;idiom communities&amp;rdquo;. For example, Clojure and Typed Clojure
are vastly different in abilities. Similarly &amp;ldquo;Scala - The Better Java&amp;rdquo;
and &amp;ldquo;Scala - The JVM Haskell&amp;rdquo; have vastly different idioms with
apparently very separate communities.&lt;/p&gt;

&lt;p&gt;Hope this is a helpful way to think about language safety!&lt;/p&gt;

&lt;p&gt;Special thanks to (in alphabetical order):
Patrick Boe &lt;a href=&#34;https://twitter.com/traffichazard/&#34;&gt;(twitter)&lt;/a&gt;,
Kyle Burton &lt;a href=&#34;http://asymmetrical-view.com/&#34;&gt;(blog)&lt;/a&gt;,
Daniel Miladinov &lt;a href=&#34;https://github.com/danielmiladinov&#34;&gt;(github)&lt;/a&gt;,
Chris Salch &lt;a href=&#34;https://github.com/arlaneenalra&#34;&gt;(github)&lt;/a&gt;, and
Tim Visher &lt;a href=&#34;https://github.com/timvisher&#34;&gt;(github)&lt;/a&gt;&lt;/p&gt;

&lt;div ng-show=&#34;showRealName&#34;&gt; Feel free to put in your own examples by playing
with the samples below. Code surrounded with &lt;! !&gt; is ignored from the tally,
since it would vary heavily based on the language and desired result. Variable
and type names are kept at single characters, which are counted. Feel free to
add in your own language below, and use the copy feature to extract the data
structure to use in a pull request.

&lt;div&gt;Select Language:
&lt;select ng-options=&#34;lang.name for lang in allLanguages&#34; ng-model=&#34;selectedLang&#34;&gt;&lt;/select&gt;
&lt;/div&gt;
&lt;button ng-click=&#34;showEdit = !showEdit&#34;&gt;Edit Language&lt;/button&gt;
&lt;button ng-click=&#34;copyToClipboard(selectedLang)&#34;&gt;Copy Changes to Clipboard&lt;/button&gt;
&lt;div ng-show=&#34;showEdit&#34;&gt;
&lt;span&gt;&lt;input ng-model=&#34;selectedLang.name&#34;&gt;&lt;/input&gt;&lt;/span&gt;
&lt;div ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;h3&gt;{{ check.name }} : {{ score(selectedLang[check.key]) }}  &lt;/h3&gt;
&lt;p&gt;
&lt;textarea class=&#34;widetextarea&#34; rows=&#34;5&#34; ng-model=&#34;selectedLang[check.key].desc&#34;&gt;&lt;/textarea&gt; 
&lt;div&gt;
Code: &lt;select ng-options=&#34;enforcedNice(e) for e in enforcedTypes&#34; ng-model=&#34;selectedLang[check.key].enforced&#34;&gt;&lt;/select&gt;
&lt;div class=&#34;tablecode&#34;&gt;1234567890123456789012345678901234567890&lt;/div&gt;
&lt;div class=&#34;tablecode&#34; &gt; {{ cleanCode(selectedLang[check.key].rawCode) }}  &lt;/div&gt;
&lt;input type=&#34;text&#34; style=&#34;width:90%;&#34; ng-model=&#34;selectedLang[check.key].rawCode&#34; /&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div ng-show=&#34;!showEdit&#34;&gt;
&lt;span&gt;{{ selectedLang.name }} &lt;/span&gt;
&lt;div ng-repeat=&#34;check in langChecks&#34;&gt;
&lt;h3&gt;{{ check.name }} : {{ score(selectedLang[check.key]) }}  &lt;/h3&gt;
&lt;p&gt;
{{ selectedLang[check.key].desc }} 
&lt;div&gt;
Code: {{ enforcedNice(selectedLang[check.key].enforced)  }} 
&lt;div class=&#34;tablecode&#34; ng-if=&#34;selectedLang[check.key].rawCode&#34;&gt;1234567890123456789012345678901234567890&lt;/div&gt;
&lt;div class=&#34;tablecode&#34; &gt; {{ cleanCode(selectedLang[check.key].rawCode) }}  &lt;/div&gt;
&lt;input type=&#34;text&#34; style=&#34;width:90%;&#34; ng-model=&#34;selectedLang[check.key].rawCode&#34; /&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Six Unusual Reasons why Clojure is a Delight</title>
      <link>http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight/</link>
      <pubDate>Mon, 09 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/unusual-reasons-why-clojure-is-a-delight/</guid>
      <description>

&lt;p&gt;Clojure is a delightful language, and here are six uncommonly
discussed reasons why.&lt;/p&gt;

&lt;h2 id=&#34;1-dead-simple-unit-test-mocking:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;1 - Dead Simple Unit Test Mocking&lt;/h2&gt;

&lt;p&gt;Clojure is the easiest language to unit test I have ever
seen. &amp;ldquo;Mocking&amp;rdquo; a function in a test only requires a simple
replacement of the function definition. No extraneous interfaces, no
dependency injection, no mocking framework.  The built-in function &lt;code&gt;with-redefs&lt;/code&gt;
will replace any function in any library or
namespace with a new definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn next-id [connection]
  (+ 1 (get-current-id connection)))

(testing &amp;quot;next-id&amp;quot;
  ;; bind get-current-id to a lambda that always returns 4 
  (with-redefs [get-current-id (fn [_] 4)]
    (is (= 5 (next-id nil)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &amp;ldquo;mock&amp;rdquo; the &lt;code&gt;get-current-id&lt;/code&gt; function to always return 4 inside
the scope of &lt;code&gt;with-redefs&lt;/code&gt;. Couldn&amp;rsquo;t be more simple! The binding
only is in scope for code inside and called by the s-expression of the
with-redefs, so no need to unbind it after the test.&lt;/p&gt;

&lt;h2 id=&#34;2-amazing-editing:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;2 - Amazing Editing&lt;/h2&gt;

&lt;p&gt;Many arguments have been made over those contentious
parentheses. While the most powerful use of s-expressions is to easily
allow macros, for the day to day, s-expressions have a very important
use: amazing editing!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://danmidwood.com/assets/animated-paredit/paredit-slurp-barf.gif&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;With ParEdit (available in most editors), it is trivial to select,
move, replace, grow, or shrink any s-expression, string, map, or
list. &lt;a href=&#34;http://danmidwood.com/content/2014/11/21/animated-paredit.html&#34;&gt;This animated guide&lt;/a&gt;
shows excellent examples of ParEdit that are too
complex to explain here.&lt;/p&gt;

&lt;p&gt;Languages that don&amp;rsquo;t have a surrounding delimiter for expressions
leave you jumping around with the mouse and arrow keys a whole lot more.
Because it is so much easier to write a parser to select &lt;code&gt;(add 1 2)&lt;/code&gt;
than it is for &lt;code&gt;add(1, 2)&lt;/code&gt;, the tooling can be so much better.&lt;/p&gt;

&lt;p&gt;No local editing tool I have seen comes close to Vim with ParEdit for
effective editing.&lt;/p&gt;

&lt;h2 id=&#34;3-live-attached-repl:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;3 - Live Attached Repl&lt;/h2&gt;

&lt;p&gt;Developing in Clojure against a running version of the program is a
huge bonus for development speed. While possible to get similar
behavior with an attached debugger in other languages, the fluidity of
an always-on live attached repl is incredible. At any point, it is
possible to run and rerun any given expression to see the
results. More than once, I have seen an exception caused by calling a
certain function. I trace that function to see the exact inputs that
cause the exception, and am able to quickly run every line of the
offending function to see the source.&lt;/p&gt;

&lt;p&gt;If a debugger sheds light on a single line at a time when running an
application, a live attached repl sheds light on the entire
application.&lt;/p&gt;

&lt;h2 id=&#34;4-no-fuss-polymorphism:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;4 - No-fuss Polymorphism&lt;/h2&gt;

&lt;p&gt;One of the best claims about &amp;ldquo;traditional&amp;rdquo; Java OO is
polymorphism. The ability to make an interface with concrete classes
gives the powerful ability to replace behavior dynamically. The
trouble is, Java&amp;rsquo;s polymorphic dynamic dispatch is single dispatch - the
decision of which method to call is limited to a single thing: the
type of the callee. If this was the only type of dynamic dispatch you
ever knew of, it might be hard for you to consciously realize it was
ever a limitation, especially if you&amp;rsquo;ve never seen examples of
multiple dispatch.&lt;/p&gt;

&lt;p&gt;While most of the time, in any language with first class functions, it
is possible to achieve a similar effect by passing functions, it is
also possible to get a similar value with something called multimethods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti speak :animal)
(defmethod speak :dog [this] (str &amp;quot;woof says &amp;quot; (:name this)))
(defmethod speak :cat [this] (str &amp;quot;mow says &amp;quot; (:name this)))

(speak {:animal :dog :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;woof says Spike&amp;quot;
(speak {:animal :cat :id 2 :name &amp;quot;Mr Cat&amp;quot;})
;; =&amp;gt; &amp;quot;mow says Mr Cat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we use the &lt;code&gt;:animal&lt;/code&gt; keyword to be the &amp;ldquo;route&amp;rdquo; function,
and the two methods fill in two of the possible concrete types. We are
not limited to just a keyword, we can dispatch on anything on the
passed map, for example, the oddness of the id:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti odds? (comp odd? :id))
(defmethod odds? true [d] &amp;quot;odd id&amp;quot;)
(defmethod odds? false [c] &amp;quot;even id&amp;quot;)

(odds? {:animal :dog :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;odd id&amp;quot;
(odds? {:animal :cat :id 2 :name &amp;quot;Mr Cat&amp;quot;})
;; =&amp;gt; &amp;quot;even id&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While both examples are a bit silly, they should demonstrate the power
of simple polymorphism. But you might think, what about inheritance?
Multimethods allow that too!&lt;/p&gt;

&lt;h2 id=&#34;5-simple-multiple-inheritance:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;5 - Simple Multiple Inheritance&lt;/h2&gt;

&lt;p&gt;We don&amp;rsquo;t build inheritance on a single type, but on a hierarchy of
keywords. Those can be dispatched on just like any other
keyword. First, an example hierarchy of keywords using the built-in
functions &lt;code&gt;derive&lt;/code&gt; and &lt;code&gt;isa?&lt;/code&gt;. These &lt;code&gt;::&lt;/code&gt; keywords are
namespaced, which prevents collisions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(derive ::cat ::mammal)
(derive ::dog ::mammal)
(derive ::dog ::hairy)
(derive ::poodle ::dog)

(isa? ::poodle ::dog)
;; =&amp;gt; true
(isa? ::poodle ::mammal)
;; =&amp;gt; true
(isa? ::poodle ::hairy)
;; =&amp;gt; true
(isa? ::poodle ::cat)
;; =&amp;gt; false
(isa? ::mammal ::hairy)
;; =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;::dog&lt;/code&gt; is-a &lt;code&gt;::mammal&lt;/code&gt; and is-a &lt;code&gt;::hairy&lt;/code&gt;, the
classical diamond problem (without the common ancestor, which is
possible, but unneeded for the example).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmulti speak :animal)
(defmethod speak ::poodle [d] &amp;quot;chirps&amp;quot;)
(defmethod speak ::mammal [c] &amp;quot;breathes&amp;quot;)

(speak {:animal ::poodle :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;chirps&amp;quot;
(speak {:animal ::dog :id 2 :name &amp;quot;Mr Dog&amp;quot;})
;; =&amp;gt; &amp;quot;breathes&amp;quot;

(defmulti shave :animal)
(defmethod shave ::poodle [d] &amp;quot;shivers&amp;quot;)
(defmethod shave ::hairy [c] &amp;quot;stuggles&amp;quot;)
(defmethod shave ::mammal [c] &amp;quot;maybe cant be shaved!&amp;quot;)
(prefer-method shave ::hairy ::mammal)

(shave {:animal ::poodle :id 1 :name &amp;quot;Spike&amp;quot;})
;; =&amp;gt; &amp;quot;shivers&amp;quot;
(shave {:animal ::dog :id 2 :name &amp;quot;Rufs&amp;quot;})
;; =&amp;gt; &amp;quot;stuggles&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see the &lt;code&gt;::dog&lt;/code&gt; keyword doesn&amp;rsquo;t have an explicit speak or shave
implementation, which is fine, because it will then use the &amp;ldquo;preferred&amp;rdquo;
parent implementation, which returns &amp;ldquo;breathes&amp;rdquo; for speak or
&amp;ldquo;struggles&amp;rdquo; for shave. Since we can have a keyword be the child of
multiple parents, we get a multiple inherited behavior, where the
preferred match is the one returned.&lt;/p&gt;

&lt;p&gt;This is possible because the default equality check of multimethod is
the &lt;code&gt;isa?&lt;/code&gt; function. Because of this, uses of multimethod
hierarchies can have inherited behavior for complex structures.&lt;/p&gt;

&lt;h2 id=&#34;6-mostly-monadic:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;6 - Mostly Monadic&lt;/h2&gt;

&lt;p&gt;Languages like Haskell and F# have tools like the maybe monad that add
safety to operations. For example, using the maybe monad can
completely prevent null reference exceptions by making you ensure you
&amp;ldquo;unpack&amp;rdquo; the value every time.&lt;/p&gt;

&lt;p&gt;How does Clojure address this? In a typical Clojure way, which gives
80% of the value for 20% of the effort, Clojure has a great
relationship with empty lists and nil. Rather than wrapping every
value that is nullable in a type, Clojure&amp;rsquo;s default functions all
&lt;em&gt;mostly&lt;/em&gt; deal with nil and empty without throwing exceptions. For
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(get {:id 5} :id)
;; =&amp;gt; 5
(get nil :id)
;; =&amp;gt; nil

(first [3 2 1])
;; =&amp;gt; 3
(first nil)
;; =&amp;gt; nil
(count nil)
;; =&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows functions to be chained without fear that along the way a
nil will get returned.&lt;/p&gt;

&lt;p&gt;Since most of the core functions are &amp;ldquo;smart&amp;rdquo; about nil, you gain much
of the value and safety of monads without most of the
hassle. Ultimately, a more rich type system would allow for custom
types which can be domain specific, but in day-to-day working,
primitive safety is still a huge win.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:8b20eb90a7bf5bd93e271e1b65cf0feb&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;These are a few simple features that keep me coming back to Clojure,
even from languages like F# and Haskell. While Clojure is a bit more
wordy than the ML family, and not as type safe, the simplicity of
these features keep me coming back for more!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Christmas F# Polymorphism</title>
      <link>http://deliberate-software.com/christmas-f-number-polymorphism/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/christmas-f-number-polymorphism/</guid>
      <description>&lt;p&gt;One of my favorite things about F# is how it lets you choose how you want
to align your data.&lt;/p&gt;

&lt;p&gt;In the previous posts highlighting on
&lt;a href=&#34;http://deliberate-software.com/function-pattern-matching/&#34;&gt;pattern matching&lt;/a&gt;
and
&lt;a href=&#34;http://deliberate-software.com/inversed-polymorphism/&#34;&gt;inverted polymorphism&lt;/a&gt;
we covered how pattern matching in F# is safer than &lt;code&gt;if&lt;/code&gt;
statements and can replace classes and interfaces for polymorphism. If
you are unfamiliar with these concepts, you might want to skim those
first.&lt;/p&gt;

&lt;p&gt;Today, for the 6th day of the
&lt;a href=&#34;https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/&#34;&gt;F# Advent Calendar&lt;/a&gt;
I wanted to highlight F#&amp;rsquo;s flexibility in solving the
&amp;ldquo;&lt;a href=&#34;http://c2.com/cgi/wiki?ExpressionProblem&#34;&gt;expression problem&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s show the two alternatives, first here is one with interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IChristmasTrees = 
    abstract member Cost : int -&amp;gt; int
    abstract member Colors : unit -&amp;gt; string list
    
type PlasticTree() =
    interface IChristmasTrees with
        member this.Cost(jolly_factor) = (100 * jolly_factor) / 2
        member this.Colors() = [&amp;quot;green&amp;quot;;&amp;quot;silver&amp;quot;]
        
type LiveTree() =
    let HEAD_ACHE = 15
    interface IChristmasTrees with
        member this.Cost(jolly_factor) = (jolly_factor + 10) * HEAD_ACHE
        member this.Colors() = [&amp;quot;green&amp;quot;;&amp;quot;brown&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the same functionality using pattern matching and discriminated unions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IChristmasTrees2 =
  | PlasticTree
  | LiveTree

let colors = function
  | PlasticTree -&amp;gt; [&amp;quot;green&amp;quot;;&amp;quot;silver&amp;quot;]
  | LiveTree -&amp;gt; [&amp;quot;green&amp;quot;;&amp;quot;brown&amp;quot;]

let cost tree jolly_factor =
  match tree with
    | PlasticTree -&amp;gt; (100 * jolly_factor) / 2
    | LiveTree -&amp;gt;
      let HEAD_ACHE = 15
      (jolly_factor + 10) * HEAD_ACHE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What changes if we want to add a new type of tree? In the class-based
example, adding a new type is quite simple, you only need to edit one
place to find all the definitions regarding the new type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/new-interfaces.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;In the pattern matching example, adding a new type requires editing
every single place you created a function that matches on the
type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/new-pattern-matching.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Thankfully, in both cases the compiler gives warnings about missing
functions or matches, so both are equally &amp;ldquo;safe&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;What about changing an existing function or adding a new function? We
now see the opposite behavior. Classes become harder to edit, because
the functions are spread across multiple classes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/change-interfaces.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;A pattern matching system is now the easier to modify, each function
only lives in one place.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/change-pattern-matching.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;And that is the expression problem! The best thing about F# is that
you get to pick which one is better for each type of data! If you know
a certain type will need new behavior often, but rarely need new
types, use pattern matching. If you know there is a static set of
functions for a set of types, but the type list changes often, maybe
the traditional interfaces and classes makes the most sense.&lt;/p&gt;

&lt;p&gt;There is no reason not to mix and match the two ways to handle
polymorphism, so you are free to choose the best representation for
each type of data you have!&lt;/p&gt;

&lt;p&gt;Happy F#-filled Festivities!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Emacs Project Tip</title>
      <link>http://deliberate-software.com/emacs-project-tip/</link>
      <pubDate>Sat, 06 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/emacs-project-tip/</guid>
      <description>&lt;p&gt;I recently have been working in a Clojure project which is made up of
several microservices. While trying to build in a secure method for
each service to be able to call the others, I&amp;rsquo;ve been in several
different projects at the same time.&lt;/p&gt;

&lt;p&gt;At least once I accidentally opened the wrong &amp;ldquo;handler.clj&amp;rdquo; buffer,
and spent a few minutes adding a function that never worked. Since I
hate doing things like this, I wanted a simple way to see what project
I was currently viewing.&lt;/p&gt;

&lt;p&gt;I started with a changing the title of the frame to show the whole
path of the current buffer, like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/title.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The code to change the title is simple, and the default in some of the
pre-packaged emacs bundles:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(setq frame-title-format
      &#39;((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 &amp;quot;%b&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is fine, but still not great. The font is tiny and the important
part: &amp;ldquo;octopress&amp;rdquo; is buried. I wanted something a little more fluid,
so I could easily tell the different projects apart instantly. I came
up with the idea to color the background faintly different based on
the path of the file. Files with a path containing &amp;ldquo;octopress&amp;rdquo; might
be different from those containing &amp;ldquo;.emacs&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Thankfully, &lt;code&gt;buffer-face-mode&lt;/code&gt; makes it easy to change a single
property of a single buffer&amp;rsquo;s face without changing any other
buffer. So long as you disable buffer-face-mode when closing emacs,
your files will open with the correct coloring scheme, then have the
new background overlaid.&lt;/p&gt;

&lt;p&gt;While not perfect, this was the result.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/colors.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The colors I choose are only faintly different, but just enough for me
to tell instantly which is which.&lt;/p&gt;

&lt;p&gt;The buffer colors are applied when opening a file, using these
functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defun my-buffer-face-mode-variable (color)
  (interactive)
  (setq buffer-face-mode-face (list :background color))
  (buffer-face-mode 1))

(defun my-set-theme-on-mode ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (cond
    ;; add your own project/color mappings here
     ((string-match &amp;quot;halcyon&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;#00001A&amp;quot;))
     ((string-match &amp;quot;dwarf&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;#001A1A&amp;quot;))
     ((string-match &amp;quot;nimbus&amp;quot; file-name) (my-buffer-face-mode-variable &amp;quot;black&amp;quot;))
     (t &amp;quot;&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To force them to run when opening a file, since I use helm, I set it
to execute on exiting helm for any reason:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(add-hook &#39;helm-after-action-hook &#39;my-set-theme-on-mode)
;; uncomment if not using helm
;; (add-hook &#39;find-file-hook &#39;my-set-theme-on-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, to make sure emacs applies my normal theme and settings to a
buffer when starting, I disable buffer-face-mode on all buffers before
exiting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-common-lisp&#34;&gt;(defun disable-all-buffer-face-mode ()
  (interactive)
  (let ((current (get-buffer (current-buffer))))
    (-map (lambda (x) (progn (switch-to-buffer x)
                             (buffer-face-mode 0))) (buffer-list))
    (switch-to-buffer current 1)))

(add-hook &#39;kill-emacs-hook &#39;disable-all-buffer-face-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block needs &lt;a href=&#34;https://github.com/magnars/dash.el&#34;&gt;dash.el&lt;/a&gt; to get
the -map function.&lt;/p&gt;

&lt;p&gt;While not the only solution, this seemed a simple and elegant way to
quickly be reminded of your current project.&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Suggested Skill Progression</title>
      <link>http://deliberate-software.com/skill-continuum/</link>
      <pubDate>Tue, 02 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/skill-continuum/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Learning Vim is a waste of time; I can prove it! - Anonymous&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I recently had a gentle discussion with a new teammate about whether
or not they should learn to use Vim. My team uses a Vim emulator
inside Visual Studio and Emacs, and so we recommended he learn at
least the basics so to reduce friction when pair-programming (which we
do almost all the time).&lt;/p&gt;

&lt;p&gt;He really had no desire to learn it, and took no small amount of
offense when we suggested it. The friction he felt trying to &amp;ldquo;start
over&amp;rdquo; really bothered him. He set out to prove that Vim was not worth
his time, and that it was actually us who needed to stop using it,
because we were the duped slow ones.&lt;/p&gt;

&lt;p&gt;As any such localized experiments go, he never really came up with
anything conclusive either way. Personally, I suspect he spent more
time trying to figure out why Vim was worse than if he had just
buckled down and learned it. This got me thinking about skills we
learn as developers, and how much they cost.&lt;/p&gt;

&lt;h1 id=&#34;skills:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Skills&lt;/h1&gt;

&lt;p&gt;Most skills fall along a continuum of tactical to strategic.&lt;/p&gt;

&lt;h3 id=&#34;tactical-skills:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Tactical Skills&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Typing speed/accuracy&lt;/li&gt;
&lt;li&gt;Keyboard shortcuts&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Mouse-free&amp;rdquo; editing systems: Vim, Emacs&lt;/li&gt;
&lt;li&gt;Clean coding practices&lt;/li&gt;
&lt;li&gt;Refactoring tools&lt;/li&gt;
&lt;li&gt;Repl Driven Development / Test Driven Development&lt;/li&gt;
&lt;li&gt;Debugging&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;mid-way-skills:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Mid-way Skills&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Unit testing&lt;/li&gt;
&lt;li&gt;Building abstractions&lt;/li&gt;
&lt;li&gt;Designing simple solutions&lt;/li&gt;
&lt;li&gt;Automating tasks&lt;/li&gt;
&lt;li&gt;Learning new languages and frameworks&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strategic-skills:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Strategic Skills&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Gathering requirements&lt;/li&gt;
&lt;li&gt;Training developers&lt;/li&gt;
&lt;li&gt;Organizing and leading teams&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Understanding the real problem&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The more strategic the skills, the &amp;ldquo;softer&amp;rdquo; they become. The reason for this is
that soft skills often allow for the greatest leverage on a project.&lt;/p&gt;

&lt;p&gt;Why is this?&lt;/p&gt;

&lt;p&gt;Consider the developer, who by more accurately gathering requirements for a few
extra days, realizes that the stakeholder can use a preexisting solution instead
of a six month planned project. If you consider how many keystrokes he saved,
there is no way he could have typed fast enough to make up six months of effort.
Unless he can type out a six month project in a few days, his time was better
spent where it was. Obviously, these opportunities do not happen all the time,
but they &lt;em&gt;do&lt;/em&gt; happen and it doesn&amp;rsquo;t take more than one or two a year to have
major impact!&lt;/p&gt;

&lt;p&gt;Think about the return on investment for training developers. If you have an
average team (and yes, we all do), there is a good chance you have some lower
performing developers. I have witnessed many times where a few months of pairing
to brush up the skills of a less skilled developer allowed them to become much
more productive. In terms of total company effort, that small investment paid
back many times before the end of the year as the newly trained developer was
able to tackle their work with the renewed vigor that comes from a greater
mastery of their work.&lt;/p&gt;

&lt;p&gt;Similarly, the judicious use of automation for deployment, testing, and building
greatly reduces the friction of development for entire teams. Lowered friction
means less cognitive burden.&lt;/p&gt;

&lt;p&gt;That being said, I think there comes a point where you have to put fingers to
keyboard and actually produce working software. Of course, the fastest and best
software is the software you never have to write. But, when you absolutely must
write or modify software, the ability to execute is essential. Tactical skills
increase in significance the closer you get to the work.&lt;/p&gt;

&lt;p&gt;While a great software tactician will never &amp;ldquo;beat&amp;rdquo; a great strategist in terms
of raw business value, a great strategist that is a terrible tactician can only
talk their way out of work. A strategist who forgets or ignores good tactics is
what we call an &amp;ldquo;architecture astronaut&amp;rdquo; or an &amp;ldquo;ivory tower architect&amp;rdquo;. These
disconnected strategists eventually start to remove business value as their
solutions make less and less practical sense.&lt;/p&gt;

&lt;p&gt;I think a developer who wants to improve should make sure they are improving all
across the spectrum. Don&amp;rsquo;t focus only on strategic or tactical skills, but seek
projects and teams that will allow you to gain skills across the board. I like
to try to focus on one skill from each side of the continuum each year. This
year, it is emacs automation and monads on the tactical side, and leading mature
teams on the strategic. By alternating readings, I find fuel to apply the
strategies using these new tactics!&lt;/p&gt;

&lt;p&gt;Lastly, on the subject of &amp;ldquo;what to study&amp;rdquo;, I think it is possible to study a
number of subjects all across the continuum. Unless you have weeks where you
never type any code at all, you can practice and learn new tactical techniques
all the time. If it slows you down today, but speeds you up next week, it might
just be worth it. Even if it slowed you down to a quarter your usual speed for
two weeks, but then gives you a measly 5% boost to productively after that,
you&amp;rsquo;ll earn that time back by the end of the year, plus some. And 5% is not hard
to do. I&amp;rsquo;d guess learning a few new navigation or refactoring shortcuts would
net you 5% easily.&lt;/p&gt;

&lt;p&gt;When studying more strategic skills, the same holds, but they are harder to
learn. The best way I have found for learning strategic skills is to read books
about it, and try to work around others who are good at it. Neither books or
working with others will get you all the way there, you also have to apply it
yourself.&lt;/p&gt;

&lt;h1 id=&#34;progression:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Progression&lt;/h1&gt;

&lt;p&gt;I usually recommend that the more experienced a person is, the more mastery they
should have in the tactical skills. A suggested path I&amp;rsquo;ve recommended for a new
developer would look like this:&lt;/p&gt;

&lt;h3 id=&#34;0-6-months:32c130b82f3d281900b59a4e4247f69d&#34;&gt;0 - 6 Months:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Typing speed/accuracy&lt;/li&gt;
&lt;li&gt;Keyboard shortcuts&lt;/li&gt;
&lt;li&gt;Repl Driven Development / Test Driven Development&lt;/li&gt;
&lt;li&gt;Unit testing&lt;/li&gt;
&lt;li&gt;Clean coding practices&lt;/li&gt;
&lt;li&gt;Designing simple solutions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0-2-years:32c130b82f3d281900b59a4e4247f69d&#34;&gt;0 - 2 Years:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Debugging&lt;/li&gt;
&lt;li&gt;Refactoring tools&lt;/li&gt;
&lt;li&gt;Building abstractions&lt;/li&gt;
&lt;li&gt;Automating tasks&lt;/li&gt;
&lt;li&gt;Learning new languages and frameworks&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Mouse-free&amp;rdquo; editing systems: Vim, Emacs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0-50-years:32c130b82f3d281900b59a4e4247f69d&#34;&gt;0 - 50+ Years:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Gathering requirements&lt;/li&gt;
&lt;li&gt;Training developers&lt;/li&gt;
&lt;li&gt;Organizing and leading teams&lt;/li&gt;
&lt;li&gt;Understanding the real problem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is not a hard and fast list. If you are completely unsure of what to learn,
I recommend this rough progression just to get you started. If you are a two
year developer, and you cannot touch type, I think learning it can really help,
alongside the other 0 - 2 year skills.&lt;/p&gt;

&lt;p&gt;Not all skills along the list build on a mastery of the ones below it. A
developer can absolutely get to a very senior mastery of the strategic skills
only knowing one language and using notepad.exe. I believe that they are missing
out on a deep richness that comes from better knowing their field, and I suggest
they spend some time learning new languages and tools. The more tactical the
skill, usually, the easier it is to learn, so it won&amp;rsquo;t take very much time to
come up to speed.&lt;/p&gt;

&lt;p&gt;The hardest thing I think a more senior developer has to deal with is humbling
themselves to learn a perceived &amp;ldquo;entry-level&amp;rdquo; skill. I have another post brewing
about this very topic, so I&amp;rsquo;ll not get too much into it here. But if you have
gotten to a place where you feel like you are so senior that some skills are too
&amp;ldquo;entry-level&amp;rdquo; for you to learn, I think you need to humble yourself and learn
them. Nothing can be gained from pretending like they are not valuable.
Additionally, the assumption that your time is now so valuable that it is &amp;ldquo;a
waste&amp;rdquo; to spend it on learning tactical skills is absurd.&lt;/p&gt;

&lt;p&gt;Claiming you are too good to waste on low level skills not only belittles
everyone around you, but belies a deep misunderstanding of our field. The senior
developer who takes five times as long to enter and edit code isn&amp;rsquo;t just
spending longer to do that task, but they are paying a missed opportunity cost
in time they could have spent in more strategic endeavors. They could have been
training, planning, gathering requirements, building better automation, etc,
instead they stubbornly claim &amp;ldquo;typing isn&amp;rsquo;t what software is about&amp;rdquo;. By giving
it so little credence, they have made it most of their actual mental effort!
Take simple touch-typing. Imagine how much mental effort it takes the
hunt-and-peck typist to write out a single line of code. That is mental overhead
that is simply wasted. The developer who doesn&amp;rsquo;t have to think about how to move
a file or edit a structure finds themselves quickly through the tactical efforts
with little distraction, free to think deeply.&lt;/p&gt;

&lt;h1 id=&#34;resources:32c130b82f3d281900b59a4e4247f69d&#34;&gt;Resources&lt;/h1&gt;

&lt;p&gt;Here are some links and books to get you started on these topics.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Typing speed/accuracy - &lt;a href=&#34;http://store.steampowered.com/agecheck/app/246580/&#34;&gt;Typing of the Dead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Mouse-free&amp;rdquo; editing systems: Vim, Emacs - &lt;a href=&#34;http://vim-adventures.com/&#34;&gt;Vim Adventures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clean coding practices - &lt;a href=&#34;https://cleancoders.com/&#34;&gt;Clean Coders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Repl Driven Development - &lt;a href=&#34;http://blog.jayfields.com/2014/01/repl-driven-development.html&#34;&gt;RDD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Test Driven Development - &lt;a href=&#34;http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530&#34;&gt;http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debugging - &lt;a href=&#34;http://c.learncodethehardway.org/book/ex31.html&#34;&gt;Debugging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Building abstractions / Designing Simple Solutions - &lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start&#34;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Training developers - &lt;a href=&#34;http://en.wikipedia.org/wiki/Pair_programming&#34;&gt;Pair Programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Organizing and leading teams - &lt;a href=&#34;http://managinghumans.com/&#34;&gt;Managing Humans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Understanding the real problem - &lt;a href=&#34;http://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow&#34;&gt;Thinking Fast and Slow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Learning new languages and frameworks - &lt;a href=&#34;http://norvig.com/21-days.html&#34;&gt;Teach Yourself Programming in Ten Years&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Automating tasks &lt;a href=&#34;http://www.stuartellis.eu/articles/rake/&#34;&gt;Rake to Automate Tasks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What Book Should I Read Next?</title>
      <link>http://deliberate-software.com/next-book/</link>
      <pubDate>Sat, 26 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/next-book/</guid>
      <description>

&lt;p&gt;Edit: As a supplement to this: check out my &lt;a class=&#34;homelink&#34;
href=&#34;/page/books&#34;&gt;favorite books&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;It&amp;rsquo;s my first job, what book should I read first?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Recently, a few developers I am mentoring were curious about what book
to read first. Even mid and senior level developers I&amp;rsquo;ve known
sometimes struggle with this question.&lt;/p&gt;

&lt;p&gt;If you want to be truly great, you have to read technical books and
white papers, and you have to learn new programming languages. You
could figure the content out yourself from first principles, but you
will be about 50 years behind those who just read the
books. Additionally, if you stick to a certain language, you are
limiting yourself to only thinking about a problem in a way common to
the language.&lt;/p&gt;

&lt;p&gt;Just like with adding new features to a project, you should prioritize
your learning.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d start by getting into the mindset that you will need roughly a
decade and at least ten thousand high quality hours to become a master
programmer. To be able to get that many high-value hours, you will
need to carefully select your jobs, and constantly be learning new
things that actually make you a better developer.&lt;/p&gt;

&lt;h2 id=&#34;languages:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Languages&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;A language that doesn&#39;t affect the way you think about programming,
    is not worth knowing.&amp;quot; - Alan Perlis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I agree with &lt;a
href=&#34;http://michaelochurch.wordpress.com/2012/07/27/six-languages-to-master/&#34;&gt;other developers&lt;/a&gt; who assert that a language is &lt;a
href=&#34;http://en.wikiquote.org/wiki/Alan_Perlis&#34;&gt;not worth learning&lt;/a&gt;
unless it teaches you something new and mind-expanding. There are exceptions of course. Maybe you want to switch stacks to get an awesome high-value job. By all means, learn the new stack.&lt;/p&gt;

&lt;p&gt;If you want to follow the extremely good &lt;a
href=&#34;http://pragprog.com/the-pragmatic-programmer&#34;&gt;advice of others&lt;/a&gt; and learn one new programming language a year, make each
one count. For example, if you are a Ruby guy, it is safe to say you
will learn nothing of really any mind-expanding value if you try to
learn PHP, Python, JavaScript, or Perl.&lt;/p&gt;

&lt;p&gt;Same for the family of Java, C++, C#, or VB.NET. One of those is plenty.&lt;/p&gt;

&lt;p&gt;Instead shoot for languages that will really beef up your thought
process. I like the advice given by &lt;a href=&#34;http://norvig.com/21-days.html&#34;&gt;Peter Norvig&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     &amp;quot;Learn at least a half dozen programming languages. Include one
     language that supports class abstractions (like Java or C++), one that
     supports functional abstraction (like Lisp or ML), one that supports
     syntactic abstraction (like Lisp), one that supports declarative
     specifications (like Prolog or C++ templates), one that supports
     coroutines (like Icon or Scheme), and one that supports parallelism
     (like Sisal).&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I would add to that my own personal list: a language that forces you
to use monands for controlling side-effects (Haskell), and a language
that allows for dependent types (Idris).&lt;/p&gt;

&lt;p&gt;If you are saying, &amp;ldquo;wow, in Python, you have to put a colon at the end
of the function signature line, unlike in Ruby, that blows my mind&amp;rdquo;,
or &amp;ldquo;wow, in Java, the String keyword is uppercase instead of
lowercase!&amp;rdquo; chances are you are getting a very low return for your
investment of time.&lt;/p&gt;

&lt;p&gt;What is important about a new language is &lt;em&gt;not&lt;/em&gt; a new syntax. A new
syntax is just cruft that gets in the way of the new concepts. A new
concept might be closures. If you have always worked in Java, a
closure will really expand your mind. Or macros. If you have never
seen macros, the concept alone is completely foreign, not just the
syntax. That is where the value is. A good test if you are learning
something new is if you have to research what the concept even means,
without even needing to see the syntax first. For example, when I
started learning monads, I didn&amp;rsquo;t even need to see the syntax for how
Haskell does them, I didn&amp;rsquo;t even understand the concept &lt;em&gt;at all&lt;/em&gt;, so I
could read pretty much anything about the concept and get value out of
it. That is the high value content.&lt;/p&gt;

&lt;h2 id=&#34;frameworks:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Frameworks&lt;/h2&gt;

&lt;p&gt;I would say very few frameworks are going to expand your mind in a way
that is worth the effort to learn them. Some very select frameworks
can cause you to think of a problem in a novel way and thus expand
your mind (off the top of my head: React.js, Core.Async, Akka,
Datomic) but those are very few and far between.&lt;/p&gt;

&lt;p&gt;Obviously, in production use, frameworks have their place, and they
can provide an immense boost to your day-to-day productivity and
safety, but very few overall will expand your mind in such a way that
would make you better at the craft. It is not hard to reason why. A
framework can only do what is possible in the language. If the
language is only so powerful, the framework cannot be more powerful
than that. You will be using tools that you could&amp;rsquo;ve written yourself
with your current skill level, but you won&amp;rsquo;t even get the benefit of
writing it yourself. Hopefully, those tools will be safer and save you
a lot of time, but saved time cranking out widgets at work will not
directly cause you to better understand programming.&lt;/p&gt;

&lt;h2 id=&#34;paradigms:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Paradigms&lt;/h2&gt;

&lt;p&gt;It is fashionable these days to get into functional programming. If
you haven&amp;rsquo;t learned a language that supports a functional paradigm, I
highly recommend that as a good place to start. That being the case,
don&amp;rsquo;t forget to add a logic, a literate, and a declarative programming
language to your list too (you have ten years remember, you&amp;rsquo;ll need a
list). Why not pile on a stack based language too?&lt;/p&gt;

&lt;h2 id=&#34;libraries:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Libraries&lt;/h2&gt;

&lt;p&gt;While it is important to be aware of the libraries in your space, I
would say these often provide the least mind-expanding
opportunities. A library, much like a framework, is usually
constrained by the power of the language. In most languages, libraries
are just convenience abstractions at or below the same abstraction
layer as the rest of your code. I would never consider doing my
day-to-day work without the full power of available libraries, but
they are not going to help me think any better about the work.&lt;/p&gt;

&lt;h2 id=&#34;meta-books:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;&amp;ldquo;Meta&amp;rdquo; books&lt;/h2&gt;

&lt;p&gt;A vast number of books exist that attempt to impart something of a
&amp;ldquo;mindset&amp;rdquo; for the developer. Usually, the author is retelling his
experiences, which can be entertaining, but of limited reuse. The best
meta books are those that use actual research and data to try to
explain our industry. Books like Peopleware, Code Complete, and
Pragmatic Programmer are great in this regard. These best books can
cause you to see the creation of software artifacts with a totally
different light: e.g. I remember first reading about using a
programming language to generate automatically the source files for a
given project. At the time for me, it was revolutionary.&lt;/p&gt;

&lt;h2 id=&#34;pattern-books:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Pattern Books&lt;/h2&gt;

&lt;p&gt;I lately have come to think &amp;ldquo;pattern books&amp;rdquo; like Domain Driven Design,
Design Patterns, Patterns of Enterprise Architecture, Refactoring, etc
are just a way to try to replicate missing features in a language of a
lower power. These seem to be written for entirely Java and C#, and are mostly
complex solutions to complex problems created by the lack of power of the language. Apparently, I
am not alone: &lt;a
href=&#34;http://www.c2.com/cgi/wiki?AreDesignPatternsMissingLanguageFeatures&#34;&gt;Are Design Patterns Missing Language Features?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That being said, I think some parts of these books are helpful,
specifically, the ubiquitous language ideas from Domain Driven
Design. If your team has decided on always using the terms from a
certain book, and you are the only person who does not know them, I do
recommend at least skimming it just to ensure smooth communication.&lt;/p&gt;

&lt;h2 id=&#34;suggestions:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Suggestions&lt;/h2&gt;

&lt;p&gt;I won&amp;rsquo;t suggest too many books or languages, but those I do are very
highly recommended.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start&#34;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;The best book I&amp;rsquo;ve ever read. No other book I&amp;rsquo;ve read even comes close to beating this for sheer value per minute as this book. Do all the exercies, and you&amp;rsquo;ll be way ahead of the curve.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Code Complete&lt;/li&gt;
&lt;li&gt;Clean Code&lt;/li&gt;
&lt;li&gt;Pragmatic Programmer&lt;/li&gt;
&lt;li&gt;Productive Programming&lt;/li&gt;
&lt;li&gt;Peopleware&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wrap-up:904c8ce0eabb9b2e2b79e3dcb6c341c9&#34;&gt;Wrap up&lt;/h2&gt;

&lt;p&gt;It takes courage to step outside your comfort zone and learn something
new. You might be the only person learning something new on your
team. That is ok! Don&amp;rsquo;t worry about &amp;ldquo;converting&amp;rdquo; everyone else to the
path of learning, and do not make fun of them or the only language
they know. (Developers who only know one language take any comment
good or bad about &amp;ldquo;their&amp;rdquo; language as a comment about themselves.) If
you do make fun of them, you will start to resent them. It&amp;rsquo;ll make you
look like an outsider, and they will ignore you and finally push you
out of the team.&lt;/p&gt;

&lt;p&gt;When you learn a new thing, be very careful to not run around trying
to use it everywhere. I am very careful to not use any new tool in
production until I&amp;rsquo;ve &amp;ldquo;moved on&amp;rdquo; to learning another tool, so I could
critically consider the best tool for the job without the &amp;ldquo;honeymoon&amp;rdquo;
effect clouding my judgment.&lt;/p&gt;

&lt;p&gt;My experience has been: keep getting better, and you will find
yourself in better and better places to work. A person who puts in the
effort to really master the craft is easy to spot and hard to
fake. Most people want to work with those who think like them, and you
cannot think like a master engineer only knowing one tool, so get
started now, and have fun!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inverted Polymorphism</title>
      <link>http://deliberate-software.com/inversed-polymorphism/</link>
      <pubDate>Mon, 28 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/inversed-polymorphism/</guid>
      <description>&lt;p&gt;In my last post on the power of pattern matching, we saw how powerful
the &lt;code&gt;match&lt;/code&gt; statement is in F#. Using &lt;code&gt;match&lt;/code&gt; allows the compiler to
give us warnings for missing cases, no matter what the type.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at how pattern matching changes our design, allowing for an
inversion of the usual OO way of polymorphism. Here is an example that
is probably familiar to everyone: getting a database connection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface IPaymentRepository {
    IEnumerable&amp;lt;IPayment&amp;gt; GetAll ();
}
// InMemory.cs
public class InMemory : IPaymentRepository {
    public IEnumerable&amp;lt;IPayment&amp;gt; GetAll (){
        return Config.payments.Values;
    }
}
// Postgres.cs
public class Postgres : IPaymentRepository {
    public IEnumerable&amp;lt;IPayment&amp;gt; GetAll (){
        throw new NotImplementedException();
    }
}
// RepositoryFactory.cs
public class RepositoryFactory {
    public static IPaymentRepository GetPaymentRepo () {
        if (Config.configuration[&amp;quot;useInMemory&amp;quot;] == &amp;quot;true&amp;quot;) {
            return new InMemory();
        } else {
            return new Postgres();
        }
    }
}

// somewhere in the code...
var repo = RepositoryFactory.GetPaymentRepo();
var payments = repo.GetAll();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example here, we have two concrete implementers of the
&lt;code&gt;IPaymentRepository&lt;/code&gt;, each one with their own implementations. This is
a typical OO way to deal with polymorphism. Usually, &amp;ldquo;best practices&amp;rdquo;
would put each of these classes in their own files.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at how we would invert the polymorphism of the C# classes
and interfaces to use pattern matching.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PaymentRepository = 
   | InMemory
   | Postgres

let GetAll = function
    | InMemory -&amp;gt; Config.payments.Values;
    | Postgres -&amp;gt; raise(NotImplementedException())
        
let GetPaymentRepo = 
    match Config.configuration.[&amp;quot;useInMemory&amp;quot;] with
        | &amp;quot;true&amp;quot; -&amp;gt; InMemory
        | _ -&amp;gt; Postgres 

// somewhere in the code ...
let repo = Payments.GetPaymentRepo
let payments = Payments.GetAll repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how we separated our behavior from our types? The
&lt;code&gt;PaymentRepository.InMemory&lt;/code&gt; and the &lt;code&gt;PaymentRepository.Postgres&lt;/code&gt; now
are just empty types, much like an &lt;code&gt;Enum&lt;/code&gt;. We are still able to get
polymorphic behavior from them, using &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But why would we want to store our behavior separate from the type?&lt;/p&gt;

&lt;p&gt;By storing the behavior separate from the type, changes that effect a
single behavior (adding a new function, changing a function&amp;rsquo;s api,
removing a function) are easier, because they are all grouped
together. A change to the api of the &lt;code&gt;GetAll&lt;/code&gt; function is harder in
the traditional OO interface structure, requiring modifying several
files.&lt;/p&gt;

&lt;p&gt;Similarly, a change requiring adding a new type is difficult in a
pattern matching structure, as it will require finding every pattern
match and adding in the additional case. Thankfully, the F# compiler
checks both pattern matches and interfaces for us, letting us use the
best tool for the job!&lt;/p&gt;

&lt;p&gt;As to safety, adding a new type is easy with interfaces, but the
developer is left without assistance to find all places the concrete
classes are instantiated and add the new type. Neither compiler will
offer any warnings for a new interface subclass. For pattern matching
polymorphism, the compiler will warn that there are missing cases
every place a change needs to be made. While harder to add a new type
with pattern matching, it is safer.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Adding a Type&lt;/th&gt;
&lt;th&gt;Modifying Behavior&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;OO Interfaces/Classes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Easier / Less Safe&lt;/td&gt;
&lt;td&gt;Harder / Safe&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Pattern Matching Types&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Harder / Safe&lt;/td&gt;
&lt;td&gt;Easier / Safe&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
I almost always find myself modifying the functions of an
interface more than I find myself adding new types. For that typical
use case, pattern matching is probably the better choice.&lt;/p&gt;

&lt;p&gt;Consider the change where we want to add a new function to the
&lt;code&gt;IPaymentRepository&lt;/code&gt; interface and change the location of the in
memory dictionary to be stored internally. In the interfaces and
classes example, that requires editing &lt;em&gt;three separate files&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// IPaymentRepostory.cs
public interface IPaymentRepository {
    IEnumerable&amp;lt;IPayment&amp;gt; GetAll ();
    void Add(IPayment payment);
}
// InMemory.cs
public class InMemory : IPaymentRepository {
    public Dictionary&amp;lt;int, IPayment&amp;gt; payments = new Dictionary&amp;lt;int, IPayment&amp;gt;();
    public void Add(IPayment payment) {
        payments.Add(payment.GetId(),payment);
    }
    public IEnumerable&amp;lt;IPayment&amp;gt; GetAll (){
        return payments.Values;
    }
}
// Postgres.cs
public class Postgres : IPaymentRepository {
    public void Add(IPayment payment) {
        throw new NotImplementedException();
    }
    public IEnumerable&amp;lt;IPayment&amp;gt; GetAll (){
        throw new NotImplementedException();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the change to add a new function in the pattern matching example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PaymentRepository = 
   | InMemory of Dictionary&amp;lt;int, IPayment&amp;gt;
   | Postgres

let Add db (payment:IPayment) = 
    match db with
        | InMemory payments -&amp;gt; payments.Add(payment.GetId(),payment);
        | Postgres -&amp;gt; raise(NotImplementedException())

let GetAll = function
        | InMemory payments -&amp;gt; payments.Values;
        | Postgres -&amp;gt; raise(NotImplementedException())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case you were concerned that these F# types do not have any state,
they actually can have fields just like regular classes. Notice the
&lt;code&gt;Dictionary&amp;lt;int, IPayment&amp;gt;&lt;/code&gt; next to the &lt;code&gt;InMemory&lt;/code&gt; type? That is a
field! The new field does not need to be named until used in a pattern
match, so the only time it is named is &lt;code&gt;payments&lt;/code&gt; inside the &lt;code&gt;Add&lt;/code&gt; and
&lt;code&gt;GetAll&lt;/code&gt; functions after we pattern match &lt;code&gt;InMemory&lt;/code&gt;. In fact, if we
didn&amp;rsquo;t add it in the pattern match, the compiler would give us a
warning!&lt;/p&gt;

&lt;p&gt;Between the options of traditional interfaces verses pattern matching,
neither way is truly the best for every circumstance: each comes with
a trade-off. I liken the trade-offs to the &amp;ldquo;grain of the
data&amp;rdquo;. Whichever way your system is likely to change the most, that is
the way you want to optimize your type. The good news is: in F# you
can have a mix of both, and it is relatively easy to convert back and
forth depending on how your system is changing the most.&lt;/p&gt;

&lt;p&gt;Personally, I find F# pattern matching to be significantly easier to
read. The same code in C# requires twice the lines in three separate
files, which adds a complexity burden for no reason. The F# code is
safer, smaller, and easier to modify than the C# equivalent.&lt;/p&gt;

&lt;p&gt;If you write code in C# or VB.NET right now, you could add in a
project in F# today. All three languages are callable from the other
two, so you could start by breaking out a small library that uses
these feature immediately. F# modules and classes are callable from C#
just like any other DLL library. In my mind, this is what sets F#
apart from other languages: it is more powerful and safe than C#, but
with high performance and interoperability with existing C# libraries.&lt;/p&gt;

&lt;p&gt;If you want additional reading on the topic of polymorphism, check out
&lt;a href=&#34;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-17.html#%_sec_2.4&#34;&gt;section 2.4&lt;/a&gt; in SICP.&lt;/p&gt;

&lt;p&gt;Discussion in the HN &lt;a href=&#34;https://news.ycombinator.com/item?id=7763069&#34;&gt;comments&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern Matching - Making the Compiler Work For You</title>
      <link>http://deliberate-software.com/function-pattern-matching/</link>
      <pubDate>Mon, 28 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/function-pattern-matching/</guid>
      <description>&lt;p&gt;Pattern matching is a simple tool that will make your code safer and
easier to read.&lt;/p&gt;

&lt;p&gt;Consider the following code that converts an Int to a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum Language {
    Spanish,
    English
}
public static string convert(int number, Language lang) {
    string ret = &amp;quot;&amp;quot;;
    if (lang == Language.English) {
        switch(number) {
            case 0: ret = &amp;quot;zero&amp;quot;; break;
            case 1: ret = &amp;quot;one&amp;quot;; break;
            default: ret = &amp;quot;...&amp;quot;; break;
        }
    } else if (lang == Language.Spanish) {
        switch(number) {
            case 0: ret = &amp;quot;zero&amp;quot;; break;
            case 1: ret = &amp;quot;uno&amp;quot;; break;
            default: ret = &amp;quot;~~~&amp;quot;; break;
        }
    }
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens when we make this simple change?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum Language {
    Spanish,
    English,
    German
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does the code still compile? Sure does! Does the compiler/IDE offer us
any indication that something is missing? Nope! Our code has a
potential bug that is only exposed at run-time, and nothing will tell
us that. We made it fail gracefully by ensuring our code always
returns at least an empty string, but we have created a bug that can
only really be caught by something external: either automated tests or
manual checking.&lt;/p&gt;

&lt;p&gt;The OO purists and &amp;ldquo;Anti-If&amp;rdquo; guys are probably leaping out of their
seats. &amp;ldquo;Use classes and an interface!&amp;rdquo; they yell. Ok, sure. I assert
that it just makes things even worse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public interface ILanguage {
    String convert(int num);
}
public class Spanish : ILanguage {
    public String convert (int num) {
        var ret = &amp;quot;&amp;quot;;
        switch (num) {
            case 0: ret = &amp;quot;zero&amp;quot;; break;
            case 1: ret = &amp;quot;uno&amp;quot;; break;
            default: ret = &amp;quot;~~~&amp;quot;; break;
        }
        return ret;
    }
}
public class English : ILanguage {
    public String convert (int num) {
        var ret = &amp;quot;&amp;quot;;
        switch (num) {
            case 0: ret = &amp;quot;zero&amp;quot;; break;
            case 1: ret = &amp;quot;one&amp;quot;; break;
            default: ret = &amp;quot;...&amp;quot;; break;
        }
        return ret;
    }
}
// somewhere else...
public static string convert(int x, Language lang) {
    return getLanguage(lang).convert(x);
}
public static ILanguage getLanguage(Language lang) {
    switch (lang) {
        case Language.English: return new English() ; break;
        case Language.Spanish: return new Spanish() ; break;
        default: throw new Exception();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have turned 21 lines in one file into 36 in three files (not
counting namespaces and imports). Does this new structure give us any
additional safety when we add a new concrete implementation? How about
when we add a new enum value? This code is even more likely to cause
bugs than the first, because now we have an implicit coupling between
the enum and the concrete class. We could get rid of the enum, and
&amp;ldquo;pass in concrete class&amp;rdquo; but &lt;em&gt;something&lt;/em&gt; still has to say which
concrete class to instantiate.&lt;/p&gt;

&lt;p&gt;Imagine if the compiler could warn us when either the enum or the
class changed. Imagine if instead of having to hunt down the possible
uses, we could just compile and fix the errors.&lt;/p&gt;

&lt;p&gt;Good news, we can!&lt;/p&gt;

&lt;p&gt;Check out this F# code. If you have never seen F# before, I know, it
looks completely crazy! It &lt;em&gt;still&lt;/em&gt; looks a little weird to me, but
just try to read it. I think you will surprise yourself. This is a
function called &lt;code&gt;convert&lt;/code&gt;, and if you keep in mind that the types
always come AFTER the value, the code makes a lot more sense. A
parameter in C# would be &lt;code&gt;int number&lt;/code&gt;; in F# it is written
&lt;code&gt;number:Int&lt;/code&gt;. Don&amp;rsquo;t ask me why. The &lt;code&gt;match number with&lt;/code&gt; is just how
you do the equivalent to a &lt;code&gt;switch/case&lt;/code&gt; in C#, but you will see in a
second it is a lot more powerful!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let convert(number:Int, lang:Language) :string =
    match lang with
        | Language.English -&amp;gt; 
            match number with
               | 1 -&amp;gt; &amp;quot;one&amp;quot; 
               | 2 -&amp;gt; &amp;quot;two&amp;quot; 
               | _ -&amp;gt; &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the same enum from the C# file, but it is missing
something, right? Where are the Spanish and German parts? I try to
compile this and what do I see?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/Program.fs(11,11): Warning FS0025: Incomplete pattern
matches on this expression. For example, the value &#39;enum&amp;lt;Language&amp;gt;
(0)&#39; may indicate a case not covered by the pattern(s). (FS0025)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Spittake mushroom soup, the compiler just caught a potential bug for
us! A C# run-time bug no less! Not only is this very powerful, but it
is so simple. I can code the way I normally do, only now I get
additional safety for free! And no unit or integration test would ever
catch this class of errors.&lt;/p&gt;

&lt;p&gt;Heck, if you really want to keep your classes and interfaces in C#,
you can have some &amp;ldquo;glue code&amp;rdquo; in F#, and still get all the benefit!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let convert(number, lang) =
    match lang with
        | Language.English -&amp;gt; English().convert(number)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This still calls the C# class above, and now the compiler gives us a
warning when we add a new enum value!&lt;/p&gt;

&lt;p&gt;In this way, pattern matching is able to clearly remove edge cases. We
converted an unsafe &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; statement into a type safe
&lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;BONUS ROUND!&lt;/p&gt;

&lt;p&gt;What we have already seen of pattern matching makes it a better
&lt;code&gt;switch/case&lt;/code&gt; but what about the &lt;code&gt;if&lt;/code&gt; statement? Thankfully the
&lt;code&gt;match/with&lt;/code&gt; statement allows for patterns matched to have a &lt;code&gt;when&lt;/code&gt;
clause which only matches when the condition is true:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let convert(number, lang) =
    match lang with
        | Language.English -&amp;gt; 
            match number with 
                | x when x &amp;gt; 5 -&amp;gt; &amp;quot;Large!&amp;quot;
                | 0 -&amp;gt; &amp;quot;zero&amp;quot;
        | Language.Spanish -&amp;gt; 
            match number with 
                | x when x &amp;gt; 5 -&amp;gt; &amp;quot;Grande!&amp;quot;
                | 0 -&amp;gt; &amp;quot;zero&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the compiler again give us:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/home/jack/programming/monads-fsharp/monads-fsharp/Program.fs(19,19):
Warning FS0025: Incomplete pattern matches on this expression. For
example, the value &#39;1&#39; may indicate a case not covered by the
pattern(s). However, a pattern rule with a &#39;when&#39; clause might
successfully match this value. (FS0025) (monads-fsharp)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s right, it checks numbers too.&lt;/p&gt;

&lt;p&gt;Lastly, it is possible to match on a combination of values, all at
once. We can convert our more complex structure to something simpler
using this trick, and the compiler is still intelligent enough to
check for missing cases.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let convert(number, lang) =
    match lang, number with
        | Language.English, 0 -&amp;gt; &amp;quot;zero&amp;quot; 
        | Language.English, 1 -&amp;gt; &amp;quot;one&amp;quot;
        | Language.English, x when x &amp;gt; 1 -&amp;gt; &amp;quot;Larger than one!&amp;quot;
        | Language.English, _ -&amp;gt; &amp;quot;dunno&amp;quot;
        | Language.Spanish, 0 -&amp;gt; &amp;quot;zero&amp;quot; 
        | Language.Spanish, x when x &amp;gt; 5 -&amp;gt; &amp;quot;Grande!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we introduce the &lt;code&gt;_&lt;/code&gt; which is equivalent to a &lt;code&gt;default&lt;/code&gt; in a C#
&lt;code&gt;switch/case&lt;/code&gt; statement. The pattern &lt;code&gt;Language.English, _ -&amp;gt;&lt;/code&gt; sets a
default for any number in &lt;code&gt;Language.English&lt;/code&gt; not already matched. The
bug in the code here is the missing &lt;code&gt;Language.Spanish&lt;/code&gt; with numbers
1-5. What does the compiler say?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Program.fs(11,11): Warning FS0025: Incomplete pattern matches on this
expression. For example, the value &#39;(_,1)&#39; may indicate a case not
covered by the pattern(s). However, a pattern rule with a &#39;when&#39;
clause might successfully match this value. (FS0025) (monads-fsharp)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lastly, let&amp;rsquo;s show the final result of converting our original
function to F#. If your entire function is just a single pattern
match, you can remove the &lt;code&gt;match/with&lt;/code&gt; line and use the &lt;code&gt;function&lt;/code&gt;
keyword, and simply match against the parameters (which I reversed for
clarity, but do not need to be written).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let convert = function
    | Language.English, 0 -&amp;gt; &amp;quot;zero&amp;quot; 
    | Language.English, 1 -&amp;gt; &amp;quot;one&amp;quot;
    | Language.English, _ -&amp;gt; &amp;quot;...&amp;quot;
    | Language.Spanish, 0 -&amp;gt; &amp;quot;zero&amp;quot; 
    | Language.Spanish, 1 -&amp;gt; &amp;quot;uno&amp;quot; 
    | Language.Spanish, _ -&amp;gt; &amp;quot;~~~&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our original 17 line convert function, converted into a &lt;em&gt;safer&lt;/em&gt; 7
lines! I never had to specify what the types of lang, number and the
return type are, because the compiler is able to figure that out from
the code I wrote.&lt;/p&gt;

&lt;p&gt;If you are not convinced at this point that pattern matching is a big
step forward in the safety and ease of development, I am not sure what
else would convince you. More safety means less time spent tracking
down bugs and more time adding on features!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Intro To Macros</title>
      <link>http://deliberate-software.com/intro-to-macros/</link>
      <pubDate>Mon, 19 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deliberate-software.com/intro-to-macros/</guid>
      <description>&lt;p&gt;
Macros are the most powerful way to manipulate the syntax of your language. Macros make it possible to completely modify your language to match your domain. To explain them, think for a minute about functions using the simple “substitution model” used to teach functions to beginner programmers. The substitution model has the reader replace a function call with the body of the called function.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def doCalc ()
   return 1 + 2
end
def doAwesome (x) 
   return doCalc() + x
end 
 
#before substitution...
def test () 
   return doAwesome(3)
end
 
# when substituted...
def test ()
   return (1 + 2) + 3
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Ignoring scoping, the function/call system allows for immense power in programing languages. The function lets you &#34;expand&#34; a simple call into a much larger block of code. The expanded code can be vastly large. In our example above, the (doCalc) function is small, but it reality it could be doing hundreds of lines of code, which also would have to be substituted in place. The difference is real functions do not work this way. Real functions have their values evaluated before getting passed in as parameters.
&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;Macros are similar to the substitution model, with one expressed difference: by default, macros operate on the text of the code itself, not the values. Think of how expansion works in the simple if statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if workday(today()) do
  x = 1 + 1
else
  x = doOtherHugeCalc()
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;Does the huge calc function execute each time? Not at all, you are guaranteed that only one will happen at any given run through that block of code.&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;Let’s say you wanted to make a generic function that would abstract away that call, and let you return the values, maybe something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def ifworkday(first, second)
  if workday(today()) do
    return first
  else
    return second
  end
end
x = ifworkday(1 + 1, doOtherHugeCalc())
 
#when the values are “shown”
def ifworkday(2, 3)
  if workday(today()) do
    return 2
  else
    return 3
  end
end
x = ifworkday(2, 3) # CALLED BOTH FUNCTIONS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
But wait, now BOTH functions get called, you are doing exactly twice as many huge calcs as needed. Now, those familiar with javascript probably are already itching with the solution, &#34;JUST WRAP THEM IN ANONYMOUS FUNCTIONS!!!&#34;. I hear you, sure that works in this super simple example, but macros let you do this without that extra wordiness.  Macros defer evaluating parameters. Think of a macro as a function, but the biggest difference is parameters DON&#39;T get called till you choose to call them.
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if it is a macro...
defmacro ifworkday(first, second)
  if workday(today()) do
    return first
  else
    return second
  end
end
ifworkday(1+1, doOtherHugeCalc())
 
#when the values are “shown”
defmacro ifworkday(&amp;quot;1+1&amp;quot;, &amp;quot;doOtherHugeCalc()&amp;quot;)
  if workday(today()) do
    return eval(&amp;quot;1+1&amp;quot;)
  else
    return eval(&amp;quot;doOtherHugeCalc()&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;Now, in this simple ruby example, I had to use strings and eval to approximate what happens with macros in other languages. Since this is unwieldy, let’s switch to clojure, where it is more natural.&lt;/p&gt;

&lt;p&gt;I said that macros defer evaluation, they do that, but they also do much more. Lets look at a clojure list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;‘(a b c d)
;;=&amp;gt; (a b c d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;This is a list of four symbols. Symbols are basically like an enum or a keyword that only equals itself. So it is possible to say:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(= ‘a ‘a)
;;=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;but that’s pretty much it. If I tried to evaluate a symbol, it would complain that the symbol has no definition, since it is trying to treat it like a variable lookup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;;; nothing gets evaluated inside the list at all..
‘(a b c) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;Now you are left with a list of symbols, unevaluated. The defmacro form, for each parameter, gives you such a list of unevaluated symbols.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;;;before compilation
(defmacro ifWorkday [bigCalc1, bigCalc2]
  `(if (workday (today))
    ~bigCalc1
    ~bigCalc2))
 
;; the call
(ifWorkday (+ 1 1) (otherBigCalc))
 
;;... after compilation...
(defmacro ifWorkday [(+ 1 1), (otherBigCalc)]
  `(if (workday (today))
    (+ 1 1)
    (otherBigCalc)))
;; after compilation the call gets _transformed_ into:
(if (workday (today)) (+ 1 1) (otherBigCalc))
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;The ` is called syntax quote, it disables evaluation much like quote does (it just also namespaces everything inside for your convenience). The ~ is called an unquote, and it turns evaluation back on. In any given space, if you have a function called (id), and you called it like (`~id), it would mean the same as just calling (id), because you turned off evaluation, then turned it back on. Above, the bigCalc parameters are filled with the actual values passed in, the lists unevaluated of ‘(+ 1 1) and ‘(otherBigCalc).
&lt;/p&gt;

&lt;p&gt;
I like to think of the return from a macro as a “template” to replace the original call with. Take the call (ifWorkday (+ 1 1) (otherBigCalc)). When calling the macro, the last thing returned from the macro is expected to be a list of clojure code to replace the original call at compile time. So, at compile time, (ifWorkday (+ 1 1) (otherBigCalc)) is replaced with (if (workday (today)) (+ 1 1) (otherBigCalc)) which is the return from the macro.&lt;/p&gt;

&lt;p dir=&#34;ltr&#34;&gt;But that is a stupid example. Making your own if statements is the most basic uses of macros. But it demonstrates the point: macros generate code. This is profound, but hard to grasp for the first time. Macros expand code before compilation time, and therefore can be used to generate lots of code automatically.&lt;/p&gt;

&lt;p&gt;
For extra credit, let’s take a bigger example in the same vein as our custom ifWorkday. I am making a game, and in it, I want an easy abstraction that gives me back one of several options with a custom percent chance. Ideally, something like
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(if25 (doFirst) (doSecond))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
where the number corresponds to the percent chance that the next item will be executed and returned. In this example, (doFirst) will only happen 25% of the time and (doSecond) 75% of the time. This demonstrates a more interesting use of macros, the ability to generate other functions (or even other macros). Here is the code:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmacro make-percents []
  `(list ~@(map (fn [num]                                     
                  (let [macro-name (symbol (str &amp;quot;if&amp;quot; num))]    
                    `(defmacro ~macro-name [x# y#]               
                      `(if (&amp;gt; ~~num (rand-int 100)) ~x# ~y#))))  
                (range 100))))
(make-percents)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
This macro only needs to be called once, and what it does is generates this:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defmacro if0 [x__2603__auto__ y__2604__auto__]
  `(if (&amp;gt; 0 (rand-int 100)) ~x__2603__auto__ ~y__2604__auto__))
(defmacro if1 [x__2604__auto__ y__2605__auto__]
  `(if (&amp;gt; 1 (rand-int 100)) ~x__2604__auto__ ~y__2605__auto__))
(defmacro if2 [x__2606__auto__ y__2607__auto__]
  `(if (&amp;gt; 2 (rand-int 100)) ~x__2606__auto__ ~y__2607__auto__))
;;...
(defmacro if99 [x__2609__auto__ y__2601__auto__]
  `(if (&amp;gt; 99 (rand-int 100)) ~x__2609__auto__ ~y__2601__auto__))
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;I hope the profundity of this hits you like a ton of bricks. With under 10 lines of macro code (and calling it) we auto-generated 100 macros! This 10 lines of code gets expanded to 100 more lines! Sure, this is a simple, almost silly example, but imagine what you could do with this sort of power. In a more complex example, you could be auto-generating vast amounts of code this way, code that you don’t have to write every time by hand. Don&#39;t let the x__2506__auto__ parameter names scare you, I will explain that in a bit.&lt;/p&gt;
&lt;p&gt;
Those generated macros should not be too hard to understand after the previous ifWorkday macro, and they can be called just like we expect. Let&#39;s deconstruct (make-percents).
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;`(list ~@(map (fn [num]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;The ~@ is like unquote from above, the only difference is instead of just unquoting a list to be evaluated, it extracts the values from the list and sticks them in place. I like to think of it as just removing the outer parens in the unquoted list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [x ‘(1 2 (3 4))]
  `(+ 8 ~@x))
;; =&amp;gt; (clojure.core/+ 8 1 2 (3 4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;The (list) function is just how we make a list of elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(list ‘a ‘b ‘c)
;;=&amp;gt; (a b c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The (map) function has two arguments: the first, a function; the second, a list of elements to “map” over.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;~@(map (fn [num] (...))
       (range 100))
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;As you can see here, the ~@() tells us to unquote the whole form, re-enabling the evaluation, and therefore running the map call. The map then calls the anonymous function 100 times, with the num being the numbers 0..99. Inside the anon function we have a let binding:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [macro-name (symbol (str &amp;quot;if&amp;quot; num))] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;This line is more simple, it makes a let that binds to the value macro-name a symbol that looks like ‘if1, ‘if2, .. depending on which iteration of the loop you are on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;`(defmacro ~macro-name [x# y#]                
  `(if (&amp;gt; ~~num (rand-int 100)) ~x# ~y#)))) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p dir=&#34;ltr&#34;&gt;Here is the actual returned “template” of the macro. The # at the end of the parameter name ensures that it is unique, which is really really useful when you consider that the code returned from a macro replaces the call in place. To make sure you don’t accidentally double bind the same name, clojure will give you a warning like “cannot let unqualified name” if you try to let a value without including the # at the end inside a template, another really handy feature. What gets generated by x# looks something like x__2506__auto__ which is guaranteed to be unique. The reason you need this is in case there was another value bound to x inside your code, it could cause a conflict, and in certain circumstances, really break your code, so this prevents such conflicts. You should only need these when creating parameters or let bindings inside the template. All the values &#34;outside&#34; the template do not need to have the # appended to their names, since they will not actually be a part of the returned template.&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;The only odd thing here is the double ~~num. Notice how many quote levels deep we are. It is possible to unquote to “step” back up a level in the template. By the time we get to the ~~num, the original function parameter of num was two “levels” higher, so to access it, we have to “step up” two levels. Let me highlight it in colors, to make it easier to see.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliberate-software.com/images/macro.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;p dir=&#34;ltr&#34;&gt;See how by unquoting ~macro-name one level in line 3, and unquoting ~~num two levels on line 4, we bring them both back “up” to the “red” level where they were defined? Similarly, by unquoting ~x# and ~y# one level on line 4, we bring them back “up” to their “blue” definition level? This is an incredibly powerful tool that allows immense expansion of code in a tiny amount of space. If you think of the returned code form as a “template”, this quoting and unquoting lets you step in and out of evaluation with ease.&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;In the end, when the (make-percents) macro is called, it produces 100 macros that are callable just like any other macro. To tell the whole story, I wrote this into my game, then decided I wanted a more sophisticated macro that could take any number of percentages, but this remained a good way to explain this specific pattern of looped macro generation.&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;Hopefully, this article caused you to see how incredibly powerful macros can be, allowing effectively infinite auto-generation of code. The field of macros is still very under-explored, as most languages do not allow them at all, they remain a largely undiscovered, and yet incredibly powerful tool.&lt;/p&gt;
&lt;p dir=&#34;ltr&#34;&gt;For further reading, I highly recommend Let Over Lambda, the first 6 chapters of which are free &lt;a href=&#34;http://letoverlambda.com/index.cl/toc&#34;&gt;here&lt;/a&gt;. Let Over Lambda is written with examples in Common Lisp, but the macro parts are very similar in Clojure, so is a valuable read.&lt;/p&gt;
&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>